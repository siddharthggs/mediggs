"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// electron/src/constants.ts
var import_node_path, import_electron, APP_FOLDER, getAppDataDir, paths;
var init_constants = __esm({
  "electron/src/constants.ts"() {
    "use strict";
    import_node_path = __toESM(require("node:path"));
    import_electron = require("electron");
    APP_FOLDER = "Mediclone";
    getAppDataDir = () => {
      const base = import_electron.app.getPath("appData");
      return import_node_path.default.join(base, APP_FOLDER);
    };
    paths = {
      database: () => import_node_path.default.join(getAppDataDir(), "data", "mediclone.db"),
      backups: () => import_node_path.default.join(getAppDataDir(), "backups")
    };
  }
});

// electron/src/db/prismaClient.ts
var import_node_fs, import_node_path2, import_client, prisma, ensureDatabase, getPrismaClient, disconnectPrisma;
var init_prismaClient = __esm({
  "electron/src/db/prismaClient.ts"() {
    "use strict";
    import_node_fs = __toESM(require("node:fs"));
    import_node_path2 = __toESM(require("node:path"));
    import_client = require("@prisma/client");
    init_constants();
    prisma = null;
    ensureDatabase = () => {
      const databasePath = paths.database();
      const dataDir = import_node_path2.default.dirname(databasePath);
      if (!import_node_fs.default.existsSync(dataDir)) {
        import_node_fs.default.mkdirSync(dataDir, { recursive: true });
      }
      if (!process.env.DATABASE_URL) {
        process.env.DATABASE_URL = `file:${databasePath}?timeout=30000&mode=rwc`;
      }
    };
    getPrismaClient = () => {
      if (!prisma) {
        ensureDatabase();
        prisma = new import_client.PrismaClient({
          // Increase the default connect timeout
          errorFormat: "pretty",
          log: [
            { level: "query", emit: "event" },
            { level: "error", emit: "event" },
            { level: "warn", emit: "event" }
          ]
        });
        prisma.$on("query", (e) => {
          if (e.duration > 1e3) {
            console.warn(`Slow query detected (${e.duration}ms):`, e.query);
          }
        });
        prisma.$on("error", (e) => {
          console.error("Prisma error:", e.message);
        });
      }
      return prisma;
    };
    disconnectPrisma = async () => {
      if (prisma) {
        await prisma.$disconnect();
        prisma = null;
      }
    };
  }
});

// node_modules/electron-log/src/renderer/electron-log-preload.js
var require_electron_log_preload = __commonJS({
  "node_modules/electron-log/src/renderer/electron-log-preload.js"(exports2, module2) {
    "use strict";
    var electron = {};
    try {
      electron = require("electron");
    } catch (e) {
    }
    if (electron.ipcRenderer) {
      initialize(electron);
    }
    if (typeof module2 === "object") {
      module2.exports = initialize;
    }
    function initialize({ contextBridge, ipcRenderer }) {
      if (!ipcRenderer) {
        return;
      }
      ipcRenderer.on("__ELECTRON_LOG_IPC__", (_, message) => {
        window.postMessage({ cmd: "message", ...message });
      });
      ipcRenderer.invoke("__ELECTRON_LOG__", { cmd: "getOptions" }).catch((e) => console.error(new Error(
        `electron-log isn't initialized in the main process. Please call log.initialize() before. ${e.message}`
      )));
      const electronLog = {
        sendToMain(message) {
          try {
            ipcRenderer.send("__ELECTRON_LOG__", message);
          } catch (e) {
            console.error("electronLog.sendToMain ", e, "data:", message);
            ipcRenderer.send("__ELECTRON_LOG__", {
              cmd: "errorHandler",
              error: { message: e?.message, stack: e?.stack },
              errorName: "sendToMain"
            });
          }
        },
        log(...data) {
          electronLog.sendToMain({ data, level: "info" });
        }
      };
      for (const level of ["error", "warn", "info", "verbose", "debug", "silly"]) {
        electronLog[level] = (...data) => electronLog.sendToMain({
          data,
          level
        });
      }
      if (contextBridge && process.contextIsolated) {
        try {
          contextBridge.exposeInMainWorld("__electronLog", electronLog);
        } catch {
        }
      }
      if (typeof window === "object") {
        window.__electronLog = electronLog;
      } else {
        __electronLog = electronLog;
      }
    }
  }
});

// node_modules/electron-log/src/core/scope.js
var require_scope = __commonJS({
  "node_modules/electron-log/src/core/scope.js"(exports2, module2) {
    "use strict";
    module2.exports = scopeFactory;
    function scopeFactory(logger2) {
      return Object.defineProperties(scope, {
        defaultLabel: { value: "", writable: true },
        labelPadding: { value: true, writable: true },
        maxLabelLength: { value: 0, writable: true },
        labelLength: {
          get() {
            switch (typeof scope.labelPadding) {
              case "boolean":
                return scope.labelPadding ? scope.maxLabelLength : 0;
              case "number":
                return scope.labelPadding;
              default:
                return 0;
            }
          }
        }
      });
      function scope(label) {
        scope.maxLabelLength = Math.max(scope.maxLabelLength, label.length);
        const newScope = {};
        for (const level of logger2.levels) {
          newScope[level] = (...d) => logger2.logData(d, { level, scope: label });
        }
        newScope.log = newScope.info;
        return newScope;
      }
    }
  }
});

// node_modules/electron-log/src/core/Buffering.js
var require_Buffering = __commonJS({
  "node_modules/electron-log/src/core/Buffering.js"(exports2, module2) {
    "use strict";
    var Buffering = class {
      constructor({ processMessage }) {
        this.processMessage = processMessage;
        this.buffer = [];
        this.enabled = false;
        this.begin = this.begin.bind(this);
        this.commit = this.commit.bind(this);
        this.reject = this.reject.bind(this);
      }
      addMessage(message) {
        this.buffer.push(message);
      }
      begin() {
        this.enabled = [];
      }
      commit() {
        this.enabled = false;
        this.buffer.forEach((item) => this.processMessage(item));
        this.buffer = [];
      }
      reject() {
        this.enabled = false;
        this.buffer = [];
      }
    };
    module2.exports = Buffering;
  }
});

// node_modules/electron-log/src/core/Logger.js
var require_Logger = __commonJS({
  "node_modules/electron-log/src/core/Logger.js"(exports2, module2) {
    "use strict";
    var scopeFactory = require_scope();
    var Buffering = require_Buffering();
    var Logger = class _Logger {
      static instances = {};
      dependencies = {};
      errorHandler = null;
      eventLogger = null;
      functions = {};
      hooks = [];
      isDev = false;
      levels = null;
      logId = null;
      scope = null;
      transports = {};
      variables = {};
      constructor({
        allowUnknownLevel = false,
        dependencies = {},
        errorHandler,
        eventLogger,
        initializeFn,
        isDev = false,
        levels = ["error", "warn", "info", "verbose", "debug", "silly"],
        logId,
        transportFactories = {},
        variables
      } = {}) {
        this.addLevel = this.addLevel.bind(this);
        this.create = this.create.bind(this);
        this.initialize = this.initialize.bind(this);
        this.logData = this.logData.bind(this);
        this.processMessage = this.processMessage.bind(this);
        this.allowUnknownLevel = allowUnknownLevel;
        this.buffering = new Buffering(this);
        this.dependencies = dependencies;
        this.initializeFn = initializeFn;
        this.isDev = isDev;
        this.levels = levels;
        this.logId = logId;
        this.scope = scopeFactory(this);
        this.transportFactories = transportFactories;
        this.variables = variables || {};
        for (const name of this.levels) {
          this.addLevel(name, false);
        }
        this.log = this.info;
        this.functions.log = this.log;
        this.errorHandler = errorHandler;
        errorHandler?.setOptions({ ...dependencies, logFn: this.error });
        this.eventLogger = eventLogger;
        eventLogger?.setOptions({ ...dependencies, logger: this });
        for (const [name, factory] of Object.entries(transportFactories)) {
          this.transports[name] = factory(this, dependencies);
        }
        _Logger.instances[logId] = this;
      }
      static getInstance({ logId }) {
        return this.instances[logId] || this.instances.default;
      }
      addLevel(level, index = this.levels.length) {
        if (index !== false) {
          this.levels.splice(index, 0, level);
        }
        this[level] = (...args) => this.logData(args, { level });
        this.functions[level] = this[level];
      }
      catchErrors(options) {
        this.processMessage(
          {
            data: ["log.catchErrors is deprecated. Use log.errorHandler instead"],
            level: "warn"
          },
          { transports: ["console"] }
        );
        return this.errorHandler.startCatching(options);
      }
      create(options) {
        if (typeof options === "string") {
          options = { logId: options };
        }
        return new _Logger({
          dependencies: this.dependencies,
          errorHandler: this.errorHandler,
          initializeFn: this.initializeFn,
          isDev: this.isDev,
          transportFactories: this.transportFactories,
          variables: { ...this.variables },
          ...options
        });
      }
      compareLevels(passLevel, checkLevel, levels = this.levels) {
        const pass = levels.indexOf(passLevel);
        const check = levels.indexOf(checkLevel);
        if (check === -1 || pass === -1) {
          return true;
        }
        return check <= pass;
      }
      initialize(options = {}) {
        this.initializeFn({ logger: this, ...this.dependencies, ...options });
      }
      logData(data, options = {}) {
        if (this.buffering.enabled) {
          this.buffering.addMessage({ data, date: /* @__PURE__ */ new Date(), ...options });
        } else {
          this.processMessage({ data, ...options });
        }
      }
      processMessage(message, { transports = this.transports } = {}) {
        if (message.cmd === "errorHandler") {
          this.errorHandler.handle(message.error, {
            errorName: message.errorName,
            processType: "renderer",
            showDialog: Boolean(message.showDialog)
          });
          return;
        }
        let level = message.level;
        if (!this.allowUnknownLevel) {
          level = this.levels.includes(message.level) ? message.level : "info";
        }
        const normalizedMessage = {
          date: /* @__PURE__ */ new Date(),
          logId: this.logId,
          ...message,
          level,
          variables: {
            ...this.variables,
            ...message.variables
          }
        };
        for (const [transName, transFn] of this.transportEntries(transports)) {
          if (typeof transFn !== "function" || transFn.level === false) {
            continue;
          }
          if (!this.compareLevels(transFn.level, message.level)) {
            continue;
          }
          try {
            const transformedMsg = this.hooks.reduce((msg, hook) => {
              return msg ? hook(msg, transFn, transName) : msg;
            }, normalizedMessage);
            if (transformedMsg) {
              transFn({ ...transformedMsg, data: [...transformedMsg.data] });
            }
          } catch (e) {
            this.processInternalErrorFn(e);
          }
        }
      }
      processInternalErrorFn(_e) {
      }
      transportEntries(transports = this.transports) {
        const transportArray = Array.isArray(transports) ? transports : Object.entries(transports);
        return transportArray.map((item) => {
          switch (typeof item) {
            case "string":
              return this.transports[item] ? [item, this.transports[item]] : null;
            case "function":
              return [item.name, item];
            default:
              return Array.isArray(item) ? item : null;
          }
        }).filter(Boolean);
      }
    };
    module2.exports = Logger;
  }
});

// node_modules/electron-log/src/renderer/lib/RendererErrorHandler.js
var require_RendererErrorHandler = __commonJS({
  "node_modules/electron-log/src/renderer/lib/RendererErrorHandler.js"(exports2, module2) {
    "use strict";
    var consoleError = console.error;
    var RendererErrorHandler = class {
      logFn = null;
      onError = null;
      showDialog = false;
      preventDefault = true;
      constructor({ logFn = null } = {}) {
        this.handleError = this.handleError.bind(this);
        this.handleRejection = this.handleRejection.bind(this);
        this.startCatching = this.startCatching.bind(this);
        this.logFn = logFn;
      }
      handle(error, {
        logFn = this.logFn,
        errorName = "",
        onError = this.onError,
        showDialog = this.showDialog
      } = {}) {
        try {
          if (onError?.({ error, errorName, processType: "renderer" }) !== false) {
            logFn({ error, errorName, showDialog });
          }
        } catch {
          consoleError(error);
        }
      }
      setOptions({ logFn, onError, preventDefault, showDialog }) {
        if (typeof logFn === "function") {
          this.logFn = logFn;
        }
        if (typeof onError === "function") {
          this.onError = onError;
        }
        if (typeof preventDefault === "boolean") {
          this.preventDefault = preventDefault;
        }
        if (typeof showDialog === "boolean") {
          this.showDialog = showDialog;
        }
      }
      startCatching({ onError, showDialog } = {}) {
        if (this.isActive) {
          return;
        }
        this.isActive = true;
        this.setOptions({ onError, showDialog });
        window.addEventListener("error", (event) => {
          this.preventDefault && event.preventDefault?.();
          this.handleError(event.error || event);
        });
        window.addEventListener("unhandledrejection", (event) => {
          this.preventDefault && event.preventDefault?.();
          this.handleRejection(event.reason || event);
        });
      }
      handleError(error) {
        this.handle(error, { errorName: "Unhandled" });
      }
      handleRejection(reason) {
        const error = reason instanceof Error ? reason : new Error(JSON.stringify(reason));
        this.handle(error, { errorName: "Unhandled rejection" });
      }
    };
    module2.exports = RendererErrorHandler;
  }
});

// node_modules/electron-log/src/core/transforms/transform.js
var require_transform = __commonJS({
  "node_modules/electron-log/src/core/transforms/transform.js"(exports2, module2) {
    "use strict";
    module2.exports = { transform };
    function transform({
      logger: logger2,
      message,
      transport,
      initialData = message?.data || [],
      transforms = transport?.transforms
    }) {
      return transforms.reduce((data, trans) => {
        if (typeof trans === "function") {
          return trans({ data, logger: logger2, message, transport });
        }
        return data;
      }, initialData);
    }
  }
});

// node_modules/electron-log/src/renderer/lib/transports/console.js
var require_console = __commonJS({
  "node_modules/electron-log/src/renderer/lib/transports/console.js"(exports2, module2) {
    "use strict";
    var { transform } = require_transform();
    module2.exports = consoleTransportRendererFactory;
    var consoleMethods = {
      error: console.error,
      warn: console.warn,
      info: console.info,
      verbose: console.info,
      debug: console.debug,
      silly: console.debug,
      log: console.log
    };
    function consoleTransportRendererFactory(logger2) {
      return Object.assign(transport, {
        format: "{h}:{i}:{s}.{ms}{scope} \u203A {text}",
        transforms: [formatDataFn],
        writeFn({ message: { level, data } }) {
          const consoleLogFn = consoleMethods[level] || consoleMethods.info;
          setTimeout(() => consoleLogFn(...data));
        }
      });
      function transport(message) {
        transport.writeFn({
          message: { ...message, data: transform({ logger: logger2, message, transport }) }
        });
      }
    }
    function formatDataFn({
      data = [],
      logger: logger2 = {},
      message = {},
      transport = {}
    }) {
      if (typeof transport.format === "function") {
        return transport.format({
          data,
          level: message?.level || "info",
          logger: logger2,
          message,
          transport
        });
      }
      if (typeof transport.format !== "string") {
        return data;
      }
      data.unshift(transport.format);
      if (typeof data[1] === "string" && data[1].match(/%[1cdfiOos]/)) {
        data = [`${data[0]}${data[1]}`, ...data.slice(2)];
      }
      const date = message.date || /* @__PURE__ */ new Date();
      data[0] = data[0].replace(/\{(\w+)}/g, (substring, name) => {
        switch (name) {
          case "level":
            return message.level;
          case "logId":
            return message.logId;
          case "scope": {
            const scope = message.scope || logger2.scope?.defaultLabel;
            return scope ? ` (${scope})` : "";
          }
          case "text":
            return "";
          case "y":
            return date.getFullYear().toString(10);
          case "m":
            return (date.getMonth() + 1).toString(10).padStart(2, "0");
          case "d":
            return date.getDate().toString(10).padStart(2, "0");
          case "h":
            return date.getHours().toString(10).padStart(2, "0");
          case "i":
            return date.getMinutes().toString(10).padStart(2, "0");
          case "s":
            return date.getSeconds().toString(10).padStart(2, "0");
          case "ms":
            return date.getMilliseconds().toString(10).padStart(3, "0");
          case "iso":
            return date.toISOString();
          default:
            return message.variables?.[name] || substring;
        }
      }).trim();
      return data;
    }
  }
});

// node_modules/electron-log/src/renderer/lib/transports/ipc.js
var require_ipc = __commonJS({
  "node_modules/electron-log/src/renderer/lib/transports/ipc.js"(exports2, module2) {
    "use strict";
    var { transform } = require_transform();
    module2.exports = ipcTransportRendererFactory;
    var RESTRICTED_TYPES = /* @__PURE__ */ new Set([Promise, WeakMap, WeakSet]);
    function ipcTransportRendererFactory(logger2) {
      return Object.assign(transport, {
        depth: 5,
        transforms: [serializeFn]
      });
      function transport(message) {
        if (!window.__electronLog) {
          logger2.processMessage(
            {
              data: ["electron-log: logger isn't initialized in the main process"],
              level: "error"
            },
            { transports: ["console"] }
          );
          return;
        }
        try {
          const serialized = transform({
            initialData: message,
            logger: logger2,
            message,
            transport
          });
          __electronLog.sendToMain(serialized);
        } catch (e) {
          logger2.transports.console({
            data: ["electronLog.transports.ipc", e, "data:", message.data],
            level: "error"
          });
        }
      }
    }
    function isPrimitive(value) {
      return Object(value) !== value;
    }
    function serializeFn({
      data,
      depth,
      seen = /* @__PURE__ */ new WeakSet(),
      transport = {}
    } = {}) {
      const actualDepth = depth || transport.depth || 5;
      if (seen.has(data)) {
        return "[Circular]";
      }
      if (actualDepth < 1) {
        if (isPrimitive(data)) {
          return data;
        }
        if (Array.isArray(data)) {
          return "[Array]";
        }
        return `[${typeof data}]`;
      }
      if (["function", "symbol"].includes(typeof data)) {
        return data.toString();
      }
      if (isPrimitive(data)) {
        return data;
      }
      if (RESTRICTED_TYPES.has(data.constructor)) {
        return `[${data.constructor.name}]`;
      }
      if (Array.isArray(data)) {
        return data.map((item) => serializeFn({
          data: item,
          depth: actualDepth - 1,
          seen
        }));
      }
      if (data instanceof Date) {
        return data.toISOString();
      }
      if (data instanceof Error) {
        return data.stack;
      }
      if (data instanceof Map) {
        return new Map(
          Array.from(data).map(([key, value]) => [
            serializeFn({ data: key, depth: actualDepth - 1, seen }),
            serializeFn({ data: value, depth: actualDepth - 1, seen })
          ])
        );
      }
      if (data instanceof Set) {
        return new Set(
          Array.from(data).map(
            (val) => serializeFn({ data: val, depth: actualDepth - 1, seen })
          )
        );
      }
      seen.add(data);
      return Object.fromEntries(
        Object.entries(data).map(
          ([key, value]) => [
            key,
            serializeFn({ data: value, depth: actualDepth - 1, seen })
          ]
        )
      );
    }
  }
});

// node_modules/electron-log/src/renderer/index.js
var require_renderer = __commonJS({
  "node_modules/electron-log/src/renderer/index.js"(exports2, module2) {
    "use strict";
    var Logger = require_Logger();
    var RendererErrorHandler = require_RendererErrorHandler();
    var transportConsole = require_console();
    var transportIpc = require_ipc();
    if (typeof process === "object" && process.type === "browser") {
      console.warn(
        "electron-log/renderer is loaded in the main process. It could cause unexpected behaviour."
      );
    }
    module2.exports = createLogger();
    module2.exports.Logger = Logger;
    module2.exports.default = module2.exports;
    function createLogger() {
      const logger2 = new Logger({
        allowUnknownLevel: true,
        errorHandler: new RendererErrorHandler(),
        initializeFn: () => {
        },
        logId: "default",
        transportFactories: {
          console: transportConsole,
          ipc: transportIpc
        },
        variables: {
          processType: "renderer"
        }
      });
      logger2.errorHandler.setOptions({
        logFn({ error, errorName, showDialog }) {
          logger2.transports.console({
            data: [errorName, error].filter(Boolean),
            level: "error"
          });
          logger2.transports.ipc({
            cmd: "errorHandler",
            error: {
              cause: error?.cause,
              code: error?.code,
              name: error?.name,
              message: error?.message,
              stack: error?.stack
            },
            errorName,
            logId: logger2.logId,
            showDialog
          });
        }
      });
      if (typeof window === "object") {
        window.addEventListener("message", (event) => {
          const { cmd, logId, ...message } = event.data || {};
          const instance = Logger.getInstance({ logId });
          if (cmd === "message") {
            instance.processMessage(message, { transports: ["console"] });
          }
        });
      }
      return new Proxy(logger2, {
        get(target, prop) {
          if (typeof target[prop] !== "undefined") {
            return target[prop];
          }
          return (...data) => logger2.logData(data, { level: prop });
        }
      });
    }
  }
});

// node_modules/electron-log/src/node/packageJson.js
var require_packageJson = __commonJS({
  "node_modules/electron-log/src/node/packageJson.js"(exports2, module2) {
    "use strict";
    var fs14 = require("fs");
    var path16 = require("path");
    module2.exports = {
      findAndReadPackageJson,
      tryReadJsonAt
    };
    function findAndReadPackageJson() {
      return tryReadJsonAt(getMainModulePath()) || tryReadJsonAt(extractPathFromArgs()) || tryReadJsonAt(process.resourcesPath, "app.asar") || tryReadJsonAt(process.resourcesPath, "app") || tryReadJsonAt(process.cwd()) || { name: void 0, version: void 0 };
    }
    function tryReadJsonAt(...searchPaths) {
      if (!searchPaths[0]) {
        return void 0;
      }
      try {
        const searchPath = path16.join(...searchPaths);
        const fileName = findUp("package.json", searchPath);
        if (!fileName) {
          return void 0;
        }
        const json = JSON.parse(fs14.readFileSync(fileName, "utf8"));
        const name = json?.productName || json?.name;
        if (!name || name.toLowerCase() === "electron") {
          return void 0;
        }
        if (name) {
          return { name, version: json?.version };
        }
        return void 0;
      } catch (e) {
        return void 0;
      }
    }
    function findUp(fileName, cwd) {
      let currentPath = cwd;
      while (true) {
        const parsedPath = path16.parse(currentPath);
        const root = parsedPath.root;
        const dir = parsedPath.dir;
        if (fs14.existsSync(path16.join(currentPath, fileName))) {
          return path16.resolve(path16.join(currentPath, fileName));
        }
        if (currentPath === root) {
          return null;
        }
        currentPath = dir;
      }
    }
    function extractPathFromArgs() {
      const matchedArgs = process.argv.filter((arg) => {
        return arg.indexOf("--user-data-dir=") === 0;
      });
      if (matchedArgs.length === 0 || typeof matchedArgs[0] !== "string") {
        return null;
      }
      const userDataDir = matchedArgs[0];
      return userDataDir.replace("--user-data-dir=", "");
    }
    function getMainModulePath() {
      try {
        return require.main?.filename;
      } catch {
        return void 0;
      }
    }
  }
});

// node_modules/electron-log/src/node/NodeExternalApi.js
var require_NodeExternalApi = __commonJS({
  "node_modules/electron-log/src/node/NodeExternalApi.js"(exports2, module2) {
    "use strict";
    var childProcess = require("child_process");
    var os = require("os");
    var path16 = require("path");
    var packageJson = require_packageJson();
    var NodeExternalApi = class {
      appName = void 0;
      appPackageJson = void 0;
      platform = process.platform;
      getAppLogPath(appName = this.getAppName()) {
        if (this.platform === "darwin") {
          return path16.join(this.getSystemPathHome(), "Library/Logs", appName);
        }
        return path16.join(this.getAppUserDataPath(appName), "logs");
      }
      getAppName() {
        const appName = this.appName || this.getAppPackageJson()?.name;
        if (!appName) {
          throw new Error(
            "electron-log can't determine the app name. It tried these methods:\n1. Use `electron.app.name`\n2. Use productName or name from the nearest package.json`\nYou can also set it through log.transports.file.setAppName()"
          );
        }
        return appName;
      }
      /**
       * @private
       * @returns {undefined}
       */
      getAppPackageJson() {
        if (typeof this.appPackageJson !== "object") {
          this.appPackageJson = packageJson.findAndReadPackageJson();
        }
        return this.appPackageJson;
      }
      getAppUserDataPath(appName = this.getAppName()) {
        return appName ? path16.join(this.getSystemPathAppData(), appName) : void 0;
      }
      getAppVersion() {
        return this.getAppPackageJson()?.version;
      }
      getElectronLogPath() {
        return this.getAppLogPath();
      }
      getMacOsVersion() {
        const release = Number(os.release().split(".")[0]);
        if (release <= 19) {
          return `10.${release - 4}`;
        }
        return release - 9;
      }
      /**
       * @protected
       * @returns {string}
       */
      getOsVersion() {
        let osName = os.type().replace("_", " ");
        let osVersion = os.release();
        if (osName === "Darwin") {
          osName = "macOS";
          osVersion = this.getMacOsVersion();
        }
        return `${osName} ${osVersion}`;
      }
      /**
       * @return {PathVariables}
       */
      getPathVariables() {
        const appName = this.getAppName();
        const appVersion = this.getAppVersion();
        const self2 = this;
        return {
          appData: this.getSystemPathAppData(),
          appName,
          appVersion,
          get electronDefaultDir() {
            return self2.getElectronLogPath();
          },
          home: this.getSystemPathHome(),
          libraryDefaultDir: this.getAppLogPath(appName),
          libraryTemplate: this.getAppLogPath("{appName}"),
          temp: this.getSystemPathTemp(),
          userData: this.getAppUserDataPath(appName)
        };
      }
      getSystemPathAppData() {
        const home = this.getSystemPathHome();
        switch (this.platform) {
          case "darwin": {
            return path16.join(home, "Library/Application Support");
          }
          case "win32": {
            return process.env.APPDATA || path16.join(home, "AppData/Roaming");
          }
          default: {
            return process.env.XDG_CONFIG_HOME || path16.join(home, ".config");
          }
        }
      }
      getSystemPathHome() {
        return os.homedir?.() || process.env.HOME;
      }
      getSystemPathTemp() {
        return os.tmpdir();
      }
      getVersions() {
        return {
          app: `${this.getAppName()} ${this.getAppVersion()}`,
          electron: void 0,
          os: this.getOsVersion()
        };
      }
      isDev() {
        return process.env.NODE_ENV === "development" || process.env.ELECTRON_IS_DEV === "1";
      }
      isElectron() {
        return Boolean(process.versions.electron);
      }
      onAppEvent(_eventName, _handler) {
      }
      onAppReady(handler) {
        handler();
      }
      onEveryWebContentsEvent(eventName, handler) {
      }
      /**
       * Listen to async messages sent from opposite process
       * @param {string} channel
       * @param {function} listener
       */
      onIpc(channel, listener) {
      }
      onIpcInvoke(channel, listener) {
      }
      /**
       * @param {string} url
       * @param {Function} [logFunction]
       */
      openUrl(url2, logFunction = console.error) {
        const startMap = { darwin: "open", win32: "start", linux: "xdg-open" };
        const start = startMap[process.platform] || "xdg-open";
        childProcess.exec(`${start} ${url2}`, {}, (err) => {
          if (err) {
            logFunction(err);
          }
        });
      }
      setAppName(appName) {
        this.appName = appName;
      }
      setPlatform(platform) {
        this.platform = platform;
      }
      setPreloadFileForSessions({
        filePath,
        // eslint-disable-line no-unused-vars
        includeFutureSession = true,
        // eslint-disable-line no-unused-vars
        getSessions = () => []
        // eslint-disable-line no-unused-vars
      }) {
      }
      /**
       * Sent a message to opposite process
       * @param {string} channel
       * @param {any} message
       */
      sendIpc(channel, message) {
      }
      showErrorBox(title, message) {
      }
    };
    module2.exports = NodeExternalApi;
  }
});

// node_modules/electron-log/src/main/ElectronExternalApi.js
var require_ElectronExternalApi = __commonJS({
  "node_modules/electron-log/src/main/ElectronExternalApi.js"(exports2, module2) {
    "use strict";
    var path16 = require("path");
    var NodeExternalApi = require_NodeExternalApi();
    var ElectronExternalApi = class extends NodeExternalApi {
      /**
       * @type {typeof Electron}
       */
      electron = void 0;
      /**
       * @param {object} options
       * @param {typeof Electron} [options.electron]
       */
      constructor({ electron } = {}) {
        super();
        this.electron = electron;
      }
      getAppName() {
        let appName;
        try {
          appName = this.appName || this.electron.app?.name || this.electron.app?.getName();
        } catch {
        }
        return appName || super.getAppName();
      }
      getAppUserDataPath(appName) {
        return this.getPath("userData") || super.getAppUserDataPath(appName);
      }
      getAppVersion() {
        let appVersion;
        try {
          appVersion = this.electron.app?.getVersion();
        } catch {
        }
        return appVersion || super.getAppVersion();
      }
      getElectronLogPath() {
        return this.getPath("logs") || super.getElectronLogPath();
      }
      /**
       * @private
       * @param {any} name
       * @returns {string|undefined}
       */
      getPath(name) {
        try {
          return this.electron.app?.getPath(name);
        } catch {
          return void 0;
        }
      }
      getVersions() {
        return {
          app: `${this.getAppName()} ${this.getAppVersion()}`,
          electron: `Electron ${process.versions.electron}`,
          os: this.getOsVersion()
        };
      }
      getSystemPathAppData() {
        return this.getPath("appData") || super.getSystemPathAppData();
      }
      isDev() {
        if (this.electron.app?.isPackaged !== void 0) {
          return !this.electron.app.isPackaged;
        }
        if (typeof process.execPath === "string") {
          const execFileName = path16.basename(process.execPath).toLowerCase();
          return execFileName.startsWith("electron");
        }
        return super.isDev();
      }
      onAppEvent(eventName, handler) {
        this.electron.app?.on(eventName, handler);
        return () => {
          this.electron.app?.off(eventName, handler);
        };
      }
      onAppReady(handler) {
        if (this.electron.app?.isReady()) {
          handler();
        } else if (this.electron.app?.once) {
          this.electron.app?.once("ready", handler);
        } else {
          handler();
        }
      }
      onEveryWebContentsEvent(eventName, handler) {
        this.electron.webContents?.getAllWebContents()?.forEach((webContents) => {
          webContents.on(eventName, handler);
        });
        this.electron.app?.on("web-contents-created", onWebContentsCreated);
        return () => {
          this.electron.webContents?.getAllWebContents().forEach((webContents) => {
            webContents.off(eventName, handler);
          });
          this.electron.app?.off("web-contents-created", onWebContentsCreated);
        };
        function onWebContentsCreated(_, webContents) {
          webContents.on(eventName, handler);
        }
      }
      /**
       * Listen to async messages sent from opposite process
       * @param {string} channel
       * @param {function} listener
       */
      onIpc(channel, listener) {
        this.electron.ipcMain?.on(channel, listener);
      }
      onIpcInvoke(channel, listener) {
        this.electron.ipcMain?.handle?.(channel, listener);
      }
      /**
       * @param {string} url
       * @param {Function} [logFunction]
       */
      openUrl(url2, logFunction = console.error) {
        this.electron.shell?.openExternal(url2).catch(logFunction);
      }
      setPreloadFileForSessions({
        filePath,
        includeFutureSession = true,
        getSessions = () => [this.electron.session?.defaultSession]
      }) {
        for (const session of getSessions().filter(Boolean)) {
          setPreload(session);
        }
        if (includeFutureSession) {
          this.onAppEvent("session-created", (session) => {
            setPreload(session);
          });
        }
        function setPreload(session) {
          if (typeof session.registerPreloadScript === "function") {
            session.registerPreloadScript({
              filePath,
              id: "electron-log-preload",
              type: "frame"
            });
          } else {
            session.setPreloads([...session.getPreloads(), filePath]);
          }
        }
      }
      /**
       * Sent a message to opposite process
       * @param {string} channel
       * @param {any} message
       */
      sendIpc(channel, message) {
        this.electron.BrowserWindow?.getAllWindows()?.forEach((wnd) => {
          if (wnd.webContents?.isDestroyed() === false && wnd.webContents?.isCrashed() === false) {
            wnd.webContents.send(channel, message);
          }
        });
      }
      showErrorBox(title, message) {
        this.electron.dialog?.showErrorBox(title, message);
      }
    };
    module2.exports = ElectronExternalApi;
  }
});

// node_modules/electron-log/src/main/initialize.js
var require_initialize = __commonJS({
  "node_modules/electron-log/src/main/initialize.js"(exports2, module2) {
    "use strict";
    var fs14 = require("fs");
    var os = require("os");
    var path16 = require("path");
    var preloadInitializeFn = require_electron_log_preload();
    var preloadInitialized = false;
    var spyConsoleInitialized = false;
    module2.exports = {
      initialize({
        externalApi,
        getSessions,
        includeFutureSession,
        logger: logger2,
        preload = true,
        spyRendererConsole = false
      }) {
        externalApi.onAppReady(() => {
          try {
            if (preload) {
              initializePreload({
                externalApi,
                getSessions,
                includeFutureSession,
                logger: logger2,
                preloadOption: preload
              });
            }
            if (spyRendererConsole) {
              initializeSpyRendererConsole({ externalApi, logger: logger2 });
            }
          } catch (err) {
            logger2.warn(err);
          }
        });
      }
    };
    function initializePreload({
      externalApi,
      getSessions,
      includeFutureSession,
      logger: logger2,
      preloadOption
    }) {
      let preloadPath = typeof preloadOption === "string" ? preloadOption : void 0;
      if (preloadInitialized) {
        logger2.warn(new Error("log.initialize({ preload }) already called").stack);
        return;
      }
      preloadInitialized = true;
      try {
        preloadPath = path16.resolve(
          __dirname,
          "../renderer/electron-log-preload.js"
        );
      } catch {
      }
      if (!preloadPath || !fs14.existsSync(preloadPath)) {
        preloadPath = path16.join(
          externalApi.getAppUserDataPath() || os.tmpdir(),
          "electron-log-preload.js"
        );
        const preloadCode = `
      try {
        (${preloadInitializeFn.toString()})(require('electron'));
      } catch(e) {
        console.error(e);
      }
    `;
        fs14.writeFileSync(preloadPath, preloadCode, "utf8");
      }
      externalApi.setPreloadFileForSessions({
        filePath: preloadPath,
        includeFutureSession,
        getSessions
      });
    }
    function initializeSpyRendererConsole({ externalApi, logger: logger2 }) {
      if (spyConsoleInitialized) {
        logger2.warn(
          new Error("log.initialize({ spyRendererConsole }) already called").stack
        );
        return;
      }
      spyConsoleInitialized = true;
      const levels = ["debug", "info", "warn", "error"];
      externalApi.onEveryWebContentsEvent(
        "console-message",
        (event, level, message) => {
          logger2.processMessage({
            data: [message],
            level: levels[level],
            variables: { processType: "renderer" }
          });
        }
      );
    }
  }
});

// node_modules/electron-log/src/node/ErrorHandler.js
var require_ErrorHandler = __commonJS({
  "node_modules/electron-log/src/node/ErrorHandler.js"(exports2, module2) {
    "use strict";
    var ErrorHandler = class {
      externalApi = void 0;
      isActive = false;
      logFn = void 0;
      onError = void 0;
      showDialog = true;
      constructor({
        externalApi,
        logFn = void 0,
        onError = void 0,
        showDialog = void 0
      } = {}) {
        this.createIssue = this.createIssue.bind(this);
        this.handleError = this.handleError.bind(this);
        this.handleRejection = this.handleRejection.bind(this);
        this.setOptions({ externalApi, logFn, onError, showDialog });
        this.startCatching = this.startCatching.bind(this);
        this.stopCatching = this.stopCatching.bind(this);
      }
      handle(error, {
        logFn = this.logFn,
        onError = this.onError,
        processType = "browser",
        showDialog = this.showDialog,
        errorName = ""
      } = {}) {
        error = normalizeError(error);
        try {
          if (typeof onError === "function") {
            const versions = this.externalApi?.getVersions() || {};
            const createIssue = this.createIssue;
            const result = onError({
              createIssue,
              error,
              errorName,
              processType,
              versions
            });
            if (result === false) {
              return;
            }
          }
          errorName ? logFn(errorName, error) : logFn(error);
          if (showDialog && !errorName.includes("rejection") && this.externalApi) {
            this.externalApi.showErrorBox(
              `A JavaScript error occurred in the ${processType} process`,
              error.stack
            );
          }
        } catch {
          console.error(error);
        }
      }
      setOptions({ externalApi, logFn, onError, showDialog }) {
        if (typeof externalApi === "object") {
          this.externalApi = externalApi;
        }
        if (typeof logFn === "function") {
          this.logFn = logFn;
        }
        if (typeof onError === "function") {
          this.onError = onError;
        }
        if (typeof showDialog === "boolean") {
          this.showDialog = showDialog;
        }
      }
      startCatching({ onError, showDialog } = {}) {
        if (this.isActive) {
          return;
        }
        this.isActive = true;
        this.setOptions({ onError, showDialog });
        process.on("uncaughtException", this.handleError);
        process.on("unhandledRejection", this.handleRejection);
      }
      stopCatching() {
        this.isActive = false;
        process.removeListener("uncaughtException", this.handleError);
        process.removeListener("unhandledRejection", this.handleRejection);
      }
      createIssue(pageUrl, queryParams) {
        this.externalApi?.openUrl(
          `${pageUrl}?${new URLSearchParams(queryParams).toString()}`
        );
      }
      handleError(error) {
        this.handle(error, { errorName: "Unhandled" });
      }
      handleRejection(reason) {
        const error = reason instanceof Error ? reason : new Error(JSON.stringify(reason));
        this.handle(error, { errorName: "Unhandled rejection" });
      }
    };
    function normalizeError(e) {
      if (e instanceof Error) {
        return e;
      }
      if (e && typeof e === "object") {
        if (e.message) {
          return Object.assign(new Error(e.message), e);
        }
        try {
          return new Error(JSON.stringify(e));
        } catch (serErr) {
          return new Error(`Couldn't normalize error ${String(e)}: ${serErr}`);
        }
      }
      return new Error(`Can't normalize error ${String(e)}`);
    }
    module2.exports = ErrorHandler;
  }
});

// node_modules/electron-log/src/node/EventLogger.js
var require_EventLogger = __commonJS({
  "node_modules/electron-log/src/node/EventLogger.js"(exports2, module2) {
    "use strict";
    var EventLogger = class {
      disposers = [];
      format = "{eventSource}#{eventName}:";
      formatters = {
        app: {
          "certificate-error": ({ args }) => {
            return this.arrayToObject(args.slice(1, 4), [
              "url",
              "error",
              "certificate"
            ]);
          },
          "child-process-gone": ({ args }) => {
            return args.length === 1 ? args[0] : args;
          },
          "render-process-gone": ({ args: [webContents, details] }) => {
            return details && typeof details === "object" ? { ...details, ...this.getWebContentsDetails(webContents) } : [];
          }
        },
        webContents: {
          "console-message": ({ args: [level, message, line, sourceId] }) => {
            if (level < 3) {
              return void 0;
            }
            return { message, source: `${sourceId}:${line}` };
          },
          "did-fail-load": ({ args }) => {
            return this.arrayToObject(args, [
              "errorCode",
              "errorDescription",
              "validatedURL",
              "isMainFrame",
              "frameProcessId",
              "frameRoutingId"
            ]);
          },
          "did-fail-provisional-load": ({ args }) => {
            return this.arrayToObject(args, [
              "errorCode",
              "errorDescription",
              "validatedURL",
              "isMainFrame",
              "frameProcessId",
              "frameRoutingId"
            ]);
          },
          "plugin-crashed": ({ args }) => {
            return this.arrayToObject(args, ["name", "version"]);
          },
          "preload-error": ({ args }) => {
            return this.arrayToObject(args, ["preloadPath", "error"]);
          }
        }
      };
      events = {
        app: {
          "certificate-error": true,
          "child-process-gone": true,
          "render-process-gone": true
        },
        webContents: {
          // 'console-message': true,
          "did-fail-load": true,
          "did-fail-provisional-load": true,
          "plugin-crashed": true,
          "preload-error": true,
          "unresponsive": true
        }
      };
      externalApi = void 0;
      level = "error";
      scope = "";
      constructor(options = {}) {
        this.setOptions(options);
      }
      setOptions({
        events,
        externalApi,
        level,
        logger: logger2,
        format,
        formatters,
        scope
      }) {
        if (typeof events === "object") {
          this.events = events;
        }
        if (typeof externalApi === "object") {
          this.externalApi = externalApi;
        }
        if (typeof level === "string") {
          this.level = level;
        }
        if (typeof logger2 === "object") {
          this.logger = logger2;
        }
        if (typeof format === "string" || typeof format === "function") {
          this.format = format;
        }
        if (typeof formatters === "object") {
          this.formatters = formatters;
        }
        if (typeof scope === "string") {
          this.scope = scope;
        }
      }
      startLogging(options = {}) {
        this.setOptions(options);
        this.disposeListeners();
        for (const eventName of this.getEventNames(this.events.app)) {
          this.disposers.push(
            this.externalApi.onAppEvent(eventName, (...handlerArgs) => {
              this.handleEvent({ eventSource: "app", eventName, handlerArgs });
            })
          );
        }
        for (const eventName of this.getEventNames(this.events.webContents)) {
          this.disposers.push(
            this.externalApi.onEveryWebContentsEvent(
              eventName,
              (...handlerArgs) => {
                this.handleEvent(
                  { eventSource: "webContents", eventName, handlerArgs }
                );
              }
            )
          );
        }
      }
      stopLogging() {
        this.disposeListeners();
      }
      arrayToObject(array, fieldNames) {
        const obj = {};
        fieldNames.forEach((fieldName, index) => {
          obj[fieldName] = array[index];
        });
        if (array.length > fieldNames.length) {
          obj.unknownArgs = array.slice(fieldNames.length);
        }
        return obj;
      }
      disposeListeners() {
        this.disposers.forEach((disposer) => disposer());
        this.disposers = [];
      }
      formatEventLog({ eventName, eventSource, handlerArgs }) {
        const [event, ...args] = handlerArgs;
        if (typeof this.format === "function") {
          return this.format({ args, event, eventName, eventSource });
        }
        const formatter = this.formatters[eventSource]?.[eventName];
        let formattedArgs = args;
        if (typeof formatter === "function") {
          formattedArgs = formatter({ args, event, eventName, eventSource });
        }
        if (!formattedArgs) {
          return void 0;
        }
        const eventData = {};
        if (Array.isArray(formattedArgs)) {
          eventData.args = formattedArgs;
        } else if (typeof formattedArgs === "object") {
          Object.assign(eventData, formattedArgs);
        }
        if (eventSource === "webContents") {
          Object.assign(eventData, this.getWebContentsDetails(event?.sender));
        }
        const title = this.format.replace("{eventSource}", eventSource === "app" ? "App" : "WebContents").replace("{eventName}", eventName);
        return [title, eventData];
      }
      getEventNames(eventMap) {
        if (!eventMap || typeof eventMap !== "object") {
          return [];
        }
        return Object.entries(eventMap).filter(([_, listen]) => listen).map(([eventName]) => eventName);
      }
      getWebContentsDetails(webContents) {
        if (!webContents?.loadURL) {
          return {};
        }
        try {
          return {
            webContents: {
              id: webContents.id,
              url: webContents.getURL()
            }
          };
        } catch {
          return {};
        }
      }
      handleEvent({ eventName, eventSource, handlerArgs }) {
        const log2 = this.formatEventLog({ eventName, eventSource, handlerArgs });
        if (log2) {
          const logFns = this.scope ? this.logger.scope(this.scope) : this.logger;
          logFns?.[this.level]?.(...log2);
        }
      }
    };
    module2.exports = EventLogger;
  }
});

// node_modules/electron-log/src/core/transforms/format.js
var require_format = __commonJS({
  "node_modules/electron-log/src/core/transforms/format.js"(exports2, module2) {
    "use strict";
    var { transform } = require_transform();
    module2.exports = {
      concatFirstStringElements,
      formatScope,
      formatText,
      formatVariables,
      timeZoneFromOffset,
      format({ message, logger: logger2, transport, data = message?.data }) {
        switch (typeof transport.format) {
          case "string": {
            return transform({
              message,
              logger: logger2,
              transforms: [formatVariables, formatScope, formatText],
              transport,
              initialData: [transport.format, ...data]
            });
          }
          case "function": {
            return transport.format({
              data,
              level: message?.level || "info",
              logger: logger2,
              message,
              transport
            });
          }
          default: {
            return data;
          }
        }
      }
    };
    function concatFirstStringElements({ data }) {
      if (typeof data[0] !== "string" || typeof data[1] !== "string") {
        return data;
      }
      if (data[0].match(/%[1cdfiOos]/)) {
        return data;
      }
      return [`${data[0]} ${data[1]}`, ...data.slice(2)];
    }
    function timeZoneFromOffset(minutesOffset) {
      const minutesPositive = Math.abs(minutesOffset);
      const sign = minutesOffset > 0 ? "-" : "+";
      const hours = Math.floor(minutesPositive / 60).toString().padStart(2, "0");
      const minutes = (minutesPositive % 60).toString().padStart(2, "0");
      return `${sign}${hours}:${minutes}`;
    }
    function formatScope({ data, logger: logger2, message }) {
      const { defaultLabel, labelLength } = logger2?.scope || {};
      const template = data[0];
      let label = message.scope;
      if (!label) {
        label = defaultLabel;
      }
      let scopeText;
      if (label === "") {
        scopeText = labelLength > 0 ? "".padEnd(labelLength + 3) : "";
      } else if (typeof label === "string") {
        scopeText = ` (${label})`.padEnd(labelLength + 3);
      } else {
        scopeText = "";
      }
      data[0] = template.replace("{scope}", scopeText);
      return data;
    }
    function formatVariables({ data, message }) {
      let template = data[0];
      if (typeof template !== "string") {
        return data;
      }
      template = template.replace("{level}]", `${message.level}]`.padEnd(6, " "));
      const date = message.date || /* @__PURE__ */ new Date();
      data[0] = template.replace(/\{(\w+)}/g, (substring, name) => {
        switch (name) {
          case "level":
            return message.level || "info";
          case "logId":
            return message.logId;
          case "y":
            return date.getFullYear().toString(10);
          case "m":
            return (date.getMonth() + 1).toString(10).padStart(2, "0");
          case "d":
            return date.getDate().toString(10).padStart(2, "0");
          case "h":
            return date.getHours().toString(10).padStart(2, "0");
          case "i":
            return date.getMinutes().toString(10).padStart(2, "0");
          case "s":
            return date.getSeconds().toString(10).padStart(2, "0");
          case "ms":
            return date.getMilliseconds().toString(10).padStart(3, "0");
          case "z":
            return timeZoneFromOffset(date.getTimezoneOffset());
          case "iso":
            return date.toISOString();
          default: {
            return message.variables?.[name] || substring;
          }
        }
      }).trim();
      return data;
    }
    function formatText({ data }) {
      const template = data[0];
      if (typeof template !== "string") {
        return data;
      }
      const textTplPosition = template.lastIndexOf("{text}");
      if (textTplPosition === template.length - 6) {
        data[0] = template.replace(/\s?{text}/, "");
        if (data[0] === "") {
          data.shift();
        }
        return data;
      }
      const templatePieces = template.split("{text}");
      let result = [];
      if (templatePieces[0] !== "") {
        result.push(templatePieces[0]);
      }
      result = result.concat(data.slice(1));
      if (templatePieces[1] !== "") {
        result.push(templatePieces[1]);
      }
      return result;
    }
  }
});

// node_modules/electron-log/src/node/transforms/object.js
var require_object = __commonJS({
  "node_modules/electron-log/src/node/transforms/object.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    module2.exports = {
      serialize,
      maxDepth({ data, transport, depth = transport?.depth ?? 6 }) {
        if (!data) {
          return data;
        }
        if (depth < 1) {
          if (Array.isArray(data)) return "[array]";
          if (typeof data === "object" && data) return "[object]";
          return data;
        }
        if (Array.isArray(data)) {
          return data.map((child) => module2.exports.maxDepth({
            data: child,
            depth: depth - 1
          }));
        }
        if (typeof data !== "object") {
          return data;
        }
        if (data && typeof data.toISOString === "function") {
          return data;
        }
        if (data === null) {
          return null;
        }
        if (data instanceof Error) {
          return data;
        }
        const newJson = {};
        for (const i in data) {
          if (!Object.prototype.hasOwnProperty.call(data, i)) continue;
          newJson[i] = module2.exports.maxDepth({
            data: data[i],
            depth: depth - 1
          });
        }
        return newJson;
      },
      toJSON({ data }) {
        return JSON.parse(JSON.stringify(data, createSerializer()));
      },
      toString({ data, transport }) {
        const inspectOptions = transport?.inspectOptions || {};
        const simplifiedData = data.map((item) => {
          if (item === void 0) {
            return void 0;
          }
          try {
            const str = JSON.stringify(item, createSerializer(), "  ");
            return str === void 0 ? void 0 : JSON.parse(str);
          } catch (e) {
            return item;
          }
        });
        return util.formatWithOptions(inspectOptions, ...simplifiedData);
      }
    };
    function createSerializer(options = {}) {
      const seen = /* @__PURE__ */ new WeakSet();
      return function(key, value) {
        if (typeof value === "object" && value !== null) {
          if (seen.has(value)) {
            return void 0;
          }
          seen.add(value);
        }
        return serialize(key, value, options);
      };
    }
    function serialize(key, value, options = {}) {
      const serializeMapAndSet = options?.serializeMapAndSet !== false;
      if (value instanceof Error) {
        return value.stack;
      }
      if (!value) {
        return value;
      }
      if (typeof value === "function") {
        return `[function] ${value.toString()}`;
      }
      if (value instanceof Date) {
        return value.toISOString();
      }
      if (serializeMapAndSet && value instanceof Map && Object.fromEntries) {
        return Object.fromEntries(value);
      }
      if (serializeMapAndSet && value instanceof Set && Array.from) {
        return Array.from(value);
      }
      return value;
    }
  }
});

// node_modules/electron-log/src/core/transforms/style.js
var require_style = __commonJS({
  "node_modules/electron-log/src/core/transforms/style.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      transformStyles,
      applyAnsiStyles({ data }) {
        return transformStyles(data, styleToAnsi, resetAnsiStyle);
      },
      removeStyles({ data }) {
        return transformStyles(data, () => "");
      }
    };
    var ANSI_COLORS = {
      unset: "\x1B[0m",
      black: "\x1B[30m",
      red: "\x1B[31m",
      green: "\x1B[32m",
      yellow: "\x1B[33m",
      blue: "\x1B[34m",
      magenta: "\x1B[35m",
      cyan: "\x1B[36m",
      white: "\x1B[37m",
      gray: "\x1B[90m"
    };
    function styleToAnsi(style) {
      const color = style.replace(/color:\s*(\w+).*/, "$1").toLowerCase();
      return ANSI_COLORS[color] || "";
    }
    function resetAnsiStyle(string) {
      return string + ANSI_COLORS.unset;
    }
    function transformStyles(data, onStyleFound, onStyleApplied) {
      const foundStyles = {};
      return data.reduce((result, item, index, array) => {
        if (foundStyles[index]) {
          return result;
        }
        if (typeof item === "string") {
          let valueIndex = index;
          let styleApplied = false;
          item = item.replace(/%[1cdfiOos]/g, (match) => {
            valueIndex += 1;
            if (match !== "%c") {
              return match;
            }
            const style = array[valueIndex];
            if (typeof style === "string") {
              foundStyles[valueIndex] = true;
              styleApplied = true;
              return onStyleFound(style, item);
            }
            return match;
          });
          if (styleApplied && onStyleApplied) {
            item = onStyleApplied(item);
          }
        }
        result.push(item);
        return result;
      }, []);
    }
  }
});

// node_modules/electron-log/src/node/transports/console.js
var require_console2 = __commonJS({
  "node_modules/electron-log/src/node/transports/console.js"(exports2, module2) {
    "use strict";
    var {
      concatFirstStringElements,
      format
    } = require_format();
    var { maxDepth, toJSON } = require_object();
    var {
      applyAnsiStyles,
      removeStyles
    } = require_style();
    var { transform } = require_transform();
    var consoleMethods = {
      error: console.error,
      warn: console.warn,
      info: console.info,
      verbose: console.info,
      debug: console.debug,
      silly: console.debug,
      log: console.log
    };
    module2.exports = consoleTransportFactory;
    var separator = process.platform === "win32" ? ">" : "\u203A";
    var DEFAULT_FORMAT = `%c{h}:{i}:{s}.{ms}{scope}%c ${separator} {text}`;
    Object.assign(consoleTransportFactory, {
      DEFAULT_FORMAT
    });
    function consoleTransportFactory(logger2) {
      return Object.assign(transport, {
        colorMap: {
          error: "red",
          warn: "yellow",
          info: "cyan",
          verbose: "unset",
          debug: "gray",
          silly: "gray",
          default: "unset"
        },
        format: DEFAULT_FORMAT,
        level: "silly",
        transforms: [
          addTemplateColors,
          format,
          formatStyles,
          concatFirstStringElements,
          maxDepth,
          toJSON
        ],
        useStyles: process.env.FORCE_STYLES,
        writeFn({ message }) {
          const consoleLogFn = consoleMethods[message.level] || consoleMethods.info;
          consoleLogFn(...message.data);
        }
      });
      function transport(message) {
        const data = transform({ logger: logger2, message, transport });
        transport.writeFn({
          message: { ...message, data }
        });
      }
    }
    function addTemplateColors({ data, message, transport }) {
      if (typeof transport.format !== "string" || !transport.format.includes("%c")) {
        return data;
      }
      return [
        `color:${levelToStyle(message.level, transport)}`,
        "color:unset",
        ...data
      ];
    }
    function canUseStyles(useStyleValue, level) {
      if (typeof useStyleValue === "boolean") {
        return useStyleValue;
      }
      const useStderr = level === "error" || level === "warn";
      const stream = useStderr ? process.stderr : process.stdout;
      return stream && stream.isTTY;
    }
    function formatStyles(args) {
      const { message, transport } = args;
      const useStyles = canUseStyles(transport.useStyles, message.level);
      const nextTransform = useStyles ? applyAnsiStyles : removeStyles;
      return nextTransform(args);
    }
    function levelToStyle(level, transport) {
      return transport.colorMap[level] || transport.colorMap.default;
    }
  }
});

// node_modules/electron-log/src/node/transports/file/File.js
var require_File = __commonJS({
  "node_modules/electron-log/src/node/transports/file/File.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var fs14 = require("fs");
    var os = require("os");
    var File = class extends EventEmitter {
      asyncWriteQueue = [];
      bytesWritten = 0;
      hasActiveAsyncWriting = false;
      path = null;
      initialSize = void 0;
      writeOptions = null;
      writeAsync = false;
      constructor({
        path: path16,
        writeOptions = { encoding: "utf8", flag: "a", mode: 438 },
        writeAsync = false
      }) {
        super();
        this.path = path16;
        this.writeOptions = writeOptions;
        this.writeAsync = writeAsync;
      }
      get size() {
        return this.getSize();
      }
      clear() {
        try {
          fs14.writeFileSync(this.path, "", {
            mode: this.writeOptions.mode,
            flag: "w"
          });
          this.reset();
          return true;
        } catch (e) {
          if (e.code === "ENOENT") {
            return true;
          }
          this.emit("error", e, this);
          return false;
        }
      }
      crop(bytesAfter) {
        try {
          const content = readFileSyncFromEnd(this.path, bytesAfter || 4096);
          this.clear();
          this.writeLine(`[log cropped]${os.EOL}${content}`);
        } catch (e) {
          this.emit(
            "error",
            new Error(`Couldn't crop file ${this.path}. ${e.message}`),
            this
          );
        }
      }
      getSize() {
        if (this.initialSize === void 0) {
          try {
            const stats = fs14.statSync(this.path);
            this.initialSize = stats.size;
          } catch (e) {
            this.initialSize = 0;
          }
        }
        return this.initialSize + this.bytesWritten;
      }
      increaseBytesWrittenCounter(text) {
        this.bytesWritten += Buffer.byteLength(text, this.writeOptions.encoding);
      }
      isNull() {
        return false;
      }
      nextAsyncWrite() {
        const file = this;
        if (this.hasActiveAsyncWriting || this.asyncWriteQueue.length === 0) {
          return;
        }
        const text = this.asyncWriteQueue.join("");
        this.asyncWriteQueue = [];
        this.hasActiveAsyncWriting = true;
        fs14.writeFile(this.path, text, this.writeOptions, (e) => {
          file.hasActiveAsyncWriting = false;
          if (e) {
            file.emit(
              "error",
              new Error(`Couldn't write to ${file.path}. ${e.message}`),
              this
            );
          } else {
            file.increaseBytesWrittenCounter(text);
          }
          file.nextAsyncWrite();
        });
      }
      reset() {
        this.initialSize = void 0;
        this.bytesWritten = 0;
      }
      toString() {
        return this.path;
      }
      writeLine(text) {
        text += os.EOL;
        if (this.writeAsync) {
          this.asyncWriteQueue.push(text);
          this.nextAsyncWrite();
          return;
        }
        try {
          fs14.writeFileSync(this.path, text, this.writeOptions);
          this.increaseBytesWrittenCounter(text);
        } catch (e) {
          this.emit(
            "error",
            new Error(`Couldn't write to ${this.path}. ${e.message}`),
            this
          );
        }
      }
    };
    module2.exports = File;
    function readFileSyncFromEnd(filePath, bytesCount) {
      const buffer = Buffer.alloc(bytesCount);
      const stats = fs14.statSync(filePath);
      const readLength = Math.min(stats.size, bytesCount);
      const offset = Math.max(0, stats.size - bytesCount);
      const fd = fs14.openSync(filePath, "r");
      const totalBytes = fs14.readSync(fd, buffer, 0, readLength, offset);
      fs14.closeSync(fd);
      return buffer.toString("utf8", 0, totalBytes);
    }
  }
});

// node_modules/electron-log/src/node/transports/file/NullFile.js
var require_NullFile = __commonJS({
  "node_modules/electron-log/src/node/transports/file/NullFile.js"(exports2, module2) {
    "use strict";
    var File = require_File();
    var NullFile = class extends File {
      clear() {
      }
      crop() {
      }
      getSize() {
        return 0;
      }
      isNull() {
        return true;
      }
      writeLine() {
      }
    };
    module2.exports = NullFile;
  }
});

// node_modules/electron-log/src/node/transports/file/FileRegistry.js
var require_FileRegistry = __commonJS({
  "node_modules/electron-log/src/node/transports/file/FileRegistry.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var fs14 = require("fs");
    var path16 = require("path");
    var File = require_File();
    var NullFile = require_NullFile();
    var FileRegistry = class extends EventEmitter {
      store = {};
      constructor() {
        super();
        this.emitError = this.emitError.bind(this);
      }
      /**
       * Provide a File object corresponding to the filePath
       * @param {string} filePath
       * @param {WriteOptions} [writeOptions]
       * @param {boolean} [writeAsync]
       * @return {File}
       */
      provide({ filePath, writeOptions = {}, writeAsync = false }) {
        let file;
        try {
          filePath = path16.resolve(filePath);
          if (this.store[filePath]) {
            return this.store[filePath];
          }
          file = this.createFile({ filePath, writeOptions, writeAsync });
        } catch (e) {
          file = new NullFile({ path: filePath });
          this.emitError(e, file);
        }
        file.on("error", this.emitError);
        this.store[filePath] = file;
        return file;
      }
      /**
       * @param {string} filePath
       * @param {WriteOptions} writeOptions
       * @param {boolean} async
       * @return {File}
       * @private
       */
      createFile({ filePath, writeOptions, writeAsync }) {
        this.testFileWriting({ filePath, writeOptions });
        return new File({ path: filePath, writeOptions, writeAsync });
      }
      /**
       * @param {Error} error
       * @param {File} file
       * @private
       */
      emitError(error, file) {
        this.emit("error", error, file);
      }
      /**
       * @param {string} filePath
       * @param {WriteOptions} writeOptions
       * @private
       */
      testFileWriting({ filePath, writeOptions }) {
        fs14.mkdirSync(path16.dirname(filePath), { recursive: true });
        fs14.writeFileSync(filePath, "", { flag: "a", mode: writeOptions.mode });
      }
    };
    module2.exports = FileRegistry;
  }
});

// node_modules/electron-log/src/node/transports/file/index.js
var require_file = __commonJS({
  "node_modules/electron-log/src/node/transports/file/index.js"(exports2, module2) {
    "use strict";
    var fs14 = require("fs");
    var os = require("os");
    var path16 = require("path");
    var FileRegistry = require_FileRegistry();
    var { transform } = require_transform();
    var { removeStyles } = require_style();
    var {
      format,
      concatFirstStringElements
    } = require_format();
    var { toString } = require_object();
    module2.exports = fileTransportFactory;
    var globalRegistry = new FileRegistry();
    function fileTransportFactory(logger2, { registry = globalRegistry, externalApi } = {}) {
      let pathVariables;
      if (registry.listenerCount("error") < 1) {
        registry.on("error", (e, file) => {
          logConsole(`Can't write to ${file}`, e);
        });
      }
      return Object.assign(transport, {
        fileName: getDefaultFileName(logger2.variables.processType),
        format: "[{y}-{m}-{d} {h}:{i}:{s}.{ms}] [{level}]{scope} {text}",
        getFile,
        inspectOptions: { depth: 5 },
        level: "silly",
        maxSize: 1024 ** 2,
        readAllLogs,
        sync: true,
        transforms: [removeStyles, format, concatFirstStringElements, toString],
        writeOptions: { flag: "a", mode: 438, encoding: "utf8" },
        archiveLogFn(file) {
          const oldPath = file.toString();
          const inf = path16.parse(oldPath);
          try {
            fs14.renameSync(oldPath, path16.join(inf.dir, `${inf.name}.old${inf.ext}`));
          } catch (e) {
            logConsole("Could not rotate log", e);
            const quarterOfMaxSize = Math.round(transport.maxSize / 4);
            file.crop(Math.min(quarterOfMaxSize, 256 * 1024));
          }
        },
        resolvePathFn(vars) {
          return path16.join(vars.libraryDefaultDir, vars.fileName);
        },
        setAppName(name) {
          logger2.dependencies.externalApi.setAppName(name);
        }
      });
      function transport(message) {
        const file = getFile(message);
        const needLogRotation = transport.maxSize > 0 && file.size > transport.maxSize;
        if (needLogRotation) {
          transport.archiveLogFn(file);
          file.reset();
        }
        const content = transform({ logger: logger2, message, transport });
        file.writeLine(content);
      }
      function initializeOnFirstAccess() {
        if (pathVariables) {
          return;
        }
        pathVariables = Object.create(
          Object.prototype,
          {
            ...Object.getOwnPropertyDescriptors(
              externalApi.getPathVariables()
            ),
            fileName: {
              get() {
                return transport.fileName;
              },
              enumerable: true
            }
          }
        );
        if (typeof transport.archiveLog === "function") {
          transport.archiveLogFn = transport.archiveLog;
          logConsole("archiveLog is deprecated. Use archiveLogFn instead");
        }
        if (typeof transport.resolvePath === "function") {
          transport.resolvePathFn = transport.resolvePath;
          logConsole("resolvePath is deprecated. Use resolvePathFn instead");
        }
      }
      function logConsole(message, error = null, level = "error") {
        const data = [`electron-log.transports.file: ${message}`];
        if (error) {
          data.push(error);
        }
        logger2.transports.console({ data, date: /* @__PURE__ */ new Date(), level });
      }
      function getFile(msg) {
        initializeOnFirstAccess();
        const filePath = transport.resolvePathFn(pathVariables, msg);
        return registry.provide({
          filePath,
          writeAsync: !transport.sync,
          writeOptions: transport.writeOptions
        });
      }
      function readAllLogs({ fileFilter = (f) => f.endsWith(".log") } = {}) {
        initializeOnFirstAccess();
        const logsPath = path16.dirname(transport.resolvePathFn(pathVariables));
        if (!fs14.existsSync(logsPath)) {
          return [];
        }
        return fs14.readdirSync(logsPath).map((fileName) => path16.join(logsPath, fileName)).filter(fileFilter).map((logPath) => {
          try {
            return {
              path: logPath,
              lines: fs14.readFileSync(logPath, "utf8").split(os.EOL)
            };
          } catch {
            return null;
          }
        }).filter(Boolean);
      }
    }
    function getDefaultFileName(processType = process.type) {
      switch (processType) {
        case "renderer":
          return "renderer.log";
        case "worker":
          return "worker.log";
        default:
          return "main.log";
      }
    }
  }
});

// node_modules/electron-log/src/node/transports/ipc.js
var require_ipc2 = __commonJS({
  "node_modules/electron-log/src/node/transports/ipc.js"(exports2, module2) {
    "use strict";
    var { maxDepth, toJSON } = require_object();
    var { transform } = require_transform();
    module2.exports = ipcTransportFactory;
    function ipcTransportFactory(logger2, { externalApi }) {
      Object.assign(transport, {
        depth: 3,
        eventId: "__ELECTRON_LOG_IPC__",
        level: logger2.isDev ? "silly" : false,
        transforms: [toJSON, maxDepth]
      });
      return externalApi?.isElectron() ? transport : void 0;
      function transport(message) {
        if (message?.variables?.processType === "renderer") {
          return;
        }
        externalApi?.sendIpc(transport.eventId, {
          ...message,
          data: transform({ logger: logger2, message, transport })
        });
      }
    }
  }
});

// node_modules/electron-log/src/node/transports/remote.js
var require_remote = __commonJS({
  "node_modules/electron-log/src/node/transports/remote.js"(exports2, module2) {
    "use strict";
    var http = require("http");
    var https = require("https");
    var { transform } = require_transform();
    var { removeStyles } = require_style();
    var { toJSON, maxDepth } = require_object();
    module2.exports = remoteTransportFactory;
    function remoteTransportFactory(logger2) {
      return Object.assign(transport, {
        client: { name: "electron-application" },
        depth: 6,
        level: false,
        requestOptions: {},
        transforms: [removeStyles, toJSON, maxDepth],
        makeBodyFn({ message }) {
          return JSON.stringify({
            client: transport.client,
            data: message.data,
            date: message.date.getTime(),
            level: message.level,
            scope: message.scope,
            variables: message.variables
          });
        },
        processErrorFn({ error }) {
          logger2.processMessage(
            {
              data: [`electron-log: can't POST ${transport.url}`, error],
              level: "warn"
            },
            { transports: ["console", "file"] }
          );
        },
        sendRequestFn({ serverUrl, requestOptions, body }) {
          const httpTransport = serverUrl.startsWith("https:") ? https : http;
          const request = httpTransport.request(serverUrl, {
            method: "POST",
            ...requestOptions,
            headers: {
              "Content-Type": "application/json",
              "Content-Length": body.length,
              ...requestOptions.headers
            }
          });
          request.write(body);
          request.end();
          return request;
        }
      });
      function transport(message) {
        if (!transport.url) {
          return;
        }
        const body = transport.makeBodyFn({
          logger: logger2,
          message: { ...message, data: transform({ logger: logger2, message, transport }) },
          transport
        });
        const request = transport.sendRequestFn({
          serverUrl: transport.url,
          requestOptions: transport.requestOptions,
          body: Buffer.from(body, "utf8")
        });
        request.on("error", (error) => transport.processErrorFn({
          error,
          logger: logger2,
          message,
          request,
          transport
        }));
      }
    }
  }
});

// node_modules/electron-log/src/node/createDefaultLogger.js
var require_createDefaultLogger = __commonJS({
  "node_modules/electron-log/src/node/createDefaultLogger.js"(exports2, module2) {
    "use strict";
    var Logger = require_Logger();
    var ErrorHandler = require_ErrorHandler();
    var EventLogger = require_EventLogger();
    var transportConsole = require_console2();
    var transportFile = require_file();
    var transportIpc = require_ipc2();
    var transportRemote = require_remote();
    module2.exports = createDefaultLogger;
    function createDefaultLogger({ dependencies, initializeFn }) {
      const defaultLogger = new Logger({
        dependencies,
        errorHandler: new ErrorHandler(),
        eventLogger: new EventLogger(),
        initializeFn,
        isDev: dependencies.externalApi?.isDev(),
        logId: "default",
        transportFactories: {
          console: transportConsole,
          file: transportFile,
          ipc: transportIpc,
          remote: transportRemote
        },
        variables: {
          processType: "main"
        }
      });
      defaultLogger.default = defaultLogger;
      defaultLogger.Logger = Logger;
      defaultLogger.processInternalErrorFn = (e) => {
        defaultLogger.transports.console.writeFn({
          message: {
            data: ["Unhandled electron-log error", e],
            level: "error"
          }
        });
      };
      return defaultLogger;
    }
  }
});

// node_modules/electron-log/src/main/index.js
var require_main = __commonJS({
  "node_modules/electron-log/src/main/index.js"(exports2, module2) {
    "use strict";
    var electron = require("electron");
    var ElectronExternalApi = require_ElectronExternalApi();
    var { initialize } = require_initialize();
    var createDefaultLogger = require_createDefaultLogger();
    var externalApi = new ElectronExternalApi({ electron });
    var defaultLogger = createDefaultLogger({
      dependencies: { externalApi },
      initializeFn: initialize
    });
    module2.exports = defaultLogger;
    externalApi.onIpc("__ELECTRON_LOG__", (_, message) => {
      if (message.scope) {
        defaultLogger.Logger.getInstance(message).scope(message.scope);
      }
      const date = new Date(message.date);
      processMessage({
        ...message,
        date: date.getTime() ? date : /* @__PURE__ */ new Date()
      });
    });
    externalApi.onIpcInvoke("__ELECTRON_LOG__", (_, { cmd = "", logId }) => {
      switch (cmd) {
        case "getOptions": {
          const logger2 = defaultLogger.Logger.getInstance({ logId });
          return {
            levels: logger2.levels,
            logId
          };
        }
        default: {
          processMessage({ data: [`Unknown cmd '${cmd}'`], level: "error" });
          return {};
        }
      }
    });
    function processMessage(message) {
      defaultLogger.Logger.getInstance(message)?.processMessage(message);
    }
  }
});

// node_modules/electron-log/src/node/index.js
var require_node = __commonJS({
  "node_modules/electron-log/src/node/index.js"(exports2, module2) {
    "use strict";
    var NodeExternalApi = require_NodeExternalApi();
    var createDefaultLogger = require_createDefaultLogger();
    var externalApi = new NodeExternalApi();
    var defaultLogger = createDefaultLogger({
      dependencies: { externalApi }
    });
    module2.exports = defaultLogger;
  }
});

// node_modules/electron-log/src/index.js
var require_src = __commonJS({
  "node_modules/electron-log/src/index.js"(exports2, module2) {
    "use strict";
    var isRenderer = typeof process === "undefined" || (process.type === "renderer" || process.type === "worker");
    var isMain = typeof process === "object" && process.type === "browser";
    if (isRenderer) {
      require_electron_log_preload();
      module2.exports = require_renderer();
    } else if (isMain) {
      module2.exports = require_main();
    } else {
      module2.exports = require_node();
    }
  }
});

// electron/src/utils/logger.ts
var logger_exports = {};
__export(logger_exports, {
  default: () => logger_default,
  logger: () => logger
});
var import_electron_log, import_electron2, import_path, import_fs, userDataPath, logsDir, logger, logger_default;
var init_logger = __esm({
  "electron/src/utils/logger.ts"() {
    "use strict";
    import_electron_log = __toESM(require_src());
    import_electron2 = require("electron");
    import_path = __toESM(require("path"));
    import_fs = __toESM(require("fs"));
    import_electron_log.default.transports.file.level = "info";
    import_electron_log.default.transports.console.level = "debug";
    userDataPath = import_electron2.app.getPath("userData");
    import_electron_log.default.transports.file.resolvePathFn = () => import_path.default.join(userDataPath, "logs", "main.log");
    logsDir = import_path.default.join(userDataPath, "logs");
    if (!import_fs.default.existsSync(logsDir)) {
      import_fs.default.mkdirSync(logsDir, { recursive: true });
    }
    logger = {
      error: (message, ...args) => {
        import_electron_log.default.error(message, ...args);
        console.error(`[ERROR] ${message}`, ...args);
      },
      warn: (message, ...args) => {
        import_electron_log.default.warn(message, ...args);
        console.warn(`[WARN] ${message}`, ...args);
      },
      info: (message, ...args) => {
        import_electron_log.default.info(message, ...args);
        console.info(`[INFO] ${message}`, ...args);
      },
      debug: (message, ...args) => {
        import_electron_log.default.debug(message, ...args);
        console.debug(`[DEBUG] ${message}`, ...args);
      },
      verbose: (message, ...args) => {
        import_electron_log.default.verbose(message, ...args);
      }
    };
    logger_default = logger;
  }
});

// electron/src/utils/errorHandler.ts
async function withTimeout(operation, timeoutMs = 3e4, errorMessage = "Operation timed out") {
  return Promise.race([
    operation(),
    new Promise((_, reject) => {
      setTimeout(() => {
        reject(new AppError(errorMessage, "TIMEOUT", 408, void 0, true));
      }, timeoutMs);
    })
  ]);
}
function wrapIpcHandler(handler, operation, timeout = 3e4) {
  return async (event, payload) => {
    try {
      return await withTimeout(
        () => handler(payload),
        timeout,
        `${operation} timed out after ${timeout}ms`
      );
    } catch (error) {
      const appError = error instanceof AppError ? error : new AppError(
        error instanceof Error ? error.message : String(error),
        "IPC_HANDLER_ERROR",
        500,
        { operation },
        error instanceof AppError ? error.isRetryable : false
      );
      logger.error(`[IPC Error] ${operation}`, {
        error: appError.message,
        code: appError.code,
        context: appError.context,
        stack: appError.stack,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
      throw new Error(appError.message);
    }
  };
}
async function recoverDatabaseConnection() {
  try {
    const prisma2 = getPrismaClient();
    await prisma2.$disconnect().catch(() => {
    });
    await new Promise((resolve) => setTimeout(resolve, 1e3));
    await prisma2.$queryRaw`SELECT 1`;
    return true;
  } catch (error) {
    logger.error("Failed to recover database connection", error);
    return false;
  }
}
async function safeDbOperation(operation, context) {
  let lastError = null;
  const maxRetries = 3;
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await operation();
    } catch (error) {
      lastError = error instanceof Error ? error : new Error(String(error));
      const errorMessage = lastError.message;
      const isDbError = errorMessage.includes("database is locked") || errorMessage.includes("SQLITE_BUSY") || errorMessage.includes("SQLITE_LOCKED") || errorMessage.includes("connection") || errorMessage.includes("ECONNREFUSED") || errorMessage.includes("ETIMEDOUT");
      if (isDbError && attempt < maxRetries) {
        logger.warn(`Database error detected (attempt ${attempt}/${maxRetries}), attempting recovery...`);
        await new Promise((resolve) => setTimeout(resolve, Math.pow(2, attempt) * 100));
        const recovered = await recoverDatabaseConnection();
        if (recovered) {
          logger.info("Database connection recovered, retrying operation...");
          continue;
        } else {
          logger.warn("Database recovery failed, will retry operation anyway...");
          continue;
        }
      }
      if (!isDbError || attempt >= maxRetries) {
        if (isDbError) {
          throw new AppError(
            `Database operation failed after ${maxRetries} attempts: ${errorMessage}`,
            "DB_CONNECTION_ERROR",
            503,
            context,
            true
          );
        }
        throw lastError;
      }
    }
  }
  throw lastError || new Error("Operation failed");
}
function initializeErrorHandlers() {
  process.on("uncaughtException", (error) => {
    logger.error("[Uncaught Exception]", {
      message: error.message,
      stack: error.stack,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  });
  process.on("unhandledRejection", (reason, promise) => {
    logger.error("[Unhandled Rejection]", {
      reason: reason instanceof Error ? reason.message : String(reason),
      stack: reason instanceof Error ? reason.stack : void 0,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  });
  import_electron3.app.on("render-process-gone", (event, webContents, details) => {
    logger.error("[Render Process Gone]", {
      reason: details.reason,
      exitCode: details.exitCode,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  });
  import_electron3.app.on("child-process-gone", (event, details) => {
    logger.error("[Child Process Gone]", {
      type: details.type,
      reason: details.reason,
      exitCode: details.exitCode,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  });
}
function getUserFriendlyError(error) {
  if (error instanceof AppError) {
    switch (error.code) {
      case "TIMEOUT":
        return "The operation took too long. Please try again.";
      case "DB_CONNECTION_ERROR":
        return "Database connection error. Please check your connection and try again.";
      case "CIRCUIT_BREAKER_OPEN":
        return "Service temporarily unavailable. Please try again in a moment.";
      default:
        return error.message || "An unexpected error occurred.";
    }
  }
  if (error instanceof Error) {
    if (error.message.includes("database is locked")) {
      return "Database is busy. Please wait a moment and try again.";
    }
    if (error.message.includes("timeout")) {
      return "Operation timed out. Please try again.";
    }
    return error.message;
  }
  return "An unexpected error occurred.";
}
var import_electron3, AppError, CircuitBreaker, circuitBreaker;
var init_errorHandler = __esm({
  "electron/src/utils/errorHandler.ts"() {
    "use strict";
    import_electron3 = require("electron");
    init_prismaClient();
    init_logger();
    AppError = class extends Error {
      constructor(message, code, statusCode = 500, context, isRetryable = false) {
        super(message);
        this.code = code;
        this.statusCode = statusCode;
        this.context = context;
        this.isRetryable = isRetryable;
        this.name = "AppError";
      }
    };
    CircuitBreaker = class {
      constructor(threshold = 5, timeout = 6e4) {
        this.threshold = threshold;
        this.timeout = timeout;
        this.failures = /* @__PURE__ */ new Map();
        this.lastFailure = /* @__PURE__ */ new Map();
        this.state = /* @__PURE__ */ new Map();
      }
      async execute(key, operation, fallback) {
        const state = this.state.get(key) || "CLOSED";
        if (state === "OPEN") {
          const lastFail = this.lastFailure.get(key) || 0;
          if (Date.now() - lastFail < this.timeout) {
            if (fallback) {
              return fallback();
            }
            throw new AppError(
              `Circuit breaker is OPEN for ${key}`,
              "CIRCUIT_BREAKER_OPEN",
              503,
              { operation: key },
              true
            );
          }
          this.state.set(key, "HALF_OPEN");
        }
        try {
          const result = await operation();
          this.failures.set(key, 0);
          this.state.set(key, "CLOSED");
          return result;
        } catch (error) {
          const failures = (this.failures.get(key) || 0) + 1;
          this.failures.set(key, failures);
          this.lastFailure.set(key, Date.now());
          if (failures >= this.threshold) {
            this.state.set(key, "OPEN");
          }
          if (state === "HALF_OPEN") {
            this.state.set(key, "OPEN");
          }
          throw error;
        }
      }
    };
    circuitBreaker = new CircuitBreaker();
  }
});

// node_modules/bcryptjs/dist/bcrypt.js
var require_bcrypt = __commonJS({
  "node_modules/bcryptjs/dist/bcrypt.js"(exports2, module2) {
    (function(global2, factory) {
      if (typeof define === "function" && define["amd"])
        define([], factory);
      else if (typeof require === "function" && typeof module2 === "object" && module2 && module2["exports"])
        module2["exports"] = factory();
      else
        (global2["dcodeIO"] = global2["dcodeIO"] || {})["bcrypt"] = factory();
    })(exports2, function() {
      "use strict";
      var bcrypt3 = {};
      var randomFallback = null;
      function random(len) {
        if (typeof module2 !== "undefined" && module2 && module2["exports"])
          try {
            return require("crypto")["randomBytes"](len);
          } catch (e) {
          }
        try {
          var a;
          (self["crypto"] || self["msCrypto"])["getRandomValues"](a = new Uint32Array(len));
          return Array.prototype.slice.call(a);
        } catch (e) {
        }
        if (!randomFallback)
          throw Error("Neither WebCryptoAPI nor a crypto module is available. Use bcrypt.setRandomFallback to set an alternative");
        return randomFallback(len);
      }
      var randomAvailable = false;
      try {
        random(1);
        randomAvailable = true;
      } catch (e) {
      }
      randomFallback = null;
      bcrypt3.setRandomFallback = function(random2) {
        randomFallback = random2;
      };
      bcrypt3.genSaltSync = function(rounds, seed_length) {
        rounds = rounds || GENSALT_DEFAULT_LOG2_ROUNDS;
        if (typeof rounds !== "number")
          throw Error("Illegal arguments: " + typeof rounds + ", " + typeof seed_length);
        if (rounds < 4)
          rounds = 4;
        else if (rounds > 31)
          rounds = 31;
        var salt = [];
        salt.push("$2a$");
        if (rounds < 10)
          salt.push("0");
        salt.push(rounds.toString());
        salt.push("$");
        salt.push(base64_encode(random(BCRYPT_SALT_LEN), BCRYPT_SALT_LEN));
        return salt.join("");
      };
      bcrypt3.genSalt = function(rounds, seed_length, callback) {
        if (typeof seed_length === "function")
          callback = seed_length, seed_length = void 0;
        if (typeof rounds === "function")
          callback = rounds, rounds = void 0;
        if (typeof rounds === "undefined")
          rounds = GENSALT_DEFAULT_LOG2_ROUNDS;
        else if (typeof rounds !== "number")
          throw Error("illegal arguments: " + typeof rounds);
        function _async(callback2) {
          nextTick(function() {
            try {
              callback2(null, bcrypt3.genSaltSync(rounds));
            } catch (err) {
              callback2(err);
            }
          });
        }
        if (callback) {
          if (typeof callback !== "function")
            throw Error("Illegal callback: " + typeof callback);
          _async(callback);
        } else
          return new Promise(function(resolve, reject) {
            _async(function(err, res) {
              if (err) {
                reject(err);
                return;
              }
              resolve(res);
            });
          });
      };
      bcrypt3.hashSync = function(s, salt) {
        if (typeof salt === "undefined")
          salt = GENSALT_DEFAULT_LOG2_ROUNDS;
        if (typeof salt === "number")
          salt = bcrypt3.genSaltSync(salt);
        if (typeof s !== "string" || typeof salt !== "string")
          throw Error("Illegal arguments: " + typeof s + ", " + typeof salt);
        return _hash(s, salt);
      };
      bcrypt3.hash = function(s, salt, callback, progressCallback) {
        function _async(callback2) {
          if (typeof s === "string" && typeof salt === "number")
            bcrypt3.genSalt(salt, function(err, salt2) {
              _hash(s, salt2, callback2, progressCallback);
            });
          else if (typeof s === "string" && typeof salt === "string")
            _hash(s, salt, callback2, progressCallback);
          else
            nextTick(callback2.bind(this, Error("Illegal arguments: " + typeof s + ", " + typeof salt)));
        }
        if (callback) {
          if (typeof callback !== "function")
            throw Error("Illegal callback: " + typeof callback);
          _async(callback);
        } else
          return new Promise(function(resolve, reject) {
            _async(function(err, res) {
              if (err) {
                reject(err);
                return;
              }
              resolve(res);
            });
          });
      };
      function safeStringCompare(known, unknown) {
        var right = 0, wrong = 0;
        for (var i = 0, k = known.length; i < k; ++i) {
          if (known.charCodeAt(i) === unknown.charCodeAt(i))
            ++right;
          else
            ++wrong;
        }
        if (right < 0)
          return false;
        return wrong === 0;
      }
      bcrypt3.compareSync = function(s, hash) {
        if (typeof s !== "string" || typeof hash !== "string")
          throw Error("Illegal arguments: " + typeof s + ", " + typeof hash);
        if (hash.length !== 60)
          return false;
        return safeStringCompare(bcrypt3.hashSync(s, hash.substr(0, hash.length - 31)), hash);
      };
      bcrypt3.compare = function(s, hash, callback, progressCallback) {
        function _async(callback2) {
          if (typeof s !== "string" || typeof hash !== "string") {
            nextTick(callback2.bind(this, Error("Illegal arguments: " + typeof s + ", " + typeof hash)));
            return;
          }
          if (hash.length !== 60) {
            nextTick(callback2.bind(this, null, false));
            return;
          }
          bcrypt3.hash(s, hash.substr(0, 29), function(err, comp) {
            if (err)
              callback2(err);
            else
              callback2(null, safeStringCompare(comp, hash));
          }, progressCallback);
        }
        if (callback) {
          if (typeof callback !== "function")
            throw Error("Illegal callback: " + typeof callback);
          _async(callback);
        } else
          return new Promise(function(resolve, reject) {
            _async(function(err, res) {
              if (err) {
                reject(err);
                return;
              }
              resolve(res);
            });
          });
      };
      bcrypt3.getRounds = function(hash) {
        if (typeof hash !== "string")
          throw Error("Illegal arguments: " + typeof hash);
        return parseInt(hash.split("$")[2], 10);
      };
      bcrypt3.getSalt = function(hash) {
        if (typeof hash !== "string")
          throw Error("Illegal arguments: " + typeof hash);
        if (hash.length !== 60)
          throw Error("Illegal hash length: " + hash.length + " != 60");
        return hash.substring(0, 29);
      };
      var nextTick = typeof process !== "undefined" && process && typeof process.nextTick === "function" ? typeof setImmediate === "function" ? setImmediate : process.nextTick : setTimeout;
      function stringToBytes(str) {
        var out = [], i = 0;
        utfx.encodeUTF16toUTF8(function() {
          if (i >= str.length) return null;
          return str.charCodeAt(i++);
        }, function(b) {
          out.push(b);
        });
        return out;
      }
      var BASE64_CODE = "./ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split("");
      var BASE64_INDEX = [
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        0,
        1,
        54,
        55,
        56,
        57,
        58,
        59,
        60,
        61,
        62,
        63,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        27,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        28,
        29,
        30,
        31,
        32,
        33,
        34,
        35,
        36,
        37,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        46,
        47,
        48,
        49,
        50,
        51,
        52,
        53,
        -1,
        -1,
        -1,
        -1,
        -1
      ];
      var stringFromCharCode = String.fromCharCode;
      function base64_encode(b, len) {
        var off = 0, rs = [], c1, c2;
        if (len <= 0 || len > b.length)
          throw Error("Illegal len: " + len);
        while (off < len) {
          c1 = b[off++] & 255;
          rs.push(BASE64_CODE[c1 >> 2 & 63]);
          c1 = (c1 & 3) << 4;
          if (off >= len) {
            rs.push(BASE64_CODE[c1 & 63]);
            break;
          }
          c2 = b[off++] & 255;
          c1 |= c2 >> 4 & 15;
          rs.push(BASE64_CODE[c1 & 63]);
          c1 = (c2 & 15) << 2;
          if (off >= len) {
            rs.push(BASE64_CODE[c1 & 63]);
            break;
          }
          c2 = b[off++] & 255;
          c1 |= c2 >> 6 & 3;
          rs.push(BASE64_CODE[c1 & 63]);
          rs.push(BASE64_CODE[c2 & 63]);
        }
        return rs.join("");
      }
      function base64_decode(s, len) {
        var off = 0, slen = s.length, olen = 0, rs = [], c1, c2, c3, c4, o, code;
        if (len <= 0)
          throw Error("Illegal len: " + len);
        while (off < slen - 1 && olen < len) {
          code = s.charCodeAt(off++);
          c1 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
          code = s.charCodeAt(off++);
          c2 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
          if (c1 == -1 || c2 == -1)
            break;
          o = c1 << 2 >>> 0;
          o |= (c2 & 48) >> 4;
          rs.push(stringFromCharCode(o));
          if (++olen >= len || off >= slen)
            break;
          code = s.charCodeAt(off++);
          c3 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
          if (c3 == -1)
            break;
          o = (c2 & 15) << 4 >>> 0;
          o |= (c3 & 60) >> 2;
          rs.push(stringFromCharCode(o));
          if (++olen >= len || off >= slen)
            break;
          code = s.charCodeAt(off++);
          c4 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
          o = (c3 & 3) << 6 >>> 0;
          o |= c4;
          rs.push(stringFromCharCode(o));
          ++olen;
        }
        var res = [];
        for (off = 0; off < olen; off++)
          res.push(rs[off].charCodeAt(0));
        return res;
      }
      var utfx = function() {
        "use strict";
        var utfx2 = {};
        utfx2.MAX_CODEPOINT = 1114111;
        utfx2.encodeUTF8 = function(src, dst) {
          var cp = null;
          if (typeof src === "number")
            cp = src, src = function() {
              return null;
            };
          while (cp !== null || (cp = src()) !== null) {
            if (cp < 128)
              dst(cp & 127);
            else if (cp < 2048)
              dst(cp >> 6 & 31 | 192), dst(cp & 63 | 128);
            else if (cp < 65536)
              dst(cp >> 12 & 15 | 224), dst(cp >> 6 & 63 | 128), dst(cp & 63 | 128);
            else
              dst(cp >> 18 & 7 | 240), dst(cp >> 12 & 63 | 128), dst(cp >> 6 & 63 | 128), dst(cp & 63 | 128);
            cp = null;
          }
        };
        utfx2.decodeUTF8 = function(src, dst) {
          var a, b, c, d, fail = function(b2) {
            b2 = b2.slice(0, b2.indexOf(null));
            var err = Error(b2.toString());
            err.name = "TruncatedError";
            err["bytes"] = b2;
            throw err;
          };
          while ((a = src()) !== null) {
            if ((a & 128) === 0)
              dst(a);
            else if ((a & 224) === 192)
              (b = src()) === null && fail([a, b]), dst((a & 31) << 6 | b & 63);
            else if ((a & 240) === 224)
              ((b = src()) === null || (c = src()) === null) && fail([a, b, c]), dst((a & 15) << 12 | (b & 63) << 6 | c & 63);
            else if ((a & 248) === 240)
              ((b = src()) === null || (c = src()) === null || (d = src()) === null) && fail([a, b, c, d]), dst((a & 7) << 18 | (b & 63) << 12 | (c & 63) << 6 | d & 63);
            else throw RangeError("Illegal starting byte: " + a);
          }
        };
        utfx2.UTF16toUTF8 = function(src, dst) {
          var c1, c2 = null;
          while (true) {
            if ((c1 = c2 !== null ? c2 : src()) === null)
              break;
            if (c1 >= 55296 && c1 <= 57343) {
              if ((c2 = src()) !== null) {
                if (c2 >= 56320 && c2 <= 57343) {
                  dst((c1 - 55296) * 1024 + c2 - 56320 + 65536);
                  c2 = null;
                  continue;
                }
              }
            }
            dst(c1);
          }
          if (c2 !== null) dst(c2);
        };
        utfx2.UTF8toUTF16 = function(src, dst) {
          var cp = null;
          if (typeof src === "number")
            cp = src, src = function() {
              return null;
            };
          while (cp !== null || (cp = src()) !== null) {
            if (cp <= 65535)
              dst(cp);
            else
              cp -= 65536, dst((cp >> 10) + 55296), dst(cp % 1024 + 56320);
            cp = null;
          }
        };
        utfx2.encodeUTF16toUTF8 = function(src, dst) {
          utfx2.UTF16toUTF8(src, function(cp) {
            utfx2.encodeUTF8(cp, dst);
          });
        };
        utfx2.decodeUTF8toUTF16 = function(src, dst) {
          utfx2.decodeUTF8(src, function(cp) {
            utfx2.UTF8toUTF16(cp, dst);
          });
        };
        utfx2.calculateCodePoint = function(cp) {
          return cp < 128 ? 1 : cp < 2048 ? 2 : cp < 65536 ? 3 : 4;
        };
        utfx2.calculateUTF8 = function(src) {
          var cp, l = 0;
          while ((cp = src()) !== null)
            l += utfx2.calculateCodePoint(cp);
          return l;
        };
        utfx2.calculateUTF16asUTF8 = function(src) {
          var n = 0, l = 0;
          utfx2.UTF16toUTF8(src, function(cp) {
            ++n;
            l += utfx2.calculateCodePoint(cp);
          });
          return [n, l];
        };
        return utfx2;
      }();
      Date.now = Date.now || function() {
        return +/* @__PURE__ */ new Date();
      };
      var BCRYPT_SALT_LEN = 16;
      var GENSALT_DEFAULT_LOG2_ROUNDS = 10;
      var BLOWFISH_NUM_ROUNDS = 16;
      var MAX_EXECUTION_TIME = 100;
      var P_ORIG = [
        608135816,
        2242054355,
        320440878,
        57701188,
        2752067618,
        698298832,
        137296536,
        3964562569,
        1160258022,
        953160567,
        3193202383,
        887688300,
        3232508343,
        3380367581,
        1065670069,
        3041331479,
        2450970073,
        2306472731
      ];
      var S_ORIG = [
        3509652390,
        2564797868,
        805139163,
        3491422135,
        3101798381,
        1780907670,
        3128725573,
        4046225305,
        614570311,
        3012652279,
        134345442,
        2240740374,
        1667834072,
        1901547113,
        2757295779,
        4103290238,
        227898511,
        1921955416,
        1904987480,
        2182433518,
        2069144605,
        3260701109,
        2620446009,
        720527379,
        3318853667,
        677414384,
        3393288472,
        3101374703,
        2390351024,
        1614419982,
        1822297739,
        2954791486,
        3608508353,
        3174124327,
        2024746970,
        1432378464,
        3864339955,
        2857741204,
        1464375394,
        1676153920,
        1439316330,
        715854006,
        3033291828,
        289532110,
        2706671279,
        2087905683,
        3018724369,
        1668267050,
        732546397,
        1947742710,
        3462151702,
        2609353502,
        2950085171,
        1814351708,
        2050118529,
        680887927,
        999245976,
        1800124847,
        3300911131,
        1713906067,
        1641548236,
        4213287313,
        1216130144,
        1575780402,
        4018429277,
        3917837745,
        3693486850,
        3949271944,
        596196993,
        3549867205,
        258830323,
        2213823033,
        772490370,
        2760122372,
        1774776394,
        2652871518,
        566650946,
        4142492826,
        1728879713,
        2882767088,
        1783734482,
        3629395816,
        2517608232,
        2874225571,
        1861159788,
        326777828,
        3124490320,
        2130389656,
        2716951837,
        967770486,
        1724537150,
        2185432712,
        2364442137,
        1164943284,
        2105845187,
        998989502,
        3765401048,
        2244026483,
        1075463327,
        1455516326,
        1322494562,
        910128902,
        469688178,
        1117454909,
        936433444,
        3490320968,
        3675253459,
        1240580251,
        122909385,
        2157517691,
        634681816,
        4142456567,
        3825094682,
        3061402683,
        2540495037,
        79693498,
        3249098678,
        1084186820,
        1583128258,
        426386531,
        1761308591,
        1047286709,
        322548459,
        995290223,
        1845252383,
        2603652396,
        3431023940,
        2942221577,
        3202600964,
        3727903485,
        1712269319,
        422464435,
        3234572375,
        1170764815,
        3523960633,
        3117677531,
        1434042557,
        442511882,
        3600875718,
        1076654713,
        1738483198,
        4213154764,
        2393238008,
        3677496056,
        1014306527,
        4251020053,
        793779912,
        2902807211,
        842905082,
        4246964064,
        1395751752,
        1040244610,
        2656851899,
        3396308128,
        445077038,
        3742853595,
        3577915638,
        679411651,
        2892444358,
        2354009459,
        1767581616,
        3150600392,
        3791627101,
        3102740896,
        284835224,
        4246832056,
        1258075500,
        768725851,
        2589189241,
        3069724005,
        3532540348,
        1274779536,
        3789419226,
        2764799539,
        1660621633,
        3471099624,
        4011903706,
        913787905,
        3497959166,
        737222580,
        2514213453,
        2928710040,
        3937242737,
        1804850592,
        3499020752,
        2949064160,
        2386320175,
        2390070455,
        2415321851,
        4061277028,
        2290661394,
        2416832540,
        1336762016,
        1754252060,
        3520065937,
        3014181293,
        791618072,
        3188594551,
        3933548030,
        2332172193,
        3852520463,
        3043980520,
        413987798,
        3465142937,
        3030929376,
        4245938359,
        2093235073,
        3534596313,
        375366246,
        2157278981,
        2479649556,
        555357303,
        3870105701,
        2008414854,
        3344188149,
        4221384143,
        3956125452,
        2067696032,
        3594591187,
        2921233993,
        2428461,
        544322398,
        577241275,
        1471733935,
        610547355,
        4027169054,
        1432588573,
        1507829418,
        2025931657,
        3646575487,
        545086370,
        48609733,
        2200306550,
        1653985193,
        298326376,
        1316178497,
        3007786442,
        2064951626,
        458293330,
        2589141269,
        3591329599,
        3164325604,
        727753846,
        2179363840,
        146436021,
        1461446943,
        4069977195,
        705550613,
        3059967265,
        3887724982,
        4281599278,
        3313849956,
        1404054877,
        2845806497,
        146425753,
        1854211946,
        1266315497,
        3048417604,
        3681880366,
        3289982499,
        290971e4,
        1235738493,
        2632868024,
        2414719590,
        3970600049,
        1771706367,
        1449415276,
        3266420449,
        422970021,
        1963543593,
        2690192192,
        3826793022,
        1062508698,
        1531092325,
        1804592342,
        2583117782,
        2714934279,
        4024971509,
        1294809318,
        4028980673,
        1289560198,
        2221992742,
        1669523910,
        35572830,
        157838143,
        1052438473,
        1016535060,
        1802137761,
        1753167236,
        1386275462,
        3080475397,
        2857371447,
        1040679964,
        2145300060,
        2390574316,
        1461121720,
        2956646967,
        4031777805,
        4028374788,
        33600511,
        2920084762,
        1018524850,
        629373528,
        3691585981,
        3515945977,
        2091462646,
        2486323059,
        586499841,
        988145025,
        935516892,
        3367335476,
        2599673255,
        2839830854,
        265290510,
        3972581182,
        2759138881,
        3795373465,
        1005194799,
        847297441,
        406762289,
        1314163512,
        1332590856,
        1866599683,
        4127851711,
        750260880,
        613907577,
        1450815602,
        3165620655,
        3734664991,
        3650291728,
        3012275730,
        3704569646,
        1427272223,
        778793252,
        1343938022,
        2676280711,
        2052605720,
        1946737175,
        3164576444,
        3914038668,
        3967478842,
        3682934266,
        1661551462,
        3294938066,
        4011595847,
        840292616,
        3712170807,
        616741398,
        312560963,
        711312465,
        1351876610,
        322626781,
        1910503582,
        271666773,
        2175563734,
        1594956187,
        70604529,
        3617834859,
        1007753275,
        1495573769,
        4069517037,
        2549218298,
        2663038764,
        504708206,
        2263041392,
        3941167025,
        2249088522,
        1514023603,
        1998579484,
        1312622330,
        694541497,
        2582060303,
        2151582166,
        1382467621,
        776784248,
        2618340202,
        3323268794,
        2497899128,
        2784771155,
        503983604,
        4076293799,
        907881277,
        423175695,
        432175456,
        1378068232,
        4145222326,
        3954048622,
        3938656102,
        3820766613,
        2793130115,
        2977904593,
        26017576,
        3274890735,
        3194772133,
        1700274565,
        1756076034,
        4006520079,
        3677328699,
        720338349,
        1533947780,
        354530856,
        688349552,
        3973924725,
        1637815568,
        332179504,
        3949051286,
        53804574,
        2852348879,
        3044236432,
        1282449977,
        3583942155,
        3416972820,
        4006381244,
        1617046695,
        2628476075,
        3002303598,
        1686838959,
        431878346,
        2686675385,
        1700445008,
        1080580658,
        1009431731,
        832498133,
        3223435511,
        2605976345,
        2271191193,
        2516031870,
        1648197032,
        4164389018,
        2548247927,
        300782431,
        375919233,
        238389289,
        3353747414,
        2531188641,
        2019080857,
        1475708069,
        455242339,
        2609103871,
        448939670,
        3451063019,
        1395535956,
        2413381860,
        1841049896,
        1491858159,
        885456874,
        4264095073,
        4001119347,
        1565136089,
        3898914787,
        1108368660,
        540939232,
        1173283510,
        2745871338,
        3681308437,
        4207628240,
        3343053890,
        4016749493,
        1699691293,
        1103962373,
        3625875870,
        2256883143,
        3830138730,
        1031889488,
        3479347698,
        1535977030,
        4236805024,
        3251091107,
        2132092099,
        1774941330,
        1199868427,
        1452454533,
        157007616,
        2904115357,
        342012276,
        595725824,
        1480756522,
        206960106,
        497939518,
        591360097,
        863170706,
        2375253569,
        3596610801,
        1814182875,
        2094937945,
        3421402208,
        1082520231,
        3463918190,
        2785509508,
        435703966,
        3908032597,
        1641649973,
        2842273706,
        3305899714,
        1510255612,
        2148256476,
        2655287854,
        3276092548,
        4258621189,
        236887753,
        3681803219,
        274041037,
        1734335097,
        3815195456,
        3317970021,
        1899903192,
        1026095262,
        4050517792,
        356393447,
        2410691914,
        3873677099,
        3682840055,
        3913112168,
        2491498743,
        4132185628,
        2489919796,
        1091903735,
        1979897079,
        3170134830,
        3567386728,
        3557303409,
        857797738,
        1136121015,
        1342202287,
        507115054,
        2535736646,
        337727348,
        3213592640,
        1301675037,
        2528481711,
        1895095763,
        1721773893,
        3216771564,
        62756741,
        2142006736,
        835421444,
        2531993523,
        1442658625,
        3659876326,
        2882144922,
        676362277,
        1392781812,
        170690266,
        3921047035,
        1759253602,
        3611846912,
        1745797284,
        664899054,
        1329594018,
        3901205900,
        3045908486,
        2062866102,
        2865634940,
        3543621612,
        3464012697,
        1080764994,
        553557557,
        3656615353,
        3996768171,
        991055499,
        499776247,
        1265440854,
        648242737,
        3940784050,
        980351604,
        3713745714,
        1749149687,
        3396870395,
        4211799374,
        3640570775,
        1161844396,
        3125318951,
        1431517754,
        545492359,
        4268468663,
        3499529547,
        1437099964,
        2702547544,
        3433638243,
        2581715763,
        2787789398,
        1060185593,
        1593081372,
        2418618748,
        4260947970,
        69676912,
        2159744348,
        86519011,
        2512459080,
        3838209314,
        1220612927,
        3339683548,
        133810670,
        1090789135,
        1078426020,
        1569222167,
        845107691,
        3583754449,
        4072456591,
        1091646820,
        628848692,
        1613405280,
        3757631651,
        526609435,
        236106946,
        48312990,
        2942717905,
        3402727701,
        1797494240,
        859738849,
        992217954,
        4005476642,
        2243076622,
        3870952857,
        3732016268,
        765654824,
        3490871365,
        2511836413,
        1685915746,
        3888969200,
        1414112111,
        2273134842,
        3281911079,
        4080962846,
        172450625,
        2569994100,
        980381355,
        4109958455,
        2819808352,
        2716589560,
        2568741196,
        3681446669,
        3329971472,
        1835478071,
        660984891,
        3704678404,
        4045999559,
        3422617507,
        3040415634,
        1762651403,
        1719377915,
        3470491036,
        2693910283,
        3642056355,
        3138596744,
        1364962596,
        2073328063,
        1983633131,
        926494387,
        3423689081,
        2150032023,
        4096667949,
        1749200295,
        3328846651,
        309677260,
        2016342300,
        1779581495,
        3079819751,
        111262694,
        1274766160,
        443224088,
        298511866,
        1025883608,
        3806446537,
        1145181785,
        168956806,
        3641502830,
        3584813610,
        1689216846,
        3666258015,
        3200248200,
        1692713982,
        2646376535,
        4042768518,
        1618508792,
        1610833997,
        3523052358,
        4130873264,
        2001055236,
        3610705100,
        2202168115,
        4028541809,
        2961195399,
        1006657119,
        2006996926,
        3186142756,
        1430667929,
        3210227297,
        1314452623,
        4074634658,
        4101304120,
        2273951170,
        1399257539,
        3367210612,
        3027628629,
        1190975929,
        2062231137,
        2333990788,
        2221543033,
        2438960610,
        1181637006,
        548689776,
        2362791313,
        3372408396,
        3104550113,
        3145860560,
        296247880,
        1970579870,
        3078560182,
        3769228297,
        1714227617,
        3291629107,
        3898220290,
        166772364,
        1251581989,
        493813264,
        448347421,
        195405023,
        2709975567,
        677966185,
        3703036547,
        1463355134,
        2715995803,
        1338867538,
        1343315457,
        2802222074,
        2684532164,
        233230375,
        2599980071,
        2000651841,
        3277868038,
        1638401717,
        4028070440,
        3237316320,
        6314154,
        819756386,
        300326615,
        590932579,
        1405279636,
        3267499572,
        3150704214,
        2428286686,
        3959192993,
        3461946742,
        1862657033,
        1266418056,
        963775037,
        2089974820,
        2263052895,
        1917689273,
        448879540,
        3550394620,
        3981727096,
        150775221,
        3627908307,
        1303187396,
        508620638,
        2975983352,
        2726630617,
        1817252668,
        1876281319,
        1457606340,
        908771278,
        3720792119,
        3617206836,
        2455994898,
        1729034894,
        1080033504,
        976866871,
        3556439503,
        2881648439,
        1522871579,
        1555064734,
        1336096578,
        3548522304,
        2579274686,
        3574697629,
        3205460757,
        3593280638,
        3338716283,
        3079412587,
        564236357,
        2993598910,
        1781952180,
        1464380207,
        3163844217,
        3332601554,
        1699332808,
        1393555694,
        1183702653,
        3581086237,
        1288719814,
        691649499,
        2847557200,
        2895455976,
        3193889540,
        2717570544,
        1781354906,
        1676643554,
        2592534050,
        3230253752,
        1126444790,
        2770207658,
        2633158820,
        2210423226,
        2615765581,
        2414155088,
        3127139286,
        673620729,
        2805611233,
        1269405062,
        4015350505,
        3341807571,
        4149409754,
        1057255273,
        2012875353,
        2162469141,
        2276492801,
        2601117357,
        993977747,
        3918593370,
        2654263191,
        753973209,
        36408145,
        2530585658,
        25011837,
        3520020182,
        2088578344,
        530523599,
        2918365339,
        1524020338,
        1518925132,
        3760827505,
        3759777254,
        1202760957,
        3985898139,
        3906192525,
        674977740,
        4174734889,
        2031300136,
        2019492241,
        3983892565,
        4153806404,
        3822280332,
        352677332,
        2297720250,
        60907813,
        90501309,
        3286998549,
        1016092578,
        2535922412,
        2839152426,
        457141659,
        509813237,
        4120667899,
        652014361,
        1966332200,
        2975202805,
        55981186,
        2327461051,
        676427537,
        3255491064,
        2882294119,
        3433927263,
        1307055953,
        942726286,
        933058658,
        2468411793,
        3933900994,
        4215176142,
        1361170020,
        2001714738,
        2830558078,
        3274259782,
        1222529897,
        1679025792,
        2729314320,
        3714953764,
        1770335741,
        151462246,
        3013232138,
        1682292957,
        1483529935,
        471910574,
        1539241949,
        458788160,
        3436315007,
        1807016891,
        3718408830,
        978976581,
        1043663428,
        3165965781,
        1927990952,
        4200891579,
        2372276910,
        3208408903,
        3533431907,
        1412390302,
        2931980059,
        4132332400,
        1947078029,
        3881505623,
        4168226417,
        2941484381,
        1077988104,
        1320477388,
        886195818,
        18198404,
        3786409e3,
        2509781533,
        112762804,
        3463356488,
        1866414978,
        891333506,
        18488651,
        661792760,
        1628790961,
        3885187036,
        3141171499,
        876946877,
        2693282273,
        1372485963,
        791857591,
        2686433993,
        3759982718,
        3167212022,
        3472953795,
        2716379847,
        445679433,
        3561995674,
        3504004811,
        3574258232,
        54117162,
        3331405415,
        2381918588,
        3769707343,
        4154350007,
        1140177722,
        4074052095,
        668550556,
        3214352940,
        367459370,
        261225585,
        2610173221,
        4209349473,
        3468074219,
        3265815641,
        314222801,
        3066103646,
        3808782860,
        282218597,
        3406013506,
        3773591054,
        379116347,
        1285071038,
        846784868,
        2669647154,
        3771962079,
        3550491691,
        2305946142,
        453669953,
        1268987020,
        3317592352,
        3279303384,
        3744833421,
        2610507566,
        3859509063,
        266596637,
        3847019092,
        517658769,
        3462560207,
        3443424879,
        370717030,
        4247526661,
        2224018117,
        4143653529,
        4112773975,
        2788324899,
        2477274417,
        1456262402,
        2901442914,
        1517677493,
        1846949527,
        2295493580,
        3734397586,
        2176403920,
        1280348187,
        1908823572,
        3871786941,
        846861322,
        1172426758,
        3287448474,
        3383383037,
        1655181056,
        3139813346,
        901632758,
        1897031941,
        2986607138,
        3066810236,
        3447102507,
        1393639104,
        373351379,
        950779232,
        625454576,
        3124240540,
        4148612726,
        2007998917,
        544563296,
        2244738638,
        2330496472,
        2058025392,
        1291430526,
        424198748,
        50039436,
        29584100,
        3605783033,
        2429876329,
        2791104160,
        1057563949,
        3255363231,
        3075367218,
        3463963227,
        1469046755,
        985887462
      ];
      var C_ORIG = [
        1332899944,
        1700884034,
        1701343084,
        1684370003,
        1668446532,
        1869963892
      ];
      function _encipher(lr, off, P, S) {
        var n, l = lr[off], r = lr[off + 1];
        l ^= P[0];
        n = S[l >>> 24];
        n += S[256 | l >> 16 & 255];
        n ^= S[512 | l >> 8 & 255];
        n += S[768 | l & 255];
        r ^= n ^ P[1];
        n = S[r >>> 24];
        n += S[256 | r >> 16 & 255];
        n ^= S[512 | r >> 8 & 255];
        n += S[768 | r & 255];
        l ^= n ^ P[2];
        n = S[l >>> 24];
        n += S[256 | l >> 16 & 255];
        n ^= S[512 | l >> 8 & 255];
        n += S[768 | l & 255];
        r ^= n ^ P[3];
        n = S[r >>> 24];
        n += S[256 | r >> 16 & 255];
        n ^= S[512 | r >> 8 & 255];
        n += S[768 | r & 255];
        l ^= n ^ P[4];
        n = S[l >>> 24];
        n += S[256 | l >> 16 & 255];
        n ^= S[512 | l >> 8 & 255];
        n += S[768 | l & 255];
        r ^= n ^ P[5];
        n = S[r >>> 24];
        n += S[256 | r >> 16 & 255];
        n ^= S[512 | r >> 8 & 255];
        n += S[768 | r & 255];
        l ^= n ^ P[6];
        n = S[l >>> 24];
        n += S[256 | l >> 16 & 255];
        n ^= S[512 | l >> 8 & 255];
        n += S[768 | l & 255];
        r ^= n ^ P[7];
        n = S[r >>> 24];
        n += S[256 | r >> 16 & 255];
        n ^= S[512 | r >> 8 & 255];
        n += S[768 | r & 255];
        l ^= n ^ P[8];
        n = S[l >>> 24];
        n += S[256 | l >> 16 & 255];
        n ^= S[512 | l >> 8 & 255];
        n += S[768 | l & 255];
        r ^= n ^ P[9];
        n = S[r >>> 24];
        n += S[256 | r >> 16 & 255];
        n ^= S[512 | r >> 8 & 255];
        n += S[768 | r & 255];
        l ^= n ^ P[10];
        n = S[l >>> 24];
        n += S[256 | l >> 16 & 255];
        n ^= S[512 | l >> 8 & 255];
        n += S[768 | l & 255];
        r ^= n ^ P[11];
        n = S[r >>> 24];
        n += S[256 | r >> 16 & 255];
        n ^= S[512 | r >> 8 & 255];
        n += S[768 | r & 255];
        l ^= n ^ P[12];
        n = S[l >>> 24];
        n += S[256 | l >> 16 & 255];
        n ^= S[512 | l >> 8 & 255];
        n += S[768 | l & 255];
        r ^= n ^ P[13];
        n = S[r >>> 24];
        n += S[256 | r >> 16 & 255];
        n ^= S[512 | r >> 8 & 255];
        n += S[768 | r & 255];
        l ^= n ^ P[14];
        n = S[l >>> 24];
        n += S[256 | l >> 16 & 255];
        n ^= S[512 | l >> 8 & 255];
        n += S[768 | l & 255];
        r ^= n ^ P[15];
        n = S[r >>> 24];
        n += S[256 | r >> 16 & 255];
        n ^= S[512 | r >> 8 & 255];
        n += S[768 | r & 255];
        l ^= n ^ P[16];
        lr[off] = r ^ P[BLOWFISH_NUM_ROUNDS + 1];
        lr[off + 1] = l;
        return lr;
      }
      function _streamtoword(data, offp) {
        for (var i = 0, word = 0; i < 4; ++i)
          word = word << 8 | data[offp] & 255, offp = (offp + 1) % data.length;
        return { key: word, offp };
      }
      function _key(key, P, S) {
        var offset = 0, lr = [0, 0], plen = P.length, slen = S.length, sw;
        for (var i = 0; i < plen; i++)
          sw = _streamtoword(key, offset), offset = sw.offp, P[i] = P[i] ^ sw.key;
        for (i = 0; i < plen; i += 2)
          lr = _encipher(lr, 0, P, S), P[i] = lr[0], P[i + 1] = lr[1];
        for (i = 0; i < slen; i += 2)
          lr = _encipher(lr, 0, P, S), S[i] = lr[0], S[i + 1] = lr[1];
      }
      function _ekskey(data, key, P, S) {
        var offp = 0, lr = [0, 0], plen = P.length, slen = S.length, sw;
        for (var i = 0; i < plen; i++)
          sw = _streamtoword(key, offp), offp = sw.offp, P[i] = P[i] ^ sw.key;
        offp = 0;
        for (i = 0; i < plen; i += 2)
          sw = _streamtoword(data, offp), offp = sw.offp, lr[0] ^= sw.key, sw = _streamtoword(data, offp), offp = sw.offp, lr[1] ^= sw.key, lr = _encipher(lr, 0, P, S), P[i] = lr[0], P[i + 1] = lr[1];
        for (i = 0; i < slen; i += 2)
          sw = _streamtoword(data, offp), offp = sw.offp, lr[0] ^= sw.key, sw = _streamtoword(data, offp), offp = sw.offp, lr[1] ^= sw.key, lr = _encipher(lr, 0, P, S), S[i] = lr[0], S[i + 1] = lr[1];
      }
      function _crypt(b, salt, rounds, callback, progressCallback) {
        var cdata = C_ORIG.slice(), clen = cdata.length, err;
        if (rounds < 4 || rounds > 31) {
          err = Error("Illegal number of rounds (4-31): " + rounds);
          if (callback) {
            nextTick(callback.bind(this, err));
            return;
          } else
            throw err;
        }
        if (salt.length !== BCRYPT_SALT_LEN) {
          err = Error("Illegal salt length: " + salt.length + " != " + BCRYPT_SALT_LEN);
          if (callback) {
            nextTick(callback.bind(this, err));
            return;
          } else
            throw err;
        }
        rounds = 1 << rounds >>> 0;
        var P, S, i = 0, j;
        if (Int32Array) {
          P = new Int32Array(P_ORIG);
          S = new Int32Array(S_ORIG);
        } else {
          P = P_ORIG.slice();
          S = S_ORIG.slice();
        }
        _ekskey(salt, b, P, S);
        function next() {
          if (progressCallback)
            progressCallback(i / rounds);
          if (i < rounds) {
            var start = Date.now();
            for (; i < rounds; ) {
              i = i + 1;
              _key(b, P, S);
              _key(salt, P, S);
              if (Date.now() - start > MAX_EXECUTION_TIME)
                break;
            }
          } else {
            for (i = 0; i < 64; i++)
              for (j = 0; j < clen >> 1; j++)
                _encipher(cdata, j << 1, P, S);
            var ret = [];
            for (i = 0; i < clen; i++)
              ret.push((cdata[i] >> 24 & 255) >>> 0), ret.push((cdata[i] >> 16 & 255) >>> 0), ret.push((cdata[i] >> 8 & 255) >>> 0), ret.push((cdata[i] & 255) >>> 0);
            if (callback) {
              callback(null, ret);
              return;
            } else
              return ret;
          }
          if (callback)
            nextTick(next);
        }
        if (typeof callback !== "undefined") {
          next();
        } else {
          var res;
          while (true)
            if (typeof (res = next()) !== "undefined")
              return res || [];
        }
      }
      function _hash(s, salt, callback, progressCallback) {
        var err;
        if (typeof s !== "string" || typeof salt !== "string") {
          err = Error("Invalid string / salt: Not a string");
          if (callback) {
            nextTick(callback.bind(this, err));
            return;
          } else
            throw err;
        }
        var minor, offset;
        if (salt.charAt(0) !== "$" || salt.charAt(1) !== "2") {
          err = Error("Invalid salt version: " + salt.substring(0, 2));
          if (callback) {
            nextTick(callback.bind(this, err));
            return;
          } else
            throw err;
        }
        if (salt.charAt(2) === "$")
          minor = String.fromCharCode(0), offset = 3;
        else {
          minor = salt.charAt(2);
          if (minor !== "a" && minor !== "b" && minor !== "y" || salt.charAt(3) !== "$") {
            err = Error("Invalid salt revision: " + salt.substring(2, 4));
            if (callback) {
              nextTick(callback.bind(this, err));
              return;
            } else
              throw err;
          }
          offset = 4;
        }
        if (salt.charAt(offset + 2) > "$") {
          err = Error("Missing salt rounds");
          if (callback) {
            nextTick(callback.bind(this, err));
            return;
          } else
            throw err;
        }
        var r1 = parseInt(salt.substring(offset, offset + 1), 10) * 10, r2 = parseInt(salt.substring(offset + 1, offset + 2), 10), rounds = r1 + r2, real_salt = salt.substring(offset + 3, offset + 25);
        s += minor >= "a" ? "\0" : "";
        var passwordb = stringToBytes(s), saltb = base64_decode(real_salt, BCRYPT_SALT_LEN);
        function finish(bytes) {
          var res = [];
          res.push("$2");
          if (minor >= "a")
            res.push(minor);
          res.push("$");
          if (rounds < 10)
            res.push("0");
          res.push(rounds.toString());
          res.push("$");
          res.push(base64_encode(saltb, saltb.length));
          res.push(base64_encode(bytes, C_ORIG.length * 4 - 1));
          return res.join("");
        }
        if (typeof callback == "undefined")
          return finish(_crypt(passwordb, saltb, rounds));
        else {
          _crypt(passwordb, saltb, rounds, function(err2, bytes) {
            if (err2)
              callback(err2, null);
            else
              callback(null, finish(bytes));
          }, progressCallback);
        }
      }
      bcrypt3.encodeBase64 = base64_encode;
      bcrypt3.decodeBase64 = base64_decode;
      return bcrypt3;
    });
  }
});

// node_modules/bcryptjs/index.js
var require_bcryptjs = __commonJS({
  "node_modules/bcryptjs/index.js"(exports2, module2) {
    module2.exports = require_bcrypt();
  }
});

// electron/src/services/securityService.ts
var securityService_exports = {};
__export(securityService_exports, {
  clearLoginAttempts: () => clearLoginAttempts,
  clearSession: () => clearSession,
  getFailedAttemptCount: () => getFailedAttemptCount,
  getRemainingLockTime: () => getRemainingLockTime,
  getSecuritySettings: () => getSecuritySettings,
  getSessionInfo: () => getSessionInfo,
  isAccountLocked: () => isAccountLocked,
  isSessionValid: () => isSessionValid,
  recordLoginAttempt: () => recordLoginAttempt,
  shouldAutoLock: () => shouldAutoLock,
  trackSessionActivity: () => trackSessionActivity,
  updateSecuritySettings: () => updateSecuritySettings
});
function getSecuritySettings() {
  return { ...DEFAULT_SECURITY_SETTINGS };
}
async function updateSecuritySettings(settings) {
  const current = getSecuritySettings();
  const updated = { ...current, ...settings };
  return updated;
}
function trackSessionActivity(userId) {
  const existing = activeSessions.get(userId);
  if (existing) {
    existing.lastActivity = /* @__PURE__ */ new Date();
  } else {
    activeSessions.set(userId, {
      userId,
      lastActivity: /* @__PURE__ */ new Date(),
      loginTime: /* @__PURE__ */ new Date()
    });
  }
}
function isSessionValid(userId) {
  const session = activeSessions.get(userId);
  if (!session) {
    return false;
  }
  const settings = getSecuritySettings();
  const now = /* @__PURE__ */ new Date();
  const sessionAge = now.getTime() - session.loginTime.getTime();
  const idleTime = now.getTime() - session.lastActivity.getTime();
  if (sessionAge > settings.sessionTimeoutMinutes * 60 * 1e3) {
    activeSessions.delete(userId);
    return false;
  }
  if (settings.autoLockEnabled && idleTime > settings.autoLockTimeoutMinutes * 60 * 1e3) {
    activeSessions.delete(userId);
    return false;
  }
  return true;
}
function clearSession(userId) {
  activeSessions.delete(userId);
}
function recordLoginAttempt(email, success) {
  const key = email.toLowerCase();
  const now = /* @__PURE__ */ new Date();
  const existing = loginAttempts.get(key);
  if (success) {
    loginAttempts.delete(key);
    return;
  }
  if (!existing) {
    loginAttempts.set(key, {
      attempts: 1,
      firstAttempt: now
    });
    return;
  }
  const settings = getSecuritySettings();
  const windowMs = settings.loginAttemptWindowMinutes * 60 * 1e3;
  const timeSinceFirst = now.getTime() - existing.firstAttempt.getTime();
  if (timeSinceFirst > windowMs) {
    loginAttempts.set(key, {
      attempts: 1,
      firstAttempt: now
    });
    return;
  }
  existing.attempts += 1;
  if (existing.attempts >= settings.loginAttemptLimit) {
    existing.lockedUntil = new Date(now.getTime() + windowMs);
  }
  loginAttempts.set(key, existing);
}
function isAccountLocked(email) {
  const key = email.toLowerCase();
  const attempt = loginAttempts.get(key);
  if (!attempt) {
    return false;
  }
  const settings = getSecuritySettings();
  if (attempt.attempts < settings.loginAttemptLimit) {
    return false;
  }
  if (attempt.lockedUntil) {
    if (/* @__PURE__ */ new Date() < attempt.lockedUntil) {
      return true;
    } else {
      loginAttempts.delete(key);
      return false;
    }
  }
  return false;
}
function getRemainingLockTime(email) {
  const key = email.toLowerCase();
  const attempt = loginAttempts.get(key);
  if (!attempt || !attempt.lockedUntil) {
    return 0;
  }
  const remaining = attempt.lockedUntil.getTime() - (/* @__PURE__ */ new Date()).getTime();
  return Math.max(0, Math.floor(remaining / 1e3));
}
function getFailedAttemptCount(email) {
  const key = email.toLowerCase();
  const attempt = loginAttempts.get(key);
  if (!attempt) {
    return 0;
  }
  const settings = getSecuritySettings();
  const windowMs = settings.loginAttemptWindowMinutes * 60 * 1e3;
  const timeSinceFirst = (/* @__PURE__ */ new Date()).getTime() - attempt.firstAttempt.getTime();
  if (timeSinceFirst > windowMs) {
    loginAttempts.delete(key);
    return 0;
  }
  return attempt.attempts;
}
function clearLoginAttempts(email) {
  const key = email.toLowerCase();
  loginAttempts.delete(key);
}
function shouldAutoLock(userId) {
  const session = activeSessions.get(userId);
  if (!session) {
    return false;
  }
  const settings = getSecuritySettings();
  if (!settings.autoLockEnabled) {
    return false;
  }
  const now = /* @__PURE__ */ new Date();
  const idleTime = now.getTime() - session.lastActivity.getTime();
  return idleTime > settings.autoLockTimeoutMinutes * 60 * 1e3;
}
function getSessionInfo(userId) {
  const session = activeSessions.get(userId);
  if (!session) {
    return { isActive: false };
  }
  const now = /* @__PURE__ */ new Date();
  const idleMinutes = Math.floor((now.getTime() - session.lastActivity.getTime()) / (60 * 1e3));
  return {
    isActive: true,
    loginTime: session.loginTime,
    lastActivity: session.lastActivity,
    idleMinutes
  };
}
var DEFAULT_SECURITY_SETTINGS, activeSessions, loginAttempts;
var init_securityService = __esm({
  "electron/src/services/securityService.ts"() {
    "use strict";
    DEFAULT_SECURITY_SETTINGS = {
      dbEncryptionEnabled: false,
      autoLockEnabled: true,
      autoLockTimeoutMinutes: 15,
      sessionTimeoutMinutes: 480,
      // 8 hours
      loginAttemptLimit: 5,
      loginAttemptWindowMinutes: 15
    };
    activeSessions = /* @__PURE__ */ new Map();
    loginAttempts = /* @__PURE__ */ new Map();
  }
});

// electron/src/services/auditService.ts
var auditService_exports = {};
__export(auditService_exports, {
  logAudit: () => logAudit,
  logAuditAsync: () => logAuditAsync
});
var logAudit, logAuditAsync;
var init_auditService = __esm({
  "electron/src/services/auditService.ts"() {
    "use strict";
    init_prismaClient();
    logAudit = async ({
      entity,
      entityId,
      action,
      userId,
      details
    }) => {
      const prisma2 = getPrismaClient();
      try {
        await prisma2.auditLog.create({
          data: {
            entity,
            entityId,
            action,
            userId,
            details: details ? JSON.stringify(details) : void 0
          }
        });
      } catch (error) {
        console.error("Failed to log audit entry:", error);
      }
    };
    logAuditAsync = ({
      entity,
      entityId,
      action,
      userId,
      details
    }) => {
      logAudit({ entity, entityId, action, userId, details }).catch(() => {
      });
    };
  }
});

// electron/src/services/reportService.ts
var reportService_exports = {};
__export(reportService_exports, {
  getCustomerReport: () => getCustomerReport,
  getProfitLossReport: () => getProfitLossReport,
  getPurchaseReport: () => getPurchaseReport,
  getPurchaseVsSalesVariance: () => getPurchaseVsSalesVariance,
  getSalesReport: () => getSalesReport,
  getStockReport: () => getStockReport,
  getSupplierReport: () => getSupplierReport
});
async function getPurchaseVsSalesVariance(filters) {
  const prisma2 = getPrismaClient();
  const dateFilter = {};
  if (filters?.fromDate || filters?.toDate) {
    dateFilter.billDate = {};
    if (filters.fromDate) {
      dateFilter.billDate.gte = new Date(filters.fromDate);
    }
    if (filters.toDate) {
      const toDate = new Date(filters.toDate);
      toDate.setHours(23, 59, 59, 999);
      dateFilter.billDate.lte = toDate;
    }
  }
  const purchaseBills = await prisma2.bill.findMany({
    where: {
      billType: "PURCHASE",
      status: "FINALIZED",
      ...dateFilter,
      ...filters?.companyId && { supplierId: filters.companyId }
    },
    include: {
      lines: {
        where: filters?.productId ? { productId: filters.productId } : void 0,
        include: {
          product: {
            include: {
              company: true
            }
          }
        }
      }
    }
  });
  const salesBills = await prisma2.bill.findMany({
    where: {
      billType: "SALES",
      status: "FINALIZED",
      ...dateFilter
    },
    include: {
      lines: {
        where: filters?.productId ? { productId: filters.productId } : void 0,
        include: {
          product: {
            include: {
              company: true
            }
          }
        }
      }
    }
  });
  const productMap = /* @__PURE__ */ new Map();
  purchaseBills.forEach((bill) => {
    bill.lines.forEach((line) => {
      const existing = productMap.get(line.productId);
      if (existing) {
        existing.purchaseQuantity += line.quantity;
        existing.purchaseValue += Number(line.lineTotal);
      } else {
        productMap.set(line.productId, {
          productId: line.productId,
          productName: line.productName,
          purchaseQuantity: line.quantity,
          purchaseValue: Number(line.lineTotal),
          salesQuantity: 0,
          salesValue: 0
        });
      }
    });
  });
  salesBills.forEach((bill) => {
    bill.lines.forEach((line) => {
      const existing = productMap.get(line.productId);
      if (existing) {
        existing.salesQuantity += line.quantity;
        existing.salesValue += Number(line.lineTotal);
      } else {
        productMap.set(line.productId, {
          productId: line.productId,
          productName: line.productName,
          purchaseQuantity: 0,
          purchaseValue: 0,
          salesQuantity: line.quantity,
          salesValue: Number(line.lineTotal)
        });
      }
    });
  });
  const byProduct = Array.from(productMap.values()).map((data) => {
    const variance2 = data.salesValue - data.purchaseValue;
    const variancePercent2 = data.purchaseValue > 0 ? variance2 / data.purchaseValue * 100 : 0;
    return {
      ...data,
      variance: variance2,
      variancePercent: variancePercent2
    };
  }).sort((a, b) => Math.abs(b.variance) - Math.abs(a.variance));
  const companyMap = /* @__PURE__ */ new Map();
  purchaseBills.forEach((bill) => {
    bill.lines.forEach((line) => {
      const companyId = line.product.companyId;
      if (!companyId) return;
      const existing = companyMap.get(companyId);
      if (existing) {
        existing.purchaseValue += Number(line.lineTotal);
      } else {
        companyMap.set(companyId, {
          companyId,
          companyName: line.product.company?.name || `Company ${companyId}`,
          purchaseValue: Number(line.lineTotal),
          salesValue: 0
        });
      }
    });
  });
  salesBills.forEach((bill) => {
    bill.lines.forEach((line) => {
      const companyId = line.product.companyId;
      if (!companyId) return;
      const existing = companyMap.get(companyId);
      if (existing) {
        existing.salesValue += Number(line.lineTotal);
      } else {
        companyMap.set(companyId, {
          companyId,
          companyName: line.product.company?.name || `Company ${companyId}`,
          purchaseValue: 0,
          salesValue: Number(line.lineTotal)
        });
      }
    });
  });
  const byCompany = Array.from(companyMap.values()).map((data) => {
    const variance2 = data.salesValue - data.purchaseValue;
    const variancePercent2 = data.purchaseValue > 0 ? variance2 / data.purchaseValue * 100 : 0;
    return {
      ...data,
      variance: variance2,
      variancePercent: variancePercent2
    };
  }).sort((a, b) => Math.abs(b.variance) - Math.abs(a.variance));
  const totalPurchaseValue = byProduct.reduce((sum, p) => sum + p.purchaseValue, 0);
  const totalSalesValue = byProduct.reduce((sum, p) => sum + p.salesValue, 0);
  const variance = totalSalesValue - totalPurchaseValue;
  const variancePercent = totalPurchaseValue > 0 ? variance / totalPurchaseValue * 100 : 0;
  return {
    summary: {
      totalPurchaseValue,
      totalSalesValue,
      variance,
      variancePercent
    },
    byProduct,
    byCompany
  };
}
var import_client3, getSalesReport, getPurchaseReport, getProfitLossReport, getStockReport, getCustomerReport, getSupplierReport;
var init_reportService = __esm({
  "electron/src/services/reportService.ts"() {
    "use strict";
    import_client3 = require("@prisma/client");
    init_prismaClient();
    getSalesReport = async (range) => {
      const prisma2 = getPrismaClient();
      const fromDate = new Date(range.fromDate);
      const toDate = new Date(range.toDate);
      toDate.setHours(23, 59, 59, 999);
      const invoices = await prisma2.salesInvoice.findMany({
        where: {
          invoiceDate: {
            gte: fromDate,
            lte: toDate
          }
        },
        include: {
          customer: true,
          items: {
            include: {
              product: true
            }
          }
        }
      });
      let totalAmount = 0;
      let totalTax = 0;
      let totalDiscount = 0;
      const customerMap = /* @__PURE__ */ new Map();
      const productMap = /* @__PURE__ */ new Map();
      invoices.forEach((invoice) => {
        const invoiceTotal = Number(invoice.totalAmount);
        const invoiceTax = Number(invoice.totalTax);
        totalAmount += invoiceTotal;
        totalTax += invoiceTax;
        const customerId = invoice.customerId;
        const customerName = invoice.customer.name;
        const existing = customerMap.get(customerId);
        if (existing) {
          existing.count += 1;
          existing.amount += invoiceTotal;
        } else {
          customerMap.set(customerId, {
            name: customerName,
            count: 1,
            amount: invoiceTotal
          });
        }
        invoice.items.forEach((item) => {
          const productId = item.productId;
          const productName = item.product.name;
          const quantity = item.quantity;
          const lineTotal = Number(item.lineTotal);
          const discount = Number(item.discountPercent || 0);
          totalDiscount += lineTotal * discount / 100;
          const existing2 = productMap.get(productId);
          if (existing2) {
            existing2.quantity += quantity;
            existing2.amount += lineTotal;
          } else {
            productMap.set(productId, {
              name: productName,
              quantity,
              amount: lineTotal
            });
          }
        });
      });
      return {
        totalInvoices: invoices.length,
        totalAmount,
        totalTax,
        totalDiscount,
        netAmount: totalAmount - totalDiscount,
        byCustomer: Array.from(customerMap.entries()).map(([id, data]) => ({
          customerId: id,
          customerName: data.name,
          invoiceCount: data.count,
          totalAmount: data.amount
        })).sort((a, b) => b.totalAmount - a.totalAmount),
        byProduct: Array.from(productMap.entries()).map(([id, data]) => ({
          productId: id,
          productName: data.name,
          quantity: data.quantity,
          totalAmount: data.amount
        })).sort((a, b) => b.totalAmount - a.totalAmount)
      };
    };
    getPurchaseReport = async (range) => {
      const prisma2 = getPrismaClient();
      const fromDate = new Date(range.fromDate);
      const toDate = new Date(range.toDate);
      toDate.setHours(23, 59, 59, 999);
      const invoices = await prisma2.purchaseInvoice.findMany({
        where: {
          invoiceDate: {
            gte: fromDate,
            lte: toDate
          }
        },
        include: {
          supplier: true,
          items: {
            include: {
              product: true
            }
          }
        }
      });
      let totalAmount = 0;
      let totalTax = 0;
      const supplierMap = /* @__PURE__ */ new Map();
      const productMap = /* @__PURE__ */ new Map();
      invoices.forEach((invoice) => {
        const invoiceTotal = Number(invoice.totalAmount);
        const invoiceTax = Number(invoice.totalTax);
        totalAmount += invoiceTotal;
        totalTax += invoiceTax;
        const supplierId = invoice.supplierId;
        if (supplierId) {
          const supplierName = invoice.supplier?.name ?? invoice.supplierName;
          const existing = supplierMap.get(supplierId);
          if (existing) {
            existing.count += 1;
            existing.amount += invoiceTotal;
          } else {
            supplierMap.set(supplierId, {
              name: supplierName,
              count: 1,
              amount: invoiceTotal
            });
          }
        }
        invoice.items.forEach((item) => {
          const productId = item.productId;
          const productName = item.product.name;
          const quantity = item.quantity;
          const lineTotal = Number(item.lineTotal);
          const existing = productMap.get(productId);
          if (existing) {
            existing.quantity += quantity;
            existing.amount += lineTotal;
          } else {
            productMap.set(productId, {
              name: productName,
              quantity,
              amount: lineTotal
            });
          }
        });
      });
      return {
        totalInvoices: invoices.length,
        totalAmount,
        totalTax,
        netAmount: totalAmount,
        bySupplier: Array.from(supplierMap.entries()).map(([id, data]) => ({
          supplierId: id,
          supplierName: data.name,
          invoiceCount: data.count,
          totalAmount: data.amount
        })).sort((a, b) => b.totalAmount - a.totalAmount),
        byProduct: Array.from(productMap.entries()).map(([id, data]) => ({
          productId: id,
          productName: data.name,
          quantity: data.quantity,
          totalAmount: data.amount
        })).sort((a, b) => b.totalAmount - a.totalAmount)
      };
    };
    getProfitLossReport = async (range) => {
      const prisma2 = getPrismaClient();
      const fromDate = new Date(range.fromDate);
      const toDate = new Date(range.toDate);
      toDate.setHours(23, 59, 59, 999);
      const [salesInvoices, purchaseInvoices] = await Promise.all([
        prisma2.salesInvoice.findMany({
          where: {
            invoiceDate: {
              gte: fromDate,
              lte: toDate
            }
          },
          select: {
            totalAmount: true
          }
        }),
        prisma2.purchaseInvoice.findMany({
          where: {
            invoiceDate: {
              gte: fromDate,
              lte: toDate
            }
          },
          select: {
            totalAmount: true
          }
        })
      ]);
      const totalSales = salesInvoices.reduce(
        (sum, inv) => sum + Number(inv.totalAmount),
        0
      );
      const totalPurchases = purchaseInvoices.reduce(
        (sum, inv) => sum + Number(inv.totalAmount),
        0
      );
      const grossProfit = totalSales - totalPurchases;
      const grossProfitMargin = totalSales > 0 ? grossProfit / totalSales * 100 : 0;
      return {
        totalSales,
        totalPurchases,
        grossProfit,
        grossProfitMargin,
        period: {
          fromDate: range.fromDate,
          toDate: range.toDate
        }
      };
    };
    getStockReport = async () => {
      const prisma2 = getPrismaClient();
      const now = /* @__PURE__ */ new Date();
      const thirtyDaysFromNow = new Date(now);
      thirtyDaysFromNow.setDate(thirtyDaysFromNow.getDate() + 30);
      const products = await prisma2.product.findMany({
        include: {
          batches: {
            include: {
              godown: true
            }
          }
        }
      });
      let totalValue = 0;
      let lowStockCount = 0;
      let expiredBatchesCount = 0;
      let nearExpiryBatchesCount = 0;
      const byProduct = products.map((product) => {
        const batches = product.batches.map((batch) => {
          const expiryDate = new Date(batch.expiryDate);
          const daysUntilExpiry = Math.ceil((expiryDate.getTime() - now.getTime()) / (1e3 * 60 * 60 * 24));
          if (daysUntilExpiry < 0) {
            expiredBatchesCount++;
          } else if (daysUntilExpiry <= 30) {
            nearExpiryBatchesCount++;
          }
          return {
            batchId: batch.id,
            batchNumber: batch.batchNumber,
            expiryDate: batch.expiryDate.toISOString(),
            quantity: batch.quantity,
            godownName: batch.godown?.name,
            daysUntilExpiry
          };
        });
        const totalQuantity = batches.reduce((sum, b) => sum + b.quantity, 0);
        const productValue = product.batches.reduce((sum, b) => sum + b.quantity * Number(b.mrp), 0);
        totalValue += productValue;
        if (totalQuantity < product.minStock) {
          lowStockCount++;
        }
        return {
          productId: product.id,
          productName: product.name,
          sku: product.sku,
          totalQuantity,
          totalValue: productValue,
          batches
        };
      });
      const godownMap = /* @__PURE__ */ new Map();
      godownMap.set(null, { name: "No Godown", value: 0, products: /* @__PURE__ */ new Set() });
      products.forEach((product) => {
        product.batches.forEach((batch) => {
          const godownId = batch.godownId;
          const godownName = batch.godown?.name ?? "No Godown";
          const batchValue = batch.quantity * Number(batch.mrp);
          if (!godownMap.has(godownId)) {
            godownMap.set(godownId, { name: godownName, value: 0, products: /* @__PURE__ */ new Set() });
          }
          const godown = godownMap.get(godownId);
          godown.value += batchValue;
          godown.products.add(product.id);
        });
      });
      const byGodown = Array.from(godownMap.entries()).map(([id, data]) => ({
        godownId: id,
        godownName: data.name,
        totalValue: data.value,
        productCount: data.products.size
      }));
      return {
        totalProducts: products.length,
        totalValue,
        lowStockCount,
        expiredBatchesCount,
        nearExpiryBatchesCount,
        byProduct,
        byGodown
      };
    };
    getCustomerReport = async () => {
      const prisma2 = getPrismaClient();
      const customers = await prisma2.customer.findMany({
        include: {
          salesInvoices: {
            include: {
              payments: true
            }
          }
        }
      });
      let totalOutstanding = 0;
      const topCustomers = customers.map((customer) => {
        const totalSales = customer.salesInvoices.reduce(
          (sum, inv) => sum + Number(inv.totalAmount),
          0
        );
        const totalPaid = customer.salesInvoices.reduce(
          (sum, inv) => sum + Number(inv.paidAmount ?? 0),
          0
        );
        const outstanding = totalSales - totalPaid;
        totalOutstanding += outstanding;
        return {
          customerId: customer.id,
          customerName: customer.name,
          totalSales,
          totalPaid,
          outstanding,
          invoiceCount: customer.salesInvoices.length
        };
      }).sort((a, b) => b.totalSales - a.totalSales);
      return {
        totalCustomers: customers.length,
        totalOutstanding,
        topCustomers
      };
    };
    getSupplierReport = async () => {
      const prisma2 = getPrismaClient();
      const suppliers = await prisma2.supplier.findMany({
        include: {
          purchaseInvoices: {
            include: {
              payments: true
            }
          }
        }
      });
      let totalOutstanding = 0;
      const topSuppliers = suppliers.map((supplier) => {
        const totalPurchases = supplier.purchaseInvoices.reduce(
          (sum, inv) => sum + Number(inv.totalAmount),
          0
        );
        const totalPaid = supplier.purchaseInvoices.reduce(
          (sum, inv) => sum + Number(inv.paidAmount ?? 0),
          0
        );
        const outstanding = totalPurchases - totalPaid;
        totalOutstanding += outstanding;
        return {
          supplierId: supplier.id,
          supplierName: supplier.name,
          totalPurchases,
          totalPaid,
          outstanding,
          invoiceCount: supplier.purchaseInvoices.length
        };
      }).sort((a, b) => b.totalPurchases - a.totalPurchases);
      return {
        totalSuppliers: suppliers.length,
        totalOutstanding,
        topSuppliers
      };
    };
  }
});

// electron/src/services/backupService.ts
async function calculateChecksum(filePath) {
  const fileBuffer = await import_node_fs2.default.promises.readFile(filePath);
  return import_node_crypto.default.createHash("sha256").update(fileBuffer).digest("hex");
}
async function verifyBackupIntegrity(backupFile) {
  try {
    if (!import_node_fs2.default.existsSync(backupFile)) {
      return { valid: false, error: "Backup file does not exist" };
    }
    const stats = await import_node_fs2.default.promises.stat(backupFile);
    if (stats.size < 1024) {
      return { valid: false, error: "Backup file is too small to be valid" };
    }
    const fileHandle = await import_node_fs2.default.promises.open(backupFile, "r");
    const buffer = Buffer.alloc(16);
    await fileHandle.read(buffer, 0, 16, 0);
    await fileHandle.close();
    const sqliteHeader = "SQLite format 3\0";
    if (buffer.toString("utf8", 0, 16) !== sqliteHeader) {
      return { valid: false, error: "Invalid SQLite file format" };
    }
    const metadataFile = backupFile.replace(BACKUP_EXT, METADATA_EXT);
    if (import_node_fs2.default.existsSync(metadataFile)) {
      const metadata = JSON.parse(
        await import_node_fs2.default.promises.readFile(metadataFile, "utf-8")
      );
      const actualChecksum = await calculateChecksum(backupFile);
      if (actualChecksum !== metadata.checksum) {
        return { valid: false, error: "Checksum mismatch - file may be corrupted" };
      }
    }
    return { valid: true };
  } catch (error) {
    return {
      valid: false,
      error: error instanceof Error ? error.message : "Unknown error during verification"
    };
  }
}
async function createBackup() {
  try {
    const databasePath = getDatabasePath();
    if (!import_node_fs2.default.existsSync(databasePath)) {
      return { success: false, error: "Database file does not exist" };
    }
    const sourceCheck = await verifyBackupIntegrity(databasePath);
    if (!sourceCheck.valid) {
      return { success: false, error: `Source database invalid: ${sourceCheck.error}` };
    }
    const timestamp = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-");
    const backupDir = getBackupDir();
    const backupFile = import_node_path3.default.join(backupDir, `${BACKUP_PREFIX}${timestamp}${BACKUP_EXT}`);
    const metadataFile = import_node_path3.default.join(backupDir, `${BACKUP_PREFIX}${timestamp}${METADATA_EXT}`);
    await import_node_fs2.default.promises.copyFile(databasePath, backupFile);
    const checksum = await calculateChecksum(backupFile);
    const stats = await import_node_fs2.default.promises.stat(backupFile);
    const metadata = {
      timestamp,
      fileSize: stats.size,
      checksum,
      version: "1.0",
      // Can be enhanced to track app version
      createdAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    await import_node_fs2.default.promises.writeFile(metadataFile, JSON.stringify(metadata, null, 2));
    const verifyResult = await verifyBackupIntegrity(backupFile);
    if (!verifyResult.valid) {
      await import_node_fs2.default.promises.unlink(backupFile).catch(() => {
      });
      await import_node_fs2.default.promises.unlink(metadataFile).catch(() => {
      });
      return { success: false, error: `Backup verification failed: ${verifyResult.error}` };
    }
    await cleanupOldBackups();
    return { success: true, filePath: backupFile };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : "Unknown error during backup"
    };
  }
}
async function cleanupOldBackups() {
  try {
    const backupDir = getBackupDir();
    const files = await import_node_fs2.default.promises.readdir(backupDir);
    const now = Date.now();
    const retentionMs = BACKUP_RETENTION_DAYS * 24 * 60 * 60 * 1e3;
    for (const file of files) {
      if (file.startsWith(BACKUP_PREFIX) && file.endsWith(BACKUP_EXT)) {
        const filePath = import_node_path3.default.join(backupDir, file);
        try {
          const stats = await import_node_fs2.default.promises.stat(filePath);
          const age = now - stats.mtimeMs;
          if (age > retentionMs) {
            await import_node_fs2.default.promises.unlink(filePath).catch(() => {
            });
            const metadataFile = filePath.replace(BACKUP_EXT, METADATA_EXT);
            await import_node_fs2.default.promises.unlink(metadataFile).catch(() => {
            });
          }
        } catch (err) {
          console.warn(`Failed to process backup file ${file}:`, err);
        }
      }
    }
  } catch (error) {
    console.warn("Error during backup cleanup:", error);
  }
}
async function listBackups() {
  try {
    const backupDir = getBackupDir();
    const files = await import_node_fs2.default.promises.readdir(backupDir);
    const backups = [];
    for (const file of files) {
      if (file.startsWith(BACKUP_PREFIX) && file.endsWith(BACKUP_EXT)) {
        const filePath = import_node_path3.default.join(backupDir, file);
        try {
          const stats = await import_node_fs2.default.promises.stat(filePath);
          const metadataFile = filePath.replace(BACKUP_EXT, METADATA_EXT);
          let metadata = null;
          if (import_node_fs2.default.existsSync(metadataFile)) {
            metadata = JSON.parse(await import_node_fs2.default.promises.readFile(metadataFile, "utf-8"));
          }
          const verifyResult = await verifyBackupIntegrity(filePath);
          backups.push({
            filePath,
            timestamp: metadata?.timestamp || import_node_path3.default.basename(file, BACKUP_EXT),
            fileSize: stats.size,
            createdAt: metadata?.createdAt || stats.mtime.toISOString(),
            isValid: verifyResult.valid
          });
        } catch (err) {
          console.warn(`Failed to process backup ${file}:`, err);
        }
      }
    }
    return backups.sort(
      (a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
    );
  } catch (error) {
    console.error("Error listing backups:", error);
    return [];
  }
}
async function restoreBackup(backupFile, options = {}) {
  const { validateBeforeRestore = true } = options;
  try {
    if (validateBeforeRestore) {
      const verifyResult = await verifyBackupIntegrity(backupFile);
      if (!verifyResult.valid) {
        return { success: false, error: `Backup validation failed: ${verifyResult.error}` };
      }
    }
    const databasePath = getDatabasePath();
    const safetyBackup = await createBackup();
    if (!safetyBackup.success) {
      return { success: false, error: `Failed to create safety backup: ${safetyBackup.error}` };
    }
    await import_node_fs2.default.promises.copyFile(backupFile, databasePath);
    const restoreVerify = await verifyBackupIntegrity(databasePath);
    if (!restoreVerify.valid) {
      if (safetyBackup.filePath) {
        await import_node_fs2.default.promises.copyFile(safetyBackup.filePath, databasePath).catch(() => {
        });
      }
      return { success: false, error: `Restored database validation failed: ${restoreVerify.error}` };
    }
    return { success: true };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : "Unknown error during restore"
    };
  }
}
var import_node_fs2, import_node_path3, import_node_crypto, getDatabasePath, getBackupDir, BACKUP_RETENTION_DAYS, BACKUP_PREFIX, BACKUP_EXT, METADATA_EXT, exportBackup, importBackup;
var init_backupService = __esm({
  "electron/src/services/backupService.ts"() {
    "use strict";
    import_node_fs2 = __toESM(require("node:fs"));
    import_node_path3 = __toESM(require("node:path"));
    import_node_crypto = __toESM(require("node:crypto"));
    init_constants();
    getDatabasePath = () => paths.database();
    getBackupDir = () => {
      const backupDir = paths.backups();
      if (!import_node_fs2.default.existsSync(backupDir)) {
        import_node_fs2.default.mkdirSync(backupDir, { recursive: true });
      }
      return backupDir;
    };
    BACKUP_RETENTION_DAYS = 30;
    BACKUP_PREFIX = "backup-";
    BACKUP_EXT = ".db";
    METADATA_EXT = ".json";
    exportBackup = createBackup;
    importBackup = async (sourceFile) => {
      const result = await restoreBackup(sourceFile);
      if (!result.success) {
        throw new Error(result.error || "Restore failed");
      }
    };
  }
});

// electron/src/services/companyInfoService.ts
var mapCompanyInfo, getCompanyInfo, saveCompanyInfo;
var init_companyInfoService = __esm({
  "electron/src/services/companyInfoService.ts"() {
    "use strict";
    init_prismaClient();
    mapCompanyInfo = (info) => ({
      id: info.id,
      companyName: info.companyName,
      address: info.address ?? void 0,
      phone: info.phone ?? void 0,
      email: info.email ?? void 0,
      gstNumber: info.gstNumber ?? void 0,
      dlNumber1: info.dlNumber1 ?? void 0,
      dlNumber2: info.dlNumber2 ?? void 0,
      fssaiNumber: info.fssaiNumber ?? void 0,
      cinPan: info.cinPan ?? void 0,
      logoPath: info.logoPath ?? void 0,
      signPath: info.signPath ?? void 0,
      state: info.state ?? void 0,
      stateCode: info.stateCode ?? void 0,
      createdAt: info.createdAt.toISOString(),
      updatedAt: info.updatedAt.toISOString()
    });
    getCompanyInfo = async () => {
      const prisma2 = getPrismaClient();
      const info = await prisma2.companyInfo.findFirst({
        orderBy: { updatedAt: "desc" }
      });
      if (!info) {
        return null;
      }
      return mapCompanyInfo(info);
    };
    saveCompanyInfo = async (payload) => {
      if (!payload.companyName || payload.companyName.trim() === "") {
        throw new Error("Company name is required");
      }
      const prisma2 = getPrismaClient();
      const toNull = (value) => value && value.trim() !== "" ? value.trim() : null;
      const existing = await prisma2.companyInfo.findFirst({
        orderBy: { updatedAt: "desc" }
      });
      if (existing) {
        const updated = await prisma2.companyInfo.update({
          where: { id: existing.id },
          data: {
            companyName: payload.companyName.trim(),
            address: toNull(payload.address),
            phone: toNull(payload.phone),
            email: toNull(payload.email),
            gstNumber: toNull(payload.gstNumber),
            dlNumber1: toNull(payload.dlNumber1),
            dlNumber2: toNull(payload.dlNumber2),
            fssaiNumber: toNull(payload.fssaiNumber),
            cinPan: toNull(payload.cinPan),
            logoPath: toNull(payload.logoPath),
            signPath: toNull(payload.signPath),
            state: toNull(payload.state),
            stateCode: toNull(payload.stateCode)
          }
        });
        return mapCompanyInfo(updated);
      } else {
        const created = await prisma2.companyInfo.create({
          data: {
            companyName: payload.companyName.trim(),
            address: toNull(payload.address),
            phone: toNull(payload.phone),
            email: toNull(payload.email),
            gstNumber: toNull(payload.gstNumber),
            dlNumber1: toNull(payload.dlNumber1),
            dlNumber2: toNull(payload.dlNumber2),
            fssaiNumber: toNull(payload.fssaiNumber),
            cinPan: toNull(payload.cinPan),
            logoPath: toNull(payload.logoPath),
            signPath: toNull(payload.signPath),
            state: toNull(payload.state),
            stateCode: toNull(payload.stateCode)
          }
        });
        return mapCompanyInfo(created);
      }
    };
  }
});

// electron/src/services/stockLedgerService.ts
var stockLedgerService_exports = {};
__export(stockLedgerService_exports, {
  createLedgerEntry: () => createLedgerEntry,
  getProductStockBalance: () => getProductStockBalance,
  getProductStockBalanceFromLedger: () => getProductStockBalanceFromLedger,
  reconcileAllBatches: () => reconcileAllBatches,
  reconcileBatchQuantity: () => reconcileBatchQuantity,
  scanStockConsistency: () => scanStockConsistency,
  validateBatchConsistency: () => validateBatchConsistency
});
async function createLedgerEntry(params) {
  const {
    productId,
    batchId,
    godownId,
    movementType,
    reference,
    quantityChange,
    narration,
    tx
  } = params;
  if (!tx) {
    const prisma2 = getPrismaClient();
    return prisma2.$transaction(async (transactionClient) => {
      return createLedgerEntryInternal({ ...params, tx: transactionClient });
    });
  }
  return createLedgerEntryInternal(params);
}
async function createLedgerEntryInternal(params) {
  const {
    productId,
    batchId,
    godownId,
    movementType,
    reference,
    quantityChange,
    narration,
    tx
  } = params;
  const prisma2 = tx || getPrismaClient();
  let currentBatchQuantity = 0;
  if (batchId) {
    const batch = await prisma2.batch.findUnique({
      where: { id: batchId },
      select: { quantity: true, productId: true }
    });
    if (!batch) {
      throw new Error(`Batch ${batchId} not found`);
    }
    if (batch.productId !== productId) {
      throw new Error(`Batch ${batchId} does not belong to product ${productId}`);
    }
    currentBatchQuantity = batch.quantity;
  }
  const ledgerEntries = batchId ? await prisma2.stockLedger.findMany({
    where: { productId, batchId },
    orderBy: { createdAt: "asc" }
  }) : [];
  const ledgerBalance = ledgerEntries.reduce(
    (sum, entry) => sum + entry.quantityChange,
    0
  );
  const baseBalance = Math.abs(ledgerBalance - currentBatchQuantity) < 1 ? ledgerBalance : currentBatchQuantity;
  const newBalance = baseBalance + quantityChange;
  if (newBalance < 0 && movementType !== "ADJUSTMENT") {
    throw new Error(
      `Insufficient stock. Current: ${baseBalance}, Required: ${Math.abs(quantityChange)}`
    );
  }
  const ledgerEntry = await prisma2.stockLedger.create({
    data: {
      productId,
      batchId,
      godownId,
      movementType,
      reference,
      quantityChange,
      balanceAfter: newBalance,
      narration: narration || `${movementType} - ${reference}`
    }
  });
  if (batchId) {
    await prisma2.batch.update({
      where: { id: batchId },
      data: { quantity: newBalance }
    });
  }
  return {
    ledgerId: ledgerEntry.id,
    newBatchQuantity: newBalance
  };
}
async function reconcileBatchQuantity(batchId, tx) {
  const prisma2 = tx || getPrismaClient();
  const batch = await prisma2.batch.findUnique({
    where: { id: batchId },
    select: { quantity: true, productId: true }
  });
  if (!batch) {
    throw new Error(`Batch ${batchId} not found`);
  }
  const ledgerEntries = await prisma2.stockLedger.findMany({
    where: {
      productId: batch.productId,
      batchId
    },
    orderBy: { createdAt: "asc" }
  });
  const calculatedQuantity = ledgerEntries.reduce(
    (sum, entry) => sum + entry.quantityChange,
    0
  );
  const oldQuantity = batch.quantity;
  const reconciled = oldQuantity !== calculatedQuantity;
  if (reconciled) {
    await prisma2.batch.update({
      where: { id: batchId },
      data: { quantity: calculatedQuantity }
    });
  }
  return {
    oldQuantity,
    newQuantity: calculatedQuantity,
    reconciled
  };
}
async function validateBatchConsistency(batchId, tx) {
  const prisma2 = tx || getPrismaClient();
  const batch = await prisma2.batch.findUnique({
    where: { id: batchId },
    select: { quantity: true, productId: true }
  });
  if (!batch) {
    throw new Error(`Batch ${batchId} not found`);
  }
  const ledgerEntries = await prisma2.stockLedger.findMany({
    where: {
      productId: batch.productId,
      batchId
    },
    orderBy: { createdAt: "asc" }
  });
  const ledgerQuantity = ledgerEntries.reduce(
    (sum, entry) => sum + entry.quantityChange,
    0
  );
  const difference = batch.quantity - ledgerQuantity;
  return {
    consistent: Math.abs(difference) < 0.01,
    // Allow for floating point errors
    batchQuantity: batch.quantity,
    ledgerQuantity,
    difference
  };
}
async function getProductStockBalance(productId, godownId, tx) {
  const prisma2 = tx || getPrismaClient();
  const batches = await prisma2.batch.findMany({
    where: {
      productId,
      ...godownId && { godownId }
    },
    select: { quantity: true }
  });
  return batches.reduce((sum, batch) => sum + batch.quantity, 0);
}
async function getProductStockBalanceFromLedger(productId, batchId, godownId, tx) {
  const prisma2 = tx || getPrismaClient();
  const ledgerEntries = await prisma2.stockLedger.findMany({
    where: {
      productId,
      ...batchId && { batchId },
      ...godownId && { godownId }
    },
    orderBy: { createdAt: "asc" }
  });
  return ledgerEntries.reduce((sum, entry) => sum + entry.quantityChange, 0);
}
async function scanStockConsistency() {
  const prisma2 = getPrismaClient();
  const issues = [];
  const batches = await prisma2.batch.findMany({
    include: {
      product: {
        select: { name: true }
      }
    }
  });
  for (const batch of batches) {
    const validation = await validateBatchConsistency(batch.id);
    if (!validation.consistent) {
      issues.push({
        batchId: batch.id,
        productId: batch.productId,
        batchNumber: batch.batchNumber,
        batchQuantity: validation.batchQuantity,
        ledgerQuantity: validation.ledgerQuantity,
        difference: validation.difference,
        consistent: false
      });
    }
  }
  return issues;
}
async function reconcileAllBatches() {
  const prisma2 = getPrismaClient();
  const errors = [];
  let reconciled = 0;
  const issues = await scanStockConsistency();
  for (const issue of issues) {
    try {
      const result = await reconcileBatchQuantity(issue.batchId);
      if (result.reconciled) {
        reconciled++;
      }
    } catch (error) {
      errors.push(
        `Failed to reconcile batch ${issue.batchNumber}: ${error instanceof Error ? error.message : "Unknown error"}`
      );
    }
  }
  return {
    totalBatches: issues.length,
    reconciled,
    errors
  };
}
var init_stockLedgerService = __esm({
  "electron/src/services/stockLedgerService.ts"() {
    "use strict";
    init_prismaClient();
  }
});

// electron/src/services/safeDeleteService.ts
var safeDeleteService_exports = {};
__export(safeDeleteService_exports, {
  safeDeleteBill: () => safeDeleteBill,
  safeDeleteProduct: () => safeDeleteProduct,
  safeDeletePurchaseInvoice: () => safeDeletePurchaseInvoice,
  safeDeleteSalesInvoice: () => safeDeleteSalesInvoice
});
var safeDeleteProduct, safeDeleteSalesInvoice, safeDeletePurchaseInvoice, safeDeleteBill;
var init_safeDeleteService = __esm({
  "electron/src/services/safeDeleteService.ts"() {
    "use strict";
    init_prismaClient();
    init_auditService();
    init_logger();
    safeDeleteProduct = async (productId, options) => {
      const prisma2 = getPrismaClient();
      return prisma2.$transaction(async (tx) => {
        const product = await tx.product.findUnique({
          where: { id: productId },
          include: {
            batches: {
              where: { quantity: { gt: 0 } }
            },
            purchaseItems: { take: 1 },
            salesItems: { take: 1 },
            billLines: { take: 1 }
          }
        });
        if (!product) {
          throw new Error("Product not found");
        }
        if (product.deletedAt) {
          throw new Error("Product is already deleted");
        }
        if (product.batches.length > 0) {
          throw new Error("Cannot delete product with active stock. Please clear stock first.");
        }
        if (product.purchaseItems.length > 0 || product.salesItems.length > 0 || product.billLines.length > 0) {
          throw new Error("Cannot delete product that has been used in invoices or bills.");
        }
        await tx.product.update({
          where: { id: productId },
          data: {
            deletedAt: /* @__PURE__ */ new Date(),
            deletedBy: options.userId
          }
        });
        logAuditAsync({
          entity: "Product",
          entityId: productId,
          action: "DELETE",
          userId: options.userId,
          details: {
            sku: product.sku,
            name: product.name,
            reason: options.reason
          }
        });
        logger.info(`Product ${productId} soft deleted by user ${options.userId}`);
      });
    };
    safeDeleteSalesInvoice = async (invoiceId, options) => {
      const prisma2 = getPrismaClient();
      return prisma2.$transaction(async (tx) => {
        const invoice = await tx.salesInvoice.findUnique({
          where: { id: invoiceId },
          include: {
            items: {
              include: {
                batch: true,
                product: true
              }
            }
          }
        });
        if (!invoice) {
          throw new Error("Sales invoice not found");
        }
        if (invoice.deletedAt) {
          throw new Error("Sales invoice is already deleted");
        }
        if (invoice.status === "FINALIZED" && !options.force) {
          throw new Error("Cannot delete finalized invoice. Only ADMIN can force delete finalized invoices.");
        }
        const { createLedgerEntry: createLedgerEntry2 } = await Promise.resolve().then(() => (init_stockLedgerService(), stockLedgerService_exports));
        if (invoice.status === "FINALIZED") {
          for (const item of invoice.items) {
            if (item.batchId && item.batch) {
              await createLedgerEntry2({
                productId: item.productId,
                batchId: item.batchId,
                movementType: "RETURN",
                reference: `DELETE-${invoice.invoiceNumber}`,
                quantityChange: item.quantity,
                narration: `Stock restored due to invoice deletion: ${invoice.invoiceNumber}`,
                tx
              });
            }
          }
        }
        await tx.salesInvoice.update({
          where: { id: invoiceId },
          data: {
            deletedAt: /* @__PURE__ */ new Date(),
            deletedBy: options.userId
          }
        });
        logAuditAsync({
          entity: "SalesInvoice",
          entityId: invoiceId,
          action: "DELETE",
          userId: options.userId,
          details: {
            invoiceNumber: invoice.invoiceNumber,
            status: invoice.status,
            reason: options.reason
          }
        });
        logger.info(`Sales invoice ${invoiceId} soft deleted by user ${options.userId}`);
      });
    };
    safeDeletePurchaseInvoice = async (invoiceId, options) => {
      const prisma2 = getPrismaClient();
      return prisma2.$transaction(async (tx) => {
        const invoice = await tx.purchaseInvoice.findUnique({
          where: { id: invoiceId },
          include: {
            items: {
              include: {
                batch: true,
                product: true
              }
            }
          }
        });
        if (!invoice) {
          throw new Error("Purchase invoice not found");
        }
        if (invoice.deletedAt) {
          throw new Error("Purchase invoice is already deleted");
        }
        if (invoice.paymentStatus === "PAID" && !options.force) {
          throw new Error("Cannot delete paid invoice. Only ADMIN can force delete paid invoices.");
        }
        const { createLedgerEntry: createLedgerEntry2 } = await Promise.resolve().then(() => (init_stockLedgerService(), stockLedgerService_exports));
        for (const item of invoice.items) {
          if (item.batchId && item.batch) {
            const totalQuantity = item.quantity + item.freeQuantity;
            await createLedgerEntry2({
              productId: item.productId,
              batchId: item.batchId,
              movementType: "ADJUSTMENT",
              reference: `DELETE-${invoice.invoiceNumber}`,
              quantityChange: -totalQuantity,
              narration: `Stock reversed due to purchase invoice deletion: ${invoice.invoiceNumber}`,
              tx
            });
          }
        }
        await tx.purchaseInvoice.update({
          where: { id: invoiceId },
          data: {
            deletedAt: /* @__PURE__ */ new Date(),
            deletedBy: options.userId
          }
        });
        logAuditAsync({
          entity: "PurchaseInvoice",
          entityId: invoiceId,
          action: "DELETE",
          userId: options.userId,
          details: {
            invoiceNumber: invoice.invoiceNumber,
            reason: options.reason
          }
        });
        logger.info(`Purchase invoice ${invoiceId} soft deleted by user ${options.userId}`);
      });
    };
    safeDeleteBill = async (billId, options) => {
      const prisma2 = getPrismaClient();
      return prisma2.$transaction(async (tx) => {
        const bill = await tx.bill.findUnique({
          where: { id: billId },
          include: {
            lines: {
              include: {
                batch: true,
                product: true
              }
            }
          }
        });
        if (!bill) {
          throw new Error("Bill not found");
        }
        if (bill.deletedAt) {
          throw new Error("Bill is already deleted");
        }
        if (bill.status === "FINALIZED" && !options.force) {
          throw new Error("Cannot delete finalized bill. Only ADMIN can force delete finalized bills.");
        }
        const { createLedgerEntry: createLedgerEntry2 } = await Promise.resolve().then(() => (init_stockLedgerService(), stockLedgerService_exports));
        if (bill.status === "FINALIZED" && bill.billType === "SALES") {
          for (const line of bill.lines) {
            if (line.batchId && line.batch) {
              await createLedgerEntry2({
                productId: line.productId,
                batchId: line.batchId,
                movementType: "RETURN",
                reference: `DELETE-${bill.billNumber}`,
                quantityChange: line.quantity,
                narration: `Stock restored due to bill deletion: ${bill.billNumber}`,
                tx
              });
            }
          }
        }
        await tx.bill.update({
          where: { id: billId },
          data: {
            deletedAt: /* @__PURE__ */ new Date(),
            deletedBy: options.userId
          }
        });
        logAuditAsync({
          entity: "Bill",
          entityId: billId,
          action: "DELETE",
          userId: options.userId,
          details: {
            billNumber: bill.billNumber,
            billType: bill.billType,
            status: bill.status,
            reason: options.reason
          }
        });
        logger.info(`Bill ${billId} soft deleted by user ${options.userId}`);
      });
    };
  }
});

// electron/src/services/customerService.ts
var customerService_exports = {};
__export(customerService_exports, {
  createCustomer: () => createCustomer,
  deleteCustomer: () => deleteCustomer,
  getCustomerById: () => getCustomerById,
  listCustomers: () => listCustomers,
  updateCustomer: () => updateCustomer
});
var import_client6, mapCustomer, listCustomers, createCustomer, getCustomerById, updateCustomer, deleteCustomer;
var init_customerService = __esm({
  "electron/src/services/customerService.ts"() {
    "use strict";
    import_client6 = require("@prisma/client");
    init_prismaClient();
    init_auditService();
    mapCustomer = (customer) => ({
      id: customer.id,
      name: customer.name,
      gstin: customer.gstin ?? void 0,
      drugLicenseNumber: customer.drugLicenseNumber ?? void 0,
      drugLicenseNumber2: customer.drugLicenseNumber2 ?? void 0,
      panNumber: customer.panNumber ?? void 0,
      addressLine1: customer.addressLine1 ?? void 0,
      addressLine2: customer.addressLine2 ?? void 0,
      city: customer.city ?? void 0,
      state: customer.state ?? void 0,
      stateCode: customer.stateCode ?? void 0,
      postalCode: customer.postalCode ?? void 0,
      phone: customer.phone ?? void 0,
      email: customer.email ?? void 0,
      createdAt: customer.createdAt.toISOString()
    });
    listCustomers = async (search) => {
      const prisma2 = getPrismaClient();
      const customers = await prisma2.customer.findMany({
        where: search ? {
          name: { contains: search }
        } : void 0,
        orderBy: { name: "asc" }
      });
      return customers.map(mapCustomer);
    };
    createCustomer = async (payload) => {
      if (!payload.name) {
        throw new Error("Customer name is required");
      }
      const prisma2 = getPrismaClient();
      const customer = await prisma2.customer.create({
        data: {
          name: payload.name,
          gstin: payload.gstin,
          drugLicenseNumber: payload.drugLicenseNumber,
          drugLicenseNumber2: payload.drugLicenseNumber2,
          panNumber: payload.panNumber,
          addressLine1: payload.addressLine1,
          addressLine2: payload.addressLine2,
          city: payload.city,
          state: payload.state,
          stateCode: payload.stateCode,
          postalCode: payload.postalCode,
          phone: payload.phone,
          email: payload.email,
          creditLimit: new import_client6.Prisma.Decimal(payload.creditLimit ?? 0)
        }
      });
      await logAudit({
        entity: "Customer",
        entityId: customer.id,
        action: "CREATE",
        details: { name: customer.name, gstin: customer.gstin }
      });
      return mapCustomer(customer);
    };
    getCustomerById = async (id) => {
      const prisma2 = getPrismaClient();
      const customer = await prisma2.customer.findUnique({
        where: { id }
      });
      if (!customer) {
        throw new Error("Customer not found");
      }
      return mapCustomer(customer);
    };
    updateCustomer = async (id, payload) => {
      const prisma2 = getPrismaClient();
      const customer = await prisma2.customer.update({
        where: { id },
        data: {
          ...payload.name && { name: payload.name },
          ...payload.gstin !== void 0 && { gstin: payload.gstin },
          ...payload.drugLicenseNumber !== void 0 && { drugLicenseNumber: payload.drugLicenseNumber },
          ...payload.drugLicenseNumber2 !== void 0 && { drugLicenseNumber2: payload.drugLicenseNumber2 },
          ...payload.panNumber !== void 0 && { panNumber: payload.panNumber },
          ...payload.addressLine1 !== void 0 && { addressLine1: payload.addressLine1 },
          ...payload.addressLine2 !== void 0 && { addressLine2: payload.addressLine2 },
          ...payload.city !== void 0 && { city: payload.city },
          ...payload.state !== void 0 && { state: payload.state },
          ...payload.stateCode !== void 0 && { stateCode: payload.stateCode },
          ...payload.postalCode !== void 0 && { postalCode: payload.postalCode },
          ...payload.phone !== void 0 && { phone: payload.phone },
          ...payload.email !== void 0 && { email: payload.email },
          ...payload.creditLimit !== void 0 && { creditLimit: new import_client6.Prisma.Decimal(payload.creditLimit) }
        }
      });
      await logAudit({
        entity: "Customer",
        entityId: customer.id,
        action: "UPDATE",
        details: { name: customer.name }
      });
      return mapCustomer(customer);
    };
    deleteCustomer = async (id) => {
      const prisma2 = getPrismaClient();
      const customer = await prisma2.customer.findUnique({
        where: { id },
        include: {
          salesInvoices: { take: 1 }
        }
      });
      if (!customer) {
        throw new Error("Customer not found");
      }
      if (customer.salesInvoices.length > 0) {
        throw new Error("Cannot delete customer with existing sales invoices");
      }
      await prisma2.customer.delete({ where: { id } });
      await logAudit({
        entity: "Customer",
        entityId: id,
        action: "DELETE",
        details: { name: customer.name }
      });
    };
  }
});

// electron/src/services/gstComplianceService.ts
var gstComplianceService_exports = {};
__export(gstComplianceService_exports, {
  canPrintBill: () => canPrintBill,
  determineInterState: () => determineInterState,
  generateFYAwareBillNumber: () => generateFYAwareBillNumber,
  getFinancialYear: () => getFinancialYear,
  validateBillGSTCompliance: () => validateBillGSTCompliance,
  validateGSTBreakup: () => validateGSTBreakup,
  validateHSNCode: () => validateHSNCode
});
function validateHSNCode(hsnCode) {
  if (!hsnCode || hsnCode.trim().length === 0) {
    return { valid: false, error: "HSN code is required" };
  }
  const cleaned = hsnCode.trim().replace(/\s+/g, "");
  if (!/^\d{4,8}$/.test(cleaned)) {
    return { valid: false, error: "HSN code must be 4, 6, or 8 digits" };
  }
  return { valid: true };
}
async function determineInterState(customerState, supplierState) {
  const companyInfo = await getCompanyInfo();
  const companyState = companyInfo?.state;
  if (!companyState) {
    return false;
  }
  if (customerState) {
    return companyState.trim().toUpperCase() !== customerState.trim().toUpperCase();
  }
  if (supplierState) {
    return companyState.trim().toUpperCase() !== supplierState.trim().toUpperCase();
  }
  return false;
}
function getFinancialYear(date) {
  const month = date.getMonth() + 1;
  const calendarYear = date.getFullYear();
  let fyStartYear;
  if (month >= 4) {
    fyStartYear = calendarYear;
  } else {
    fyStartYear = calendarYear - 1;
  }
  const fyEndYear = fyStartYear + 1;
  const fyString = `${fyStartYear}-${String(fyEndYear).slice(-2)}`;
  return { year: fyStartYear, fyString };
}
async function generateFYAwareBillNumber(billType, billDate) {
  const prisma2 = getPrismaClient();
  const { fyString } = getFinancialYear(billDate);
  const prefix = billType === "SALES" ? "SAL" : billType === "PURCHASE" ? "PUR" : "CN";
  const lastBill = await prisma2.bill.findFirst({
    where: {
      billType,
      billNumber: {
        startsWith: `${prefix}-${fyString}-`
      }
    },
    orderBy: {
      billNumber: "desc"
    }
  });
  let sequence = 1;
  if (lastBill) {
    const match = lastBill.billNumber.match(/-(\d+)$/);
    if (match) {
      sequence = parseInt(match[1], 10) + 1;
    }
  }
  return `${prefix}-${fyString}-${String(sequence).padStart(4, "0")}`;
}
function validateGSTBreakup(lines, isInterState) {
  const errors = [];
  for (const line of lines) {
    if (isInterState) {
      if (line.cgstAmount > 0 || line.sgstAmount > 0) {
        errors.push(`Line ${line.taxableAmount}: Inter-state transaction cannot have CGST/SGST`);
      }
      if (line.igstAmount === 0 && line.taxPercent > 0) {
        errors.push(`Line ${line.taxableAmount}: Inter-state transaction must have IGST`);
      }
      const expectedIGST = line.taxableAmount * line.taxPercent / 100;
      if (Math.abs(line.igstAmount - expectedIGST) > 0.01) {
        errors.push(`Line ${line.taxableAmount}: IGST calculation mismatch`);
      }
    } else {
      if (line.igstAmount > 0) {
        errors.push(`Line ${line.taxableAmount}: Intra-state transaction cannot have IGST`);
      }
      if (line.cgstAmount === 0 && line.sgstAmount === 0 && line.taxPercent > 0) {
        errors.push(`Line ${line.taxableAmount}: Intra-state transaction must have CGST+SGST`);
      }
      const expectedCGST = line.taxableAmount * line.taxPercent / 200;
      const expectedSGST = expectedCGST;
      if (Math.abs(line.cgstAmount - expectedCGST) > 0.01) {
        errors.push(`Line ${line.taxableAmount}: CGST calculation mismatch`);
      }
      if (Math.abs(line.sgstAmount - expectedSGST) > 0.01) {
        errors.push(`Line ${line.taxableAmount}: SGST calculation mismatch`);
      }
    }
  }
  return {
    valid: errors.length === 0,
    errors
  };
}
async function validateBillGSTCompliance(billId) {
  const prisma2 = getPrismaClient();
  const errors = [];
  const warnings = [];
  const bill = await prisma2.bill.findUnique({
    where: { id: billId },
    include: {
      lines: true,
      customer: true,
      supplier: true
    }
  });
  if (!bill) {
    return { compliant: false, errors: ["Bill not found"], warnings: [] };
  }
  for (const line of bill.lines) {
    const hsnValidation = validateHSNCode(line.hsnCode);
    if (!hsnValidation.valid) {
      errors.push(`Line ${line.lineNumber}: ${hsnValidation.error}`);
    }
  }
  const isInterState = await determineInterState(
    bill.customer?.state,
    bill.supplier?.state
  );
  const gstValidation = validateGSTBreakup(
    bill.lines.map((line) => ({
      taxableAmount: Number(line.taxableAmount),
      cgstAmount: Number(line.cgstAmount),
      sgstAmount: Number(line.sgstAmount),
      igstAmount: Number(line.igstAmount),
      cgstPercent: Number(line.cgstPercent),
      sgstPercent: Number(line.sgstPercent),
      igstPercent: Number(line.igstPercent),
      taxPercent: Number(line.taxPercent)
    })),
    isInterState
  );
  if (!gstValidation.valid) {
    errors.push(...gstValidation.errors);
  }
  if (bill.billNumber) {
    const { fyString } = getFinancialYear(bill.billDate);
    const expectedPrefix = bill.billType === "SALES" ? "SAL" : bill.billType === "PURCHASE" ? "PUR" : "CN";
    if (!bill.billNumber.startsWith(`${expectedPrefix}-${fyString}-`)) {
      warnings.push(`Bill number format may not match financial year: ${bill.billNumber}`);
    }
  }
  const roundOff = Number(bill.roundOff);
  if (Math.abs(roundOff) > 1) {
    warnings.push(`Round-off amount is unusually high: ${roundOff}`);
  }
  if (bill.billType === "CREDIT_NOTE") {
    if (!bill.remarks && !bill.notes) {
      warnings.push("Credit note should reference the original invoice number");
    }
  }
  return {
    compliant: errors.length === 0,
    errors,
    warnings
  };
}
async function canPrintBill(billId) {
  const validation = await validateBillGSTCompliance(billId);
  if (!validation.compliant) {
    return {
      canPrint: false,
      reason: `GST compliance errors: ${validation.errors.join("; ")}`
    };
  }
  return { canPrint: true };
}
var init_gstComplianceService = __esm({
  "electron/src/services/gstComplianceService.ts"() {
    "use strict";
    init_prismaClient();
    init_companyInfoService();
  }
});

// electron/src/utils/asyncSafety.ts
async function safeQuery(query, timeout = 1e4, operationName = "database query") {
  return safeDbOperation(
    () => withTimeout(query, timeout, `${operationName} timed out`),
    { operation: operationName }
  );
}
var init_asyncSafety = __esm({
  "electron/src/utils/asyncSafety.ts"() {
    "use strict";
    init_errorHandler();
  }
});

// electron/src/services/fefoService.ts
var fefoService_exports = {};
__export(fefoService_exports, {
  allocateFefoBatches: () => allocateFefoBatches,
  getDaysUntilExpiry: () => getDaysUntilExpiry,
  getExpiredBatches: () => getExpiredBatches,
  getNearExpiryBatches: () => getNearExpiryBatches,
  isBatchExpired: () => isBatchExpired,
  isNearExpiry: () => isNearExpiry,
  overrideExpirySale: () => overrideExpirySale
});
function getDaysUntilExpiry(expiryDate) {
  const now = /* @__PURE__ */ new Date();
  const diffTime = expiryDate.getTime() - now.getTime();
  return Math.ceil(diffTime / (1e3 * 60 * 60 * 24));
}
function isBatchExpired(expiryDate) {
  return getDaysUntilExpiry(expiryDate) < 0;
}
function isNearExpiry(expiryDate, thresholdDays = NEAR_EXPIRY_DAYS) {
  const daysUntil = getDaysUntilExpiry(expiryDate);
  return daysUntil >= 0 && daysUntil <= thresholdDays;
}
async function allocateFefoBatches(tx, productId, quantity, batchId, options = {}) {
  const {
    allowExpired = false,
    allowNearExpiry = true,
    nearExpiryThreshold = NEAR_EXPIRY_DAYS,
    requireOverride = false,
    userId
  } = options;
  const warnings = [];
  let requiresOverride = false;
  if (batchId) {
    const batch = await tx.batch.findUnique({
      where: { id: batchId },
      include: {
        product: {
          select: { name: true }
        }
      }
    });
    if (!batch || batch.productId !== productId) {
      throw new Error("Invalid batch for this product");
    }
    if (batch.quantity < quantity) {
      throw new Error(`Insufficient batch quantity. Available: ${batch.quantity}, Required: ${quantity}`);
    }
    const daysUntil = getDaysUntilExpiry(batch.expiryDate);
    const expired = isBatchExpired(batch.expiryDate);
    const nearExpiry = isNearExpiry(batch.expiryDate, nearExpiryThreshold);
    if (expired && !allowExpired) {
      if (requireOverride && userId) {
        requiresOverride = true;
        warnings.push(
          `\u26A0\uFE0F EXPIRED BATCH: Batch ${batch.batchNumber} expired ${Math.abs(daysUntil)} days ago. Admin override required.`
        );
      } else {
        throw new Error(
          `Cannot sell expired batch ${batch.batchNumber}. Expired ${Math.abs(daysUntil)} days ago.`
        );
      }
    }
    if (nearExpiry && !expired) {
      if (daysUntil <= CRITICAL_EXPIRY_DAYS) {
        warnings.push(
          `\u{1F6A8} CRITICAL: Batch ${batch.batchNumber} expires in ${daysUntil} days!`
        );
      } else {
        warnings.push(
          `\u26A0\uFE0F WARNING: Batch ${batch.batchNumber} expires in ${daysUntil} days (near expiry)`
        );
      }
    }
    return {
      allocations: [{
        batchId: batch.id,
        quantity,
        mrp: batch.mrp,
        batchNumber: batch.batchNumber,
        expiryDate: batch.expiryDate,
        daysUntilExpiry: daysUntil,
        isNearExpiry: nearExpiry,
        isExpired: expired
      }],
      warnings,
      requiresOverride
    };
  }
  const batches = await tx.batch.findMany({
    where: {
      productId,
      quantity: { gt: 0 }
    },
    orderBy: {
      expiryDate: "asc"
    },
    include: {
      product: {
        select: { name: true }
      }
    }
  });
  if (batches.length === 0) {
    throw new Error("No batches available for this product");
  }
  const allocations = [];
  let remaining = quantity;
  for (const batch of batches) {
    if (remaining <= 0) break;
    const daysUntil = getDaysUntilExpiry(batch.expiryDate);
    const expired = isBatchExpired(batch.expiryDate);
    const nearExpiry = isNearExpiry(batch.expiryDate, nearExpiryThreshold);
    if (expired && !allowExpired) {
      if (requireOverride && userId) {
        requiresOverride = true;
        warnings.push(
          `\u26A0\uFE0F EXPIRED BATCH SKIPPED: ${batch.batchNumber} expired ${Math.abs(daysUntil)} days ago`
        );
      }
      continue;
    }
    const used = Math.min(batch.quantity, remaining);
    allocations.push({
      batchId: batch.id,
      quantity: used,
      mrp: batch.mrp,
      batchNumber: batch.batchNumber,
      expiryDate: batch.expiryDate,
      daysUntilExpiry: daysUntil,
      isNearExpiry: nearExpiry,
      isExpired: expired
    });
    if (nearExpiry && !expired) {
      if (daysUntil <= CRITICAL_EXPIRY_DAYS) {
        warnings.push(
          `\u{1F6A8} CRITICAL: Allocating ${used} from batch ${batch.batchNumber} expiring in ${daysUntil} days!`
        );
      } else {
        warnings.push(
          `\u26A0\uFE0F WARNING: Allocating ${used} from batch ${batch.batchNumber} expiring in ${daysUntil} days`
        );
      }
    }
    remaining -= used;
  }
  if (remaining > 0) {
    throw new Error(
      `Insufficient stock. Available: ${quantity - remaining}, Required: ${quantity}`
    );
  }
  return {
    allocations,
    warnings,
    requiresOverride
  };
}
async function overrideExpirySale(billId, batchId, quantity, reason, userId) {
  const prisma2 = getPrismaClient();
  const user = await prisma2.user.findUnique({
    where: { id: userId },
    include: { role: true }
  });
  if (!user || user.role.name.toUpperCase() !== "ADMIN") {
    throw new Error("Only admin users can override expiry restrictions");
  }
  const batch = await prisma2.batch.findUnique({
    where: { id: batchId },
    include: {
      product: {
        select: { name: true }
      }
    }
  });
  if (!batch) {
    throw new Error("Batch not found");
  }
  const daysUntil = getDaysUntilExpiry(batch.expiryDate);
  const expired = isBatchExpired(batch.expiryDate);
  await logAudit({
    entity: "Batch",
    entityId: batchId,
    action: "EXPIRY_OVERRIDE",
    userId,
    details: {
      billId,
      batchId,
      batchNumber: batch.batchNumber,
      productName: batch.product.name,
      quantity,
      reason,
      expired,
      daysUntilExpiry: daysUntil,
      overrideTimestamp: (/* @__PURE__ */ new Date()).toISOString()
    }
  });
}
async function getNearExpiryBatches(thresholdDays = NEAR_EXPIRY_DAYS, productId) {
  const prisma2 = getPrismaClient();
  const now = /* @__PURE__ */ new Date();
  const thresholdDate = new Date(now);
  thresholdDate.setDate(thresholdDate.getDate() + thresholdDays);
  const batches = await prisma2.batch.findMany({
    where: {
      quantity: { gt: 0 },
      expiryDate: {
        lte: thresholdDate
      },
      ...productId && { productId }
    },
    include: {
      product: {
        select: { name: true }
      }
    },
    orderBy: {
      expiryDate: "asc"
    }
  });
  return batches.map((batch) => {
    const daysUntil = getDaysUntilExpiry(batch.expiryDate);
    return {
      batchId: batch.id,
      batchNumber: batch.batchNumber,
      productId: batch.productId,
      productName: batch.product.name,
      quantity: batch.quantity,
      expiryDate: batch.expiryDate,
      daysUntilExpiry: daysUntil,
      isExpired: isBatchExpired(batch.expiryDate)
    };
  });
}
async function getExpiredBatches(productId) {
  const prisma2 = getPrismaClient();
  const now = /* @__PURE__ */ new Date();
  const batches = await prisma2.batch.findMany({
    where: {
      quantity: { gt: 0 },
      expiryDate: {
        lt: now
      },
      ...productId && { productId }
    },
    include: {
      product: {
        select: { name: true }
      }
    },
    orderBy: {
      expiryDate: "asc"
    }
  });
  return batches.map((batch) => {
    const daysUntil = getDaysUntilExpiry(batch.expiryDate);
    return {
      batchId: batch.id,
      batchNumber: batch.batchNumber,
      productId: batch.productId,
      productName: batch.product.name,
      quantity: batch.quantity,
      expiryDate: batch.expiryDate,
      daysExpired: Math.abs(daysUntil)
    };
  });
}
var NEAR_EXPIRY_DAYS, CRITICAL_EXPIRY_DAYS;
var init_fefoService = __esm({
  "electron/src/services/fefoService.ts"() {
    "use strict";
    init_prismaClient();
    init_auditService();
    NEAR_EXPIRY_DAYS = 30;
    CRITICAL_EXPIRY_DAYS = 7;
  }
});

// electron/src/services/validationService.ts
var validationService_exports = {};
__export(validationService_exports, {
  getBillValidationSummary: () => getBillValidationSummary,
  overrideValidationWarning: () => overrideValidationWarning,
  validateAbnormalQuantity: () => validateAbnormalQuantity,
  validateBill: () => validateBill,
  validateDuplicateBill: () => validateDuplicateBill,
  validateExcessiveDiscount: () => validateExcessiveDiscount,
  validateNearExpirySale: () => validateNearExpirySale,
  validateSellingBelowCost: () => validateSellingBelowCost
});
async function validateSellingBelowCost(productId, batchId, sellingPrice, quantity) {
  const prisma2 = getPrismaClient();
  let costPrice = 0;
  if (batchId) {
    const batch = await prisma2.batch.findUnique({
      where: { id: batchId },
      select: { ptr: true, pts: true }
    });
    if (batch) {
      costPrice = batch.pts ? Number(batch.pts) : Number(batch.ptr);
    }
  } else {
    const batch = await prisma2.batch.findFirst({
      where: { productId },
      orderBy: { createdAt: "desc" },
      select: { ptr: true, pts: true }
    });
    if (batch) {
      costPrice = batch.pts ? Number(batch.pts) : Number(batch.ptr);
    }
  }
  if (costPrice === 0) {
    return null;
  }
  const margin = sellingPrice - costPrice;
  const marginPercent = margin / costPrice * 100;
  if (margin < 0) {
    const lossAmount = Math.abs(margin) * quantity;
    return {
      type: "BELOW_COST",
      severity: "CRITICAL",
      message: `Selling below cost! Loss: \u20B9${lossAmount.toFixed(2)} (${Math.abs(marginPercent).toFixed(2)}% below cost)`,
      field: "rate",
      value: sellingPrice,
      suggestedValue: costPrice,
      requiresOverride: true
    };
  } else if (marginPercent < BELOW_COST_THRESHOLD * 100) {
    return {
      type: "BELOW_COST",
      severity: "HIGH",
      message: `Very low margin: ${marginPercent.toFixed(2)}%. Selling price is very close to cost.`,
      field: "rate",
      value: sellingPrice,
      suggestedValue: costPrice * 1.1,
      // Suggest 10% margin
      requiresOverride: false
    };
  }
  return null;
}
function validateExcessiveDiscount(mrp, sellingPrice, discountPercent) {
  if (discountPercent >= CRITICAL_DISCOUNT_THRESHOLD) {
    return {
      type: "EXCESSIVE_DISCOUNT",
      severity: "CRITICAL",
      message: `Excessive discount: ${discountPercent.toFixed(2)}%! This is unusually high.`,
      field: "discountPercent",
      value: discountPercent,
      suggestedValue: EXCESSIVE_DISCOUNT_THRESHOLD,
      requiresOverride: true
    };
  } else if (discountPercent >= EXCESSIVE_DISCOUNT_THRESHOLD) {
    return {
      type: "EXCESSIVE_DISCOUNT",
      severity: "HIGH",
      message: `High discount: ${discountPercent.toFixed(2)}%. Please verify this is correct.`,
      field: "discountPercent",
      value: discountPercent,
      suggestedValue: discountPercent,
      requiresOverride: false
    };
  }
  return null;
}
async function validateNearExpirySale(batchId, productId) {
  if (!batchId) {
    return null;
  }
  const prisma2 = getPrismaClient();
  const batch = await prisma2.batch.findUnique({
    where: { id: batchId },
    select: { expiryDate: true, batchNumber: true }
  });
  if (!batch) {
    return null;
  }
  const daysUntil = getDaysUntilExpiry(batch.expiryDate);
  const nearExpiry = isNearExpiry(batch.expiryDate, NEAR_EXPIRY_DAYS2);
  if (daysUntil < 0) {
    return {
      type: "NEAR_EXPIRY",
      severity: "CRITICAL",
      message: `Batch ${batch.batchNumber} has EXPIRED ${Math.abs(daysUntil)} days ago!`,
      field: "batchId",
      value: batchId,
      requiresOverride: true
    };
  } else if (daysUntil <= 7) {
    return {
      type: "NEAR_EXPIRY",
      severity: "CRITICAL",
      message: `Batch ${batch.batchNumber} expires in ${daysUntil} days! Critical expiry warning.`,
      field: "batchId",
      value: batchId,
      requiresOverride: false
    };
  } else if (nearExpiry) {
    return {
      type: "NEAR_EXPIRY",
      severity: "MEDIUM",
      message: `Batch ${batch.batchNumber} expires in ${daysUntil} days (near expiry).`,
      field: "batchId",
      value: batchId,
      requiresOverride: false
    };
  }
  return null;
}
async function validateDuplicateBill(billType, customerId, supplierId, billDate, totalAmount, excludeBillId) {
  const prisma2 = getPrismaClient();
  const sameDayBills = await prisma2.bill.findMany({
    where: {
      billType,
      billDate: {
        gte: new Date(billDate.getFullYear(), billDate.getMonth(), billDate.getDate()),
        lt: new Date(billDate.getFullYear(), billDate.getMonth(), billDate.getDate() + 1)
      },
      status: "FINALIZED",
      ...customerId && { customerId },
      ...supplierId && { supplierId },
      ...excludeBillId && { id: { not: excludeBillId } }
    },
    select: {
      id: true,
      billNumber: true,
      totalAmount: true
    }
  });
  const similarBills = sameDayBills.filter((bill) => {
    const diff = Math.abs(Number(bill.totalAmount) - totalAmount);
    const percentDiff = diff / totalAmount * 100;
    return percentDiff < 1;
  });
  if (similarBills.length > 0) {
    const billNumbers = similarBills.map((b) => b.billNumber).join(", ");
    return {
      type: "DUPLICATE_BILL",
      severity: similarBills.length >= 2 ? "HIGH" : "MEDIUM",
      message: `Possible duplicate bill detected. Similar bills found on same date: ${billNumbers}`,
      field: "billNumber",
      value: billNumbers,
      requiresOverride: false
    };
  }
  return null;
}
async function validateAbnormalQuantity(productId, quantity, billType) {
  if (billType !== "SALES") {
    return null;
  }
  const prisma2 = getPrismaClient();
  const thirtyDaysAgo = /* @__PURE__ */ new Date();
  thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
  const recentBills = await prisma2.bill.findMany({
    where: {
      billType: "SALES",
      status: "FINALIZED",
      billDate: { gte: thirtyDaysAgo }
    },
    include: {
      lines: {
        where: { productId },
        select: { quantity: true }
      }
    }
  });
  const quantities = [];
  recentBills.forEach((bill) => {
    bill.lines.forEach((line) => {
      quantities.push(line.quantity);
    });
  });
  if (quantities.length === 0) {
    return null;
  }
  const averageQuantity = quantities.reduce((sum, q) => sum + q, 0) / quantities.length;
  const maxQuantity = Math.max(...quantities);
  const threshold = Math.max(averageQuantity * ABNORMAL_QUANTITY_MULTIPLIER, maxQuantity * 1.5);
  if (quantity > threshold) {
    return {
      type: "ABNORMAL_QUANTITY",
      severity: quantity > threshold * 2 ? "HIGH" : "MEDIUM",
      message: `Abnormal quantity: ${quantity}. Average in last 30 days: ${averageQuantity.toFixed(0)}. This is ${(quantity / averageQuantity).toFixed(1)}x the average.`,
      field: "quantity",
      value: quantity,
      suggestedValue: averageQuantity,
      requiresOverride: false
    };
  }
  return null;
}
async function validateBill(billData, excludeBillId, userId) {
  const warnings = [];
  const errors = [];
  for (const line of billData.lines) {
    const belowCostWarning = await validateSellingBelowCost(
      line.productId,
      line.batchId ?? null,
      line.rate,
      line.quantity
    );
    if (belowCostWarning) {
      warnings.push(belowCostWarning);
    }
    if (line.mrp) {
      const discountPercent = (line.mrp - line.rate) / line.mrp * 100;
      const discountWarning = validateExcessiveDiscount(
        line.mrp,
        line.rate,
        discountPercent
      );
      if (discountWarning) {
        warnings.push(discountWarning);
      }
    }
    const expiryWarning = await validateNearExpirySale(
      line.batchId ?? null,
      line.productId
    );
    if (expiryWarning) {
      warnings.push(expiryWarning);
    }
    const quantityWarning = await validateAbnormalQuantity(
      line.productId,
      line.quantity,
      billData.billType
    );
    if (quantityWarning) {
      warnings.push(quantityWarning);
    }
  }
  const duplicateWarning = await validateDuplicateBill(
    billData.billType,
    billData.customerId ?? null,
    billData.supplierId ?? null,
    billData.billDate,
    billData.totalAmount,
    excludeBillId
  );
  if (duplicateWarning) {
    warnings.push(duplicateWarning);
  }
  const requiresOverride = warnings.some((w) => w.requiresOverride);
  const criticalWarnings = warnings.filter((w) => w.severity === "CRITICAL" && w.requiresOverride);
  if (criticalWarnings.length > 0 && !userId) {
    errors.push("Critical validation warnings require admin override");
  }
  return {
    valid: errors.length === 0,
    warnings,
    errors,
    canProceed: errors.length === 0 && (!requiresOverride || userId !== void 0)
  };
}
async function overrideValidationWarning(billId, warningType, reason, userId) {
  const prisma2 = getPrismaClient();
  const user = await prisma2.user.findUnique({
    where: { id: userId },
    include: { role: true }
  });
  if (!user || user.role.name.toUpperCase() !== "ADMIN") {
    throw new Error("Only admin users can override validation warnings");
  }
  await logAudit({
    entity: "Bill",
    entityId: billId,
    action: "VALIDATION_OVERRIDE",
    userId,
    details: {
      billId,
      warningType,
      reason,
      overrideTimestamp: (/* @__PURE__ */ new Date()).toISOString()
    }
  });
}
async function getBillValidationSummary(billId) {
  const prisma2 = getPrismaClient();
  const bill = await prisma2.bill.findUnique({
    where: { id: billId },
    include: {
      lines: {
        include: {
          product: true,
          batch: true
        }
      },
      customer: true,
      supplier: true
    }
  });
  if (!bill) {
    throw new Error("Bill not found");
  }
  const validation = await validateBill({
    billType: bill.billType,
    billDate: bill.billDate,
    customerId: bill.customerId,
    supplierId: bill.supplierId,
    totalAmount: Number(bill.totalAmount),
    lines: bill.lines.map((line) => ({
      productId: line.productId,
      batchId: line.batchId,
      rate: Number(line.rate),
      quantity: line.quantity,
      discountPercent: Number(line.discountPercent),
      mrp: line.batch ? Number(line.batch.mrp) : void 0
    }))
  }, billId);
  return {
    warnings: validation.warnings,
    hasCriticalWarnings: validation.warnings.some((w) => w.severity === "CRITICAL"),
    requiresOverride: validation.warnings.some((w) => w.requiresOverride)
  };
}
var BELOW_COST_THRESHOLD, EXCESSIVE_DISCOUNT_THRESHOLD, CRITICAL_DISCOUNT_THRESHOLD, NEAR_EXPIRY_DAYS2, ABNORMAL_QUANTITY_MULTIPLIER;
var init_validationService = __esm({
  "electron/src/services/validationService.ts"() {
    "use strict";
    init_prismaClient();
    init_auditService();
    init_fefoService();
    BELOW_COST_THRESHOLD = 0.05;
    EXCESSIVE_DISCOUNT_THRESHOLD = 20;
    CRITICAL_DISCOUNT_THRESHOLD = 30;
    NEAR_EXPIRY_DAYS2 = 30;
    ABNORMAL_QUANTITY_MULTIPLIER = 3;
  }
});

// electron/src/services/profitMarginService.ts
var profitMarginService_exports = {};
__export(profitMarginService_exports, {
  calculateBillProfitMargin: () => calculateBillProfitMargin,
  calculateCompanyProfitMargin: () => calculateCompanyProfitMargin,
  calculateLineProfitMargin: () => calculateLineProfitMargin,
  calculateProductProfitMargin: () => calculateProductProfitMargin,
  getComprehensiveProfitReport: () => getComprehensiveProfitReport,
  getExpiryLossImpact: () => getExpiryLossImpact
});
function calculateLineProfitMargin(costPrice, sellingPrice, quantity, freeQuantity, discountAmount, taxableAmount, gstAmount, lineTotal) {
  const effectiveQuantity = quantity + freeQuantity;
  const totalCost = costPrice * effectiveQuantity;
  const grossProfit = taxableAmount - totalCost;
  const netProfit = grossProfit;
  const profitMargin = taxableAmount > 0 ? netProfit / taxableAmount * 100 : 0;
  const profitPerUnit = quantity > 0 ? netProfit / quantity : 0;
  return {
    costPrice,
    sellingPrice,
    quantity,
    freeQuantity,
    discountAmount,
    taxableAmount,
    gstAmount,
    lineTotal,
    grossProfit,
    netProfit,
    profitMargin,
    profitPerUnit
  };
}
async function calculateBillProfitMargin(billId) {
  const prisma2 = getPrismaClient();
  const bill = await prisma2.bill.findUnique({
    where: { id: billId },
    include: {
      lines: {
        include: {
          product: {
            select: { name: true }
          },
          batch: {
            select: {
              ptr: true,
              pts: true
            }
          }
        }
      }
    }
  });
  if (!bill) {
    throw new Error("Bill not found");
  }
  if (bill.billType !== "SALES") {
    throw new Error("Profit calculation only available for sales bills");
  }
  const lines = [];
  let totalCost = 0;
  let totalGST = 0;
  let totalDiscount = 0;
  for (const line of bill.lines) {
    const costPrice = line.batch?.pts ? toNumber9(line.batch.pts) : line.batch?.ptr ? toNumber9(line.batch.ptr) : 0;
    const sellingPrice = toNumber9(line.rate);
    const quantity = line.quantity;
    const freeQuantity = line.freeQuantity;
    const discountAmount = toNumber9(line.discountAmount);
    const taxableAmount = toNumber9(line.taxableAmount);
    const gstAmount = toNumber9(line.cgstAmount) + toNumber9(line.sgstAmount) + toNumber9(line.igstAmount);
    const lineTotal = toNumber9(line.lineTotal);
    const margin = calculateLineProfitMargin(
      costPrice,
      sellingPrice,
      quantity,
      freeQuantity,
      discountAmount,
      taxableAmount,
      gstAmount,
      lineTotal
    );
    lines.push({
      ...margin,
      productId: line.productId,
      productName: line.productName
    });
    totalCost += margin.costPrice * (quantity + freeQuantity);
    totalGST += gstAmount;
    totalDiscount += discountAmount;
  }
  const totalAmount = toNumber9(bill.totalAmount);
  const grossProfit = totalAmount - totalGST - totalCost;
  const netProfit = grossProfit;
  const profitMargin = totalAmount - totalGST > 0 ? netProfit / (totalAmount - totalGST) * 100 : 0;
  return {
    billId: bill.id,
    billNumber: bill.billNumber,
    billType: bill.billType,
    billDate: bill.billDate,
    totalAmount,
    totalCost,
    totalGST,
    totalDiscount,
    grossProfit,
    netProfit,
    profitMargin,
    lines
  };
}
async function calculateProductProfitMargin(filters) {
  const prisma2 = getPrismaClient();
  const bills = await prisma2.bill.findMany({
    where: {
      billType: "SALES",
      status: "FINALIZED",
      ...filters?.fromDate || filters?.toDate ? {
        billDate: {
          ...filters.fromDate && { gte: new Date(filters.fromDate) },
          ...filters.toDate && { lte: new Date(filters.toDate) }
        }
      } : void 0
    },
    include: {
      lines: {
        include: {
          product: {
            select: { name: true }
          },
          batch: {
            select: {
              ptr: true,
              pts: true
            }
          }
        },
        ...filters?.productId && {
          where: {
            productId: filters.productId
          }
        }
      }
    }
  });
  const productMap = /* @__PURE__ */ new Map();
  for (const bill of bills) {
    for (const line of bill.lines) {
      const costPrice = line.batch?.pts ? toNumber9(line.batch.pts) : line.batch?.ptr ? toNumber9(line.batch.ptr) : 0;
      const sellingPrice = toNumber9(line.rate);
      const quantity = line.quantity;
      const freeQuantity = line.freeQuantity;
      const discountAmount = toNumber9(line.discountAmount);
      const taxableAmount = toNumber9(line.taxableAmount);
      const gstAmount = toNumber9(line.cgstAmount) + toNumber9(line.sgstAmount) + toNumber9(line.igstAmount);
      const lineTotal = toNumber9(line.lineTotal);
      const margin = calculateLineProfitMargin(
        costPrice,
        sellingPrice,
        quantity,
        freeQuantity,
        discountAmount,
        taxableAmount,
        gstAmount,
        lineTotal
      );
      const existing = productMap.get(line.productId);
      if (existing) {
        existing.totalSales += lineTotal;
        existing.totalCost += costPrice * (quantity + freeQuantity);
        existing.totalProfit += margin.netProfit;
        existing.billCount.add(bill.id);
        existing.margins.push(margin.profitMargin);
      } else {
        productMap.set(line.productId, {
          productName: line.productName,
          totalSales: lineTotal,
          totalCost: costPrice * (quantity + freeQuantity),
          totalProfit: margin.netProfit,
          billCount: /* @__PURE__ */ new Set([bill.id]),
          margins: [margin.profitMargin]
        });
      }
    }
  }
  return Array.from(productMap.entries()).map(([productId, data]) => {
    const totalSalesExGST = data.totalSales - data.totalSales * 0.18;
    const profitMargin = totalSalesExGST > 0 ? data.totalProfit / totalSalesExGST * 100 : 0;
    const averageMargin = data.margins.length > 0 ? data.margins.reduce((sum, m) => sum + m, 0) / data.margins.length : 0;
    return {
      productId,
      productName: data.productName,
      totalSales: data.totalSales,
      totalCost: data.totalCost,
      totalProfit: data.totalProfit,
      profitMargin,
      billCount: data.billCount.size,
      averageMargin
    };
  }).sort((a, b) => b.totalProfit - a.totalProfit);
}
async function calculateCompanyProfitMargin(filters) {
  const prisma2 = getPrismaClient();
  const bills = await prisma2.bill.findMany({
    where: {
      billType: "SALES",
      status: "FINALIZED",
      ...filters?.fromDate || filters?.toDate ? {
        billDate: {
          ...filters.fromDate && { gte: new Date(filters.fromDate) },
          ...filters.toDate && { lte: new Date(filters.toDate) }
        }
      } : void 0
    },
    include: {
      lines: {
        include: {
          product: {
            include: {
              company: {
                select: { id: true, name: true }
              }
            }
          },
          batch: {
            select: {
              ptr: true,
              pts: true
            }
          }
        }
      }
    }
  });
  const companyMap = /* @__PURE__ */ new Map();
  for (const bill of bills) {
    for (const line of bill.lines) {
      const company = line.product.company;
      if (!company) continue;
      const costPrice = line.batch?.pts ? toNumber9(line.batch.pts) : line.batch?.ptr ? toNumber9(line.batch.ptr) : 0;
      const sellingPrice = toNumber9(line.rate);
      const quantity = line.quantity;
      const freeQuantity = line.freeQuantity;
      const discountAmount = toNumber9(line.discountAmount);
      const taxableAmount = toNumber9(line.taxableAmount);
      const gstAmount = toNumber9(line.cgstAmount) + toNumber9(line.sgstAmount) + toNumber9(line.igstAmount);
      const lineTotal = toNumber9(line.lineTotal);
      const margin = calculateLineProfitMargin(
        costPrice,
        sellingPrice,
        quantity,
        freeQuantity,
        discountAmount,
        taxableAmount,
        gstAmount,
        lineTotal
      );
      const companyData = companyMap.get(company.id);
      if (companyData) {
        companyData.totalSales += lineTotal;
        companyData.totalCost += costPrice * (quantity + freeQuantity);
        companyData.totalProfit += margin.netProfit;
        companyData.billCount.add(bill.id);
        const productData = companyData.products.get(line.productId);
        if (productData) {
          productData.totalSales += lineTotal;
          productData.totalCost += costPrice * (quantity + freeQuantity);
          productData.totalProfit += margin.netProfit;
        } else {
          companyData.products.set(line.productId, {
            productName: line.productName,
            totalSales: lineTotal,
            totalCost: costPrice * (quantity + freeQuantity),
            totalProfit: margin.netProfit
          });
        }
      } else {
        const products = /* @__PURE__ */ new Map();
        products.set(line.productId, {
          productName: line.productName,
          totalSales: lineTotal,
          totalCost: costPrice * (quantity + freeQuantity),
          totalProfit: margin.netProfit
        });
        companyMap.set(company.id, {
          companyName: company.name,
          totalSales: lineTotal,
          totalCost: costPrice * (quantity + freeQuantity),
          totalProfit: margin.netProfit,
          billCount: /* @__PURE__ */ new Set([bill.id]),
          products
        });
      }
    }
  }
  return Array.from(companyMap.entries()).map(([companyId, data]) => {
    const totalSalesExGST = data.totalSales - data.totalSales * 0.18;
    const profitMargin = totalSalesExGST > 0 ? data.totalProfit / totalSalesExGST * 100 : 0;
    const products = Array.from(data.products.entries()).map(([productId, productData]) => {
      const productSalesExGST = productData.totalSales - productData.totalSales * 0.18;
      const productMargin = productSalesExGST > 0 ? productData.totalProfit / productSalesExGST * 100 : 0;
      return {
        productId,
        productName: productData.productName,
        totalSales: productData.totalSales,
        totalCost: productData.totalCost,
        totalProfit: productData.totalProfit,
        profitMargin: productMargin,
        billCount: 0,
        // Would need to track per product
        averageMargin: productMargin
      };
    }).sort((a, b) => b.totalProfit - a.totalProfit);
    return {
      companyId,
      companyName: data.companyName,
      totalSales: data.totalSales,
      totalCost: data.totalCost,
      totalProfit: data.totalProfit,
      profitMargin,
      billCount: data.billCount.size,
      products
    };
  }).sort((a, b) => b.totalProfit - a.totalProfit);
}
async function getExpiryLossImpact(filters) {
  const prisma2 = getPrismaClient();
  const expiryReturns = await prisma2.expiryReturn.findMany({
    where: {
      ...filters?.fromDate || filters?.toDate ? {
        returnDate: {
          ...filters.fromDate && { gte: new Date(filters.fromDate) },
          ...filters.toDate && { lte: new Date(filters.toDate) }
        }
      } : void 0,
      ...filters?.productId && {
        batch: {
          productId: filters.productId
        }
      }
    },
    include: {
      batch: {
        include: {
          product: {
            select: { name: true }
          }
        }
      }
    }
  });
  let totalExpiryLoss = 0;
  const productMap = /* @__PURE__ */ new Map();
  for (const ret of expiryReturns) {
    const lossAmount = toNumber9(ret.lossAmount);
    totalExpiryLoss += lossAmount;
    const productId = ret.batch.productId;
    const existing = productMap.get(productId);
    if (existing) {
      existing.expiryLoss += lossAmount;
    } else {
      productMap.set(productId, {
        productName: ret.batch.product.name,
        expiryLoss: lossAmount
      });
    }
  }
  const impactOnProfit = totalExpiryLoss;
  return {
    totalExpiryLoss,
    impactOnProfit,
    byProduct: Array.from(productMap.entries()).map(([productId, data]) => ({
      productId,
      productName: data.productName,
      expiryLoss: data.expiryLoss,
      impactOnProfit: data.expiryLoss
    })).sort((a, b) => b.expiryLoss - a.expiryLoss)
  };
}
async function getComprehensiveProfitReport(filters) {
  const [productMargins, companyMargins, expiryLoss] = await Promise.all([
    calculateProductProfitMargin(filters),
    calculateCompanyProfitMargin(filters),
    getExpiryLossImpact(filters)
  ]);
  const prisma2 = getPrismaClient();
  const bills = await prisma2.bill.findMany({
    where: {
      billType: "SALES",
      status: "FINALIZED",
      ...filters?.fromDate || filters?.toDate ? {
        billDate: {
          ...filters.fromDate && { gte: new Date(filters.fromDate) },
          ...filters.toDate && { lte: new Date(filters.toDate) }
        }
      } : void 0
    },
    select: { id: true }
  });
  const billMargins = [];
  for (const bill of bills) {
    try {
      const margin = await calculateBillProfitMargin(bill.id);
      billMargins.push(margin);
    } catch (error) {
      console.warn(`Failed to calculate profit for bill ${bill.id}:`, error);
    }
  }
  const totalSales = billMargins.reduce((sum, b) => sum + b.totalAmount, 0);
  const totalCost = billMargins.reduce((sum, b) => sum + b.totalCost, 0);
  const totalGST = billMargins.reduce((sum, b) => sum + b.totalGST, 0);
  const totalDiscount = billMargins.reduce((sum, b) => sum + b.totalDiscount, 0);
  const grossProfit = totalSales - totalGST - totalCost;
  const netProfit = grossProfit - expiryLoss.impactOnProfit;
  const profitMargin = totalSales - totalGST > 0 ? netProfit / (totalSales - totalGST) * 100 : 0;
  return {
    summary: {
      totalSales,
      totalCost,
      totalGST,
      totalDiscount,
      totalExpiryLoss: expiryLoss.totalExpiryLoss,
      grossProfit,
      netProfit,
      profitMargin
    },
    byBill: billMargins.sort((a, b) => b.netProfit - a.netProfit),
    byProduct: productMargins,
    byCompany: companyMargins,
    expiryLossImpact: {
      totalExpiryLoss: expiryLoss.totalExpiryLoss,
      impactOnProfit: expiryLoss.impactOnProfit
    }
  };
}
var import_client16, toNumber9;
var init_profitMarginService = __esm({
  "electron/src/services/profitMarginService.ts"() {
    "use strict";
    import_client16 = require("@prisma/client");
    init_prismaClient();
    toNumber9 = (value) => {
      if (value instanceof import_client16.Prisma.Decimal) return value.toNumber();
      return Number(value ?? 0);
    };
  }
});

// electron/src/services/auditLockService.ts
var auditLockService_exports = {};
__export(auditLockService_exports, {
  canOverrideLock: () => canOverrideLock,
  createAuditVersion: () => createAuditVersion,
  getBillAuditHistory: () => getBillAuditHistory,
  getChangeDiff: () => getChangeDiff,
  isBillLocked: () => isBillLocked,
  overrideBillLock: () => overrideBillLock,
  validateBillModification: () => validateBillModification
});
function isBillLocked(status) {
  return status === "FINALIZED";
}
async function canOverrideLock(userId) {
  if (!userId) {
    return false;
  }
  const prisma2 = getPrismaClient();
  const user = await prisma2.user.findUnique({
    where: { id: userId },
    include: {
      role: true
    }
  });
  if (!user) {
    return false;
  }
  return user.role.name.toUpperCase() === "ADMIN";
}
async function createAuditVersion(billId, action, changesJson, performedBy, notes) {
  const prisma2 = getPrismaClient();
  const maxVersion = await prisma2.billAuditVersion.findFirst({
    where: { billId },
    orderBy: { version: "desc" },
    select: { version: true }
  });
  const nextVersion = (maxVersion?.version || 0) + 1;
  await prisma2.billAuditVersion.create({
    data: {
      billId,
      version: nextVersion,
      action,
      changesJson,
      performedBy,
      notes
    }
  });
}
function getChangeDiff(oldData, newData) {
  const diff = {};
  const allKeys = /* @__PURE__ */ new Set([...Object.keys(oldData), ...Object.keys(newData)]);
  for (const key of allKeys) {
    const oldValue = oldData[key];
    const newValue = newData[key];
    if (JSON.stringify(oldValue) !== JSON.stringify(newValue)) {
      diff[key] = { old: oldValue, new: newValue };
    }
  }
  return diff;
}
async function validateBillModification(billId, userId, requireOverride = true) {
  const prisma2 = getPrismaClient();
  const bill = await prisma2.bill.findUnique({
    where: { id: billId },
    select: { status: true }
  });
  if (!bill) {
    return {
      allowed: false,
      reason: "Bill not found",
      requiresOverride: false
    };
  }
  if (!isBillLocked(bill.status)) {
    return {
      allowed: true,
      requiresOverride: false
    };
  }
  if (requireOverride) {
    const canOverride = await canOverrideLock(userId);
    if (!canOverride) {
      return {
        allowed: false,
        reason: "Bill is finalized and cannot be modified. Admin override required.",
        requiresOverride: true
      };
    }
  }
  return {
    allowed: true,
    requiresOverride: true
  };
}
async function overrideBillLock(billId, userId, reason, changes) {
  const canOverride = await canOverrideLock(userId);
  if (!canOverride) {
    throw new Error("Only admin users can override finalized bills");
  }
  const prisma2 = getPrismaClient();
  const bill = await prisma2.bill.findUnique({
    where: { id: billId }
  });
  if (!bill) {
    throw new Error("Bill not found");
  }
  if (!isBillLocked(bill.status)) {
    throw new Error("Bill is not locked");
  }
  const changesJson = changes ? JSON.stringify(changes) : JSON.stringify({ override: true, reason });
  await createAuditVersion(
    billId,
    "ADMIN_OVERRIDE",
    changesJson,
    userId,
    `Admin override: ${reason}`
  );
  await logAudit({
    entity: "Bill",
    entityId: billId,
    action: "ADMIN_OVERRIDE",
    userId,
    details: {
      billId,
      reason,
      changes,
      overrideTimestamp: (/* @__PURE__ */ new Date()).toISOString()
    }
  });
}
async function getBillAuditHistory(billId) {
  const prisma2 = getPrismaClient();
  const versions = await prisma2.billAuditVersion.findMany({
    where: { billId },
    include: {
      performedByUser: {
        select: {
          fullName: true
        }
      }
    },
    orderBy: { version: "asc" }
  });
  return versions.map((v) => ({
    version: v.version,
    action: v.action,
    performedBy: v.performedBy,
    performedByUser: v.performedByUser?.fullName || null,
    performedAt: v.performedAt,
    notes: v.notes,
    changes: v.changesJson ? JSON.parse(v.changesJson) : null
  }));
}
var init_auditLockService = __esm({
  "electron/src/services/auditLockService.ts"() {
    "use strict";
    init_prismaClient();
    init_auditService();
  }
});

// electron/src/services/drugScheduleService.ts
var drugScheduleService_exports = {};
__export(drugScheduleService_exports, {
  canSellWithoutDoctor: () => canSellWithoutDoctor,
  getProductScheduleInfo: () => getProductScheduleInfo,
  requiresPrescription: () => requiresPrescription,
  validateBillScheduleCompliance: () => validateBillScheduleCompliance,
  validateScheduleSale: () => validateScheduleSale
});
function requiresPrescription(scheduleName) {
  if (!scheduleName) {
    return false;
  }
  return RESTRICTED_SCHEDULES.includes(scheduleName.toUpperCase());
}
async function validateScheduleSale(productId, doctorId, billType) {
  if (billType !== "SALES") {
    return { allowed: true, requiresAudit: false };
  }
  const prisma2 = getPrismaClient();
  const product = await prisma2.product.findUnique({
    where: { id: productId },
    include: {
      schedule: true
    }
  });
  if (!product) {
    return {
      allowed: false,
      error: "Product not found",
      requiresAudit: true
    };
  }
  const scheduleName = product.schedule?.name;
  const isRestricted = requiresPrescription(scheduleName);
  if (!isRestricted) {
    return { allowed: true, requiresAudit: false };
  }
  if (!doctorId) {
    return {
      allowed: false,
      error: `Product "${product.name}" is Schedule ${scheduleName} and requires doctor/prescription details`,
      requiresAudit: true
    };
  }
  const doctor = await prisma2.doctor.findUnique({
    where: { id: doctorId }
  });
  if (!doctor) {
    return {
      allowed: false,
      error: "Doctor not found",
      requiresAudit: true
    };
  }
  return {
    allowed: true,
    warning: `Schedule ${scheduleName} product sold with prescription from Dr. ${doctor.name}`,
    requiresAudit: true
  };
}
async function validateBillScheduleCompliance(billId, lines, doctorId, billType) {
  const errors = [];
  const warnings = [];
  let auditRequired = false;
  for (const line of lines) {
    const validation = await validateScheduleSale(
      line.productId,
      doctorId,
      billType
    );
    if (!validation.allowed) {
      errors.push(validation.error || "Schedule validation failed");
    }
    if (validation.warning) {
      warnings.push(validation.warning);
    }
    if (validation.requiresAudit) {
      auditRequired = true;
    }
  }
  if (auditRequired && billType === "SALES") {
    await logAudit({
      entity: "Bill",
      entityId: billId,
      action: "SCHEDULE_SALE",
      details: {
        billId,
        doctorId: doctorId || null,
        warnings,
        scheduleRestricted: true
      }
    });
  }
  return {
    compliant: errors.length === 0,
    errors,
    warnings,
    auditRequired
  };
}
async function getProductScheduleInfo(productId) {
  const prisma2 = getPrismaClient();
  const product = await prisma2.product.findUnique({
    where: { id: productId },
    include: {
      schedule: true
    }
  });
  if (!product) {
    throw new Error("Product not found");
  }
  const scheduleName = product.schedule?.name || null;
  const needsPrescription = requiresPrescription(scheduleName);
  const restrictions = [];
  if (needsPrescription) {
    restrictions.push("Requires valid prescription");
    restrictions.push("Doctor details mandatory");
    if (scheduleName === "H1") {
      restrictions.push("Schedule H1: Additional restrictions apply");
    }
  }
  return {
    scheduleName,
    requiresPrescription: needsPrescription,
    restrictions
  };
}
async function canSellWithoutDoctor(productId) {
  const info = await getProductScheduleInfo(productId);
  if (info.requiresPrescription) {
    return {
      allowed: false,
      reason: `Schedule ${info.scheduleName} product requires prescription and doctor details`
    };
  }
  return { allowed: true };
}
var RESTRICTED_SCHEDULES;
var init_drugScheduleService = __esm({
  "electron/src/services/drugScheduleService.ts"() {
    "use strict";
    init_prismaClient();
    init_auditService();
    RESTRICTED_SCHEDULES = ["H", "H1", "X"];
  }
});

// electron/src/services/billService.ts
var billService_exports = {};
__export(billService_exports, {
  cancelBill: () => cancelBill,
  createBill: () => createBill,
  deleteBill: () => deleteBill,
  finalizeBill: () => finalizeBill,
  getBillById: () => getBillById,
  listBills: () => listBills,
  updateBill: () => updateBill
});
var import_client17, toDecimal4, toNumber10, generateBillNumber, mapBillLine, mapBill, calculateLineTotals, createBill, updateBill, finalizeBill, cancelBill, getBillById, listBills, deleteBill;
var init_billService = __esm({
  "electron/src/services/billService.ts"() {
    "use strict";
    import_client17 = require("@prisma/client");
    init_prismaClient();
    init_auditService();
    init_asyncSafety();
    toDecimal4 = (value) => new import_client17.Prisma.Decimal(Number(value || 0));
    toNumber10 = (value) => {
      if (value instanceof import_client17.Prisma.Decimal) {
        return value.toNumber();
      }
      return Number(value ?? 0);
    };
    generateBillNumber = async (billType, billDate) => {
      const { generateFYAwareBillNumber: generateFYAwareBillNumber2 } = await Promise.resolve().then(() => (init_gstComplianceService(), gstComplianceService_exports));
      return generateFYAwareBillNumber2(billType, billDate);
    };
    mapBillLine = (line) => ({
      id: line.id,
      lineNumber: line.lineNumber,
      productId: line.productId,
      batchId: line.batchId ?? void 0,
      productName: line.productName,
      hsnCode: line.hsnCode,
      manufacturer: line.manufacturer ?? void 0,
      packSize: line.packSize ?? void 0,
      unitOfMeasure: line.unitOfMeasure ?? void 0,
      batchNumber: line.batchNumber ?? void 0,
      expiryDate: line.expiryDate?.toISOString() ?? void 0,
      quantity: line.quantity,
      freeQuantity: line.freeQuantity,
      soldInStrips: line.soldInStrips,
      stripQuantity: line.stripQuantity ?? void 0,
      mrp: toNumber10(line.mrp),
      ptr: toNumber10(line.ptr),
      pts: line.pts ? toNumber10(line.pts) : void 0,
      rate: toNumber10(line.rate),
      discountPercent: toNumber10(line.discountPercent),
      discountAmount: toNumber10(line.discountAmount),
      taxPercent: toNumber10(line.taxPercent),
      cgstPercent: toNumber10(line.cgstPercent),
      sgstPercent: toNumber10(line.sgstPercent),
      igstPercent: toNumber10(line.igstPercent),
      cgstAmount: toNumber10(line.cgstAmount),
      sgstAmount: toNumber10(line.sgstAmount),
      igstAmount: toNumber10(line.igstAmount),
      taxableAmount: toNumber10(line.taxableAmount),
      lineTotal: toNumber10(line.lineTotal),
      savingPercent: line.savingPercent ? toNumber10(line.savingPercent) : void 0,
      savingValue: line.savingValue ? toNumber10(line.savingValue) : void 0
    });
    mapBill = (bill) => ({
      id: bill.id,
      billNumber: bill.billNumber,
      billType: bill.billType,
      billDate: bill.billDate.toISOString(),
      dueDate: bill.dueDate?.toISOString() ?? void 0,
      status: bill.status,
      paymentStatus: bill.paymentStatus,
      billingType: bill.billingType ?? void 0,
      customerId: bill.customerId ?? void 0,
      supplierId: bill.supplierId ?? void 0,
      customerName: bill.customerName ?? bill.customer?.name ?? void 0,
      supplierName: bill.supplierName ?? bill.supplier?.name ?? void 0,
      customerGstin: bill.customerGstin ?? void 0,
      supplierGstin: bill.supplierGstin ?? void 0,
      customerAddress: bill.customerAddress ?? void 0,
      supplierAddress: bill.supplierAddress ?? void 0,
      customerPhone: bill.customerPhone ?? void 0,
      supplierPhone: bill.supplierPhone ?? void 0,
      mrId: bill.mrId ?? void 0,
      mrName: bill.mr?.name ?? void 0,
      doctorId: bill.doctorId ?? void 0,
      doctorName: bill.doctor?.name ?? void 0,
      challanNumber: bill.challanNumber ?? void 0,
      orderNumber: bill.orderNumber ?? void 0,
      remarks: bill.remarks ?? void 0,
      notes: bill.notes ?? void 0,
      subtotal: toNumber10(bill.subtotal),
      totalDiscount: toNumber10(bill.totalDiscount),
      totalTax: toNumber10(bill.totalTax),
      cgstTotal: toNumber10(bill.cgstTotal),
      sgstTotal: toNumber10(bill.sgstTotal),
      igstTotal: toNumber10(bill.igstTotal),
      roundOff: toNumber10(bill.roundOff),
      totalAmount: toNumber10(bill.totalAmount),
      paidAmount: toNumber10(bill.paidAmount),
      templateId: bill.templateId ?? void 0,
      finalizedAt: bill.finalizedAt?.toISOString() ?? void 0,
      finalizedBy: bill.finalizedBy ?? void 0,
      cancelledAt: bill.cancelledAt?.toISOString() ?? void 0,
      cancelledBy: bill.cancelledBy ?? void 0,
      cancellationReason: bill.cancellationReason ?? void 0,
      lines: bill.lines.map(mapBillLine),
      createdAt: bill.createdAt.toISOString(),
      updatedAt: bill.updatedAt.toISOString()
    });
    calculateLineTotals = (mrp, rate, quantity, freeQuantity, discountPercent, taxPercent, isInterState) => {
      const baseAmount = rate * quantity;
      const discountAmount = baseAmount * (discountPercent / 100);
      const taxableAmount = baseAmount - discountAmount;
      const cgstPercent = isInterState ? 0 : taxPercent / 2;
      const sgstPercent = isInterState ? 0 : taxPercent / 2;
      const igstPercent = isInterState ? taxPercent : 0;
      const cgstAmount = taxableAmount * (cgstPercent / 100);
      const sgstAmount = taxableAmount * (sgstPercent / 100);
      const igstAmount = taxableAmount * (igstPercent / 100);
      const lineTotal = taxableAmount + cgstAmount + sgstAmount + igstAmount;
      const savingValue = (mrp - rate) * quantity;
      const savingPercent = mrp > 0 ? (mrp - rate) / mrp * 100 : 0;
      return {
        discountAmount,
        taxableAmount,
        cgstPercent,
        sgstPercent,
        igstPercent,
        cgstAmount,
        sgstAmount,
        igstAmount,
        lineTotal,
        savingValue,
        savingPercent
      };
    };
    createBill = async (payload, userId) => {
      if (!payload.billType || !payload.billDate || !payload.lines || payload.lines.length === 0) {
        throw new Error("Bill type, date, and at least one line item are required");
      }
      const prisma2 = getPrismaClient();
      return prisma2.$transaction(
        async (tx) => {
          const billNumber = payload.billNumber || await generateBillNumber(
            payload.billType,
            new Date(payload.billDate)
          );
          const existing = await tx.bill.findUnique({
            where: { billNumber }
          });
          if (existing) {
            throw new Error("Bill number already exists");
          }
          const { validateBill: validateBill2 } = await Promise.resolve().then(() => (init_validationService(), validationService_exports));
          const validation = await validateBill2({
            billType: payload.billType,
            billDate: new Date(payload.billDate),
            customerId: payload.customerId,
            supplierId: payload.supplierId,
            totalAmount: 0,
            // Will be calculated
            lines: payload.lines.map((line) => ({
              productId: line.productId,
              batchId: line.batchId,
              rate: line.rate || 0,
              quantity: line.quantity,
              discountPercent: line.discountPercent || 0,
              mrp: void 0
              // Will be fetched from batch
            }))
          }, void 0, userId);
          if (validation.warnings.length > 0) {
            console.warn("Bill validation warnings:", validation.warnings);
            for (const warning of validation.warnings) {
              logAuditAsync({
                entity: "Bill",
                entityId: 0,
                // Will be set after creation
                action: "VALIDATION_WARNING",
                userId,
                details: {
                  warningType: warning.type,
                  severity: warning.severity,
                  message: warning.message,
                  billNumber
                }
              });
            }
          }
          let customerData = null;
          let supplierData = null;
          if (payload.customerId) {
            const customer = await tx.customer.findUnique({
              where: { id: payload.customerId },
              select: {
                name: true,
                gstin: true,
                addressLine1: true,
                addressLine2: true,
                city: true,
                state: true,
                phone: true
              }
            });
            if (!customer) {
              throw new Error("Customer not found");
            }
            customerData = {
              name: customer.name,
              gstin: customer.gstin ?? void 0,
              addressLine1: customer.addressLine1 ?? void 0,
              addressLine2: customer.addressLine2 ?? void 0,
              city: customer.city ?? void 0,
              state: customer.state ?? void 0,
              phone: customer.phone ?? void 0
            };
          }
          if (payload.supplierId) {
            const supplier = await tx.supplier.findUnique({
              where: { id: payload.supplierId },
              select: {
                name: true,
                gstin: true,
                fullAddress: true,
                addressLine1: true,
                addressLine2: true,
                city: true,
                state: true,
                phone: true
              }
            });
            if (!supplier) {
              throw new Error("Supplier not found");
            }
            supplierData = {
              name: supplier.name,
              gstin: supplier.gstin ?? void 0,
              fullAddress: supplier.fullAddress ?? void 0,
              addressLine1: supplier.addressLine1 ?? void 0,
              addressLine2: supplier.addressLine2 ?? void 0,
              city: supplier.city ?? void 0,
              state: supplier.state ?? void 0,
              phone: supplier.phone ?? void 0
            };
          }
          const { determineInterState: determineInterState2 } = await Promise.resolve().then(() => (init_gstComplianceService(), gstComplianceService_exports));
          const isInterState = await determineInterState2(
            customerData?.state,
            supplierData?.state
          );
          const linesData = await Promise.all(
            payload.lines.map(async (line, index) => {
              const product = await tx.product.findUnique({
                where: { id: line.productId },
                include: {
                  batches: line.batchId ? {
                    where: { id: line.batchId }
                  } : false
                }
              });
              if (!product) {
                throw new Error(`Product with ID ${line.productId} not found`);
              }
              const { validateHSNCode: validateHSNCode2 } = await Promise.resolve().then(() => (init_gstComplianceService(), gstComplianceService_exports));
              const hsnValidation = validateHSNCode2(product.hsnCode);
              if (!hsnValidation.valid) {
                throw new Error(`Product ${product.name}: ${hsnValidation.error}`);
              }
              const stripQty = line.stripQuantity ?? product.stripQuantity ?? 1;
              let actualQuantity = line.quantity;
              if (line.soldInStrips && stripQty) {
                actualQuantity = line.quantity * stripQty;
              }
              let batch = null;
              if (line.batchId) {
                const foundBatch = await tx.batch.findUnique({
                  where: { id: line.batchId }
                });
                if (!foundBatch || foundBatch.productId !== product.id) {
                  throw new Error(`Invalid batch for product ${product.name}`);
                }
                batch = foundBatch;
              } else if (product.isBatchManaged) {
                const { allocateFefoBatches: allocateFefoBatches2 } = await Promise.resolve().then(() => (init_fefoService(), fefoService_exports));
                const fefoResult = await allocateFefoBatches2(
                  tx,
                  product.id,
                  actualQuantity,
                  void 0,
                  {
                    allowExpired: false,
                    // Block expired batches
                    allowNearExpiry: true,
                    // Allow but warn
                    requireOverride: false
                  }
                );
                if (fefoResult.allocations.length > 0) {
                  const allocation = fefoResult.allocations[0];
                  batch = await tx.batch.findUnique({
                    where: { id: allocation.batchId }
                  });
                  if (fefoResult.warnings.length > 0) {
                    console.warn(`FEFO warnings for ${product.name}:`, fefoResult.warnings);
                  }
                }
              }
              if (product.isBatchManaged && !batch) {
                throw new Error(`No available batch for product ${product.name}`);
              }
              const mrp = batch ? toNumber10(batch.mrp) : 0;
              const ptr = batch ? toNumber10(batch.ptr) : 0;
              const pts = batch ? toNumber10(batch.pts) : 0;
              const rate = line.rate || ptr;
              const taxPercent = batch ? toNumber10(batch.taxPercent) : toNumber10(product.gstRate);
              if (batch && actualQuantity > batch.quantity) {
                throw new Error(`Insufficient stock for batch ${batch.batchNumber}. Available: ${batch.quantity}, Required: ${actualQuantity}`);
              }
              const calculations = calculateLineTotals(
                mrp,
                rate,
                actualQuantity,
                line.freeQuantity ?? 0,
                line.discountPercent ?? 0,
                taxPercent,
                isInterState
              );
              const { calculateLineProfitMargin: calculateLineProfitMargin2 } = await Promise.resolve().then(() => (init_profitMarginService(), profitMarginService_exports));
              const profitCalc = calculateLineProfitMargin2(
                ptr,
                // Cost price (PTR)
                rate,
                // Selling price
                actualQuantity,
                line.freeQuantity ?? 0,
                calculations.discountAmount,
                calculations.taxableAmount,
                calculations.cgstAmount + calculations.sgstAmount + calculations.igstAmount,
                calculations.lineTotal
              );
              return {
                lineNumber: line.lineNumber || index + 1,
                productId: product.id,
                batchId: batch?.id ?? null,
                productName: product.name,
                hsnCode: product.hsnCode,
                manufacturer: product.manufacturer,
                packSize: product.packSize,
                unitOfMeasure: product.unitOfMeasure,
                batchNumber: batch?.batchNumber ?? null,
                expiryDate: batch?.expiryDate ?? null,
                quantity: actualQuantity,
                freeQuantity: line.freeQuantity ?? 0,
                soldInStrips: line.soldInStrips ?? false,
                stripQuantity: stripQty,
                mrp: toDecimal4(mrp),
                ptr: toDecimal4(ptr),
                pts: pts > 0 ? toDecimal4(pts) : null,
                rate: toDecimal4(rate),
                discountPercent: toDecimal4(line.discountPercent ?? 0),
                discountAmount: toDecimal4(calculations.discountAmount),
                taxPercent: toDecimal4(taxPercent),
                cgstPercent: toDecimal4(calculations.cgstPercent),
                sgstPercent: toDecimal4(calculations.sgstPercent),
                igstPercent: toDecimal4(calculations.igstPercent),
                cgstAmount: toDecimal4(calculations.cgstAmount),
                sgstAmount: toDecimal4(calculations.sgstAmount),
                igstAmount: toDecimal4(calculations.igstAmount),
                taxableAmount: toDecimal4(calculations.taxableAmount),
                lineTotal: toDecimal4(calculations.lineTotal),
                savingPercent: mrp > 0 ? toDecimal4(calculations.savingPercent) : null,
                savingValue: toDecimal4(calculations.savingValue)
                // Calculate profit margin (rate - cost)
                // Profit = (rate - PTR/PTS) * quantity, excluding free quantity cost
                // Note: Free quantity reduces profit as it's given free but cost is incurred
                // Profit margin = (Profit / Taxable Amount) * 100
              };
            })
          );
          const subtotal = linesData.reduce((sum, line) => sum + toNumber10(line.taxableAmount), 0);
          const totalDiscount = linesData.reduce((sum, line) => sum + toNumber10(line.discountAmount), 0);
          const cgstTotal = linesData.reduce((sum, line) => sum + toNumber10(line.cgstAmount), 0);
          const sgstTotal = linesData.reduce((sum, line) => sum + toNumber10(line.sgstAmount), 0);
          const igstTotal = linesData.reduce((sum, line) => sum + toNumber10(line.igstAmount), 0);
          const totalTax = cgstTotal + sgstTotal + igstTotal;
          const totalBeforeRoundOff = subtotal + totalTax;
          const roundOff = Math.round(totalBeforeRoundOff) - totalBeforeRoundOff;
          const totalAmount = totalBeforeRoundOff + roundOff;
          const customerAddress = customerData ? [
            customerData.addressLine1,
            customerData.addressLine2,
            customerData.city,
            customerData.state
          ].filter(Boolean).join(", ") : payload.customerAddress;
          const supplierAddress = supplierData ? supplierData.fullAddress || [
            supplierData.addressLine1,
            supplierData.addressLine2,
            supplierData.city,
            supplierData.state
          ].filter(Boolean).join(", ") : payload.supplierAddress;
          const bill = await tx.bill.create({
            data: {
              billNumber,
              billType: payload.billType,
              billDate: new Date(payload.billDate),
              dueDate: payload.dueDate ? new Date(payload.dueDate) : null,
              billingType: payload.billingType,
              customerId: payload.customerId ?? null,
              supplierId: payload.supplierId ?? null,
              customerName: customerData?.name ?? payload.customerName ?? null,
              supplierName: supplierData?.name ?? payload.supplierName ?? null,
              customerGstin: customerData?.gstin ?? payload.customerGstin ?? null,
              supplierGstin: supplierData?.gstin ?? payload.supplierGstin ?? null,
              customerAddress,
              supplierAddress,
              customerPhone: customerData?.phone ?? payload.customerPhone ?? null,
              supplierPhone: supplierData?.phone ?? payload.supplierPhone ?? null,
              mrId: payload.mrId ?? null,
              doctorId: payload.doctorId ?? null,
              challanNumber: payload.challanNumber ?? null,
              orderNumber: payload.orderNumber ?? null,
              remarks: payload.remarks ?? null,
              notes: payload.notes ?? null,
              subtotal: toDecimal4(subtotal),
              totalDiscount: toDecimal4(totalDiscount),
              totalTax: toDecimal4(totalTax),
              cgstTotal: toDecimal4(cgstTotal),
              sgstTotal: toDecimal4(sgstTotal),
              igstTotal: toDecimal4(igstTotal),
              roundOff: toDecimal4(roundOff),
              totalAmount: toDecimal4(totalAmount),
              paidAmount: toDecimal4(0),
              templateId: payload.templateId ?? null,
              status: "DRAFT",
              paymentStatus: "UNPAID",
              lines: {
                create: linesData
              }
            },
            include: {
              customer: true,
              supplier: true,
              mr: true,
              doctor: true,
              lines: true
            }
          });
          await tx.billAuditVersion.create({
            data: {
              billId: bill.id,
              version: 1,
              action: "CREATE",
              changesJson: JSON.stringify({ billNumber, billType: payload.billType }),
              performedBy: userId ?? null
            }
          });
          const createdBill = mapBill(bill);
          logAuditAsync({
            entity: "Bill",
            entityId: bill.id,
            action: "CREATE",
            userId,
            details: {
              billNumber,
              billType: payload.billType,
              totalAmount: toNumber10(bill.totalAmount)
            }
          });
          return createdBill;
        },
        {
          timeout: 3e4
          // 30 second timeout for complex bill creation
        }
      );
    };
    updateBill = async (id, payload, userId) => {
      const prisma2 = getPrismaClient();
      return prisma2.$transaction(
        async (tx) => {
          const existing = await tx.bill.findUnique({
            where: { id },
            include: { lines: true }
          });
          if (!existing) {
            throw new Error("Bill not found");
          }
          if (existing.status === "FINALIZED") {
            const { validateBillModification: validateBillModification2, overrideBillLock: overrideBillLock2, getChangeDiff: getChangeDiff2 } = await Promise.resolve().then(() => (init_auditLockService(), auditLockService_exports));
            const validation = await validateBillModification2(id, userId, true);
            if (!validation.allowed) {
              throw new Error(validation.reason || "Cannot update finalized bill");
            }
            if (validation.requiresOverride) {
              const oldData = {
                customerId: existing.customerId,
                supplierId: existing.supplierId,
                totalAmount: existing.totalAmount,
                notes: existing.notes,
                remarks: existing.remarks
              };
              const newData = {
                ...oldData,
                ...payload.customerId !== void 0 && { customerId: payload.customerId },
                ...payload.supplierId !== void 0 && { supplierId: payload.supplierId },
                ...payload.notes !== void 0 && { notes: payload.notes },
                ...payload.remarks !== void 0 && { remarks: payload.remarks }
              };
              const diff = getChangeDiff2(oldData, newData);
              await overrideBillLock2(
                id,
                userId,
                "Bill modification after finalization",
                diff
              );
            }
          }
          if (existing.status === "CANCELLED") {
            throw new Error("Cannot update cancelled bill");
          }
          if (payload.lines && payload.lines.length > 0) {
            await tx.billLine.deleteMany({
              where: { billId: id }
            });
            const isInterState = false;
            const linesData = await Promise.all(
              payload.lines.map(async (line, index) => {
                const product = await tx.product.findUnique({
                  where: { id: line.productId }
                });
                if (!product) {
                  throw new Error(`Product with ID ${line.productId} not found`);
                }
                let batch = null;
                if (line.batchId) {
                  batch = await tx.batch.findUnique({
                    where: { id: line.batchId }
                  });
                  if (!batch || batch.productId !== product.id) {
                    throw new Error(`Invalid batch for product ${product.name}`);
                  }
                } else if (product.isBatchManaged) {
                  let actualQuantity2 = line.quantity;
                  const stripQty2 = line.stripQuantity ?? product.stripQuantity ?? 1;
                  if (line.soldInStrips && stripQty2) {
                    actualQuantity2 = line.quantity * stripQty2;
                  }
                  const { allocateFefoBatches: allocateFefoBatches2 } = await Promise.resolve().then(() => (init_fefoService(), fefoService_exports));
                  const fefoResult = await allocateFefoBatches2(
                    tx,
                    product.id,
                    actualQuantity2,
                    void 0,
                    {
                      allowExpired: false,
                      // Block expired batches
                      allowNearExpiry: true,
                      // Allow but warn
                      requireOverride: false
                    }
                  );
                  if (fefoResult.allocations.length > 0) {
                    const allocation = fefoResult.allocations[0];
                    batch = await tx.batch.findUnique({
                      where: { id: allocation.batchId }
                    });
                    if (fefoResult.warnings.length > 0) {
                      console.warn(`FEFO warnings for ${product.name}:`, fefoResult.warnings);
                    }
                  }
                }
                if (product.isBatchManaged && !batch) {
                  throw new Error(`No available batch for product ${product.name}`);
                }
                let actualQuantity = line.quantity;
                const stripQty = line.stripQuantity ?? product.stripQuantity ?? 1;
                if (line.soldInStrips && stripQty) {
                  actualQuantity = line.quantity * stripQty;
                }
                const mrp = batch ? toNumber10(batch.mrp) : 0;
                const ptr = batch ? toNumber10(batch.ptr) : 0;
                const pts = batch ? toNumber10(batch.pts) : 0;
                const rate = line.rate || ptr;
                const taxPercent = batch ? toNumber10(batch.taxPercent) : toNumber10(product.gstRate);
                if (batch && existing.status === "DRAFT") {
                }
                const calculations = calculateLineTotals(
                  mrp,
                  rate,
                  actualQuantity,
                  line.freeQuantity ?? 0,
                  line.discountPercent ?? 0,
                  taxPercent,
                  isInterState
                );
                return {
                  lineNumber: line.lineNumber || index + 1,
                  productId: product.id,
                  batchId: batch?.id ?? null,
                  productName: product.name,
                  hsnCode: product.hsnCode,
                  manufacturer: product.manufacturer,
                  packSize: product.packSize,
                  unitOfMeasure: product.unitOfMeasure,
                  batchNumber: batch?.batchNumber ?? null,
                  expiryDate: batch?.expiryDate ?? null,
                  quantity: actualQuantity,
                  freeQuantity: line.freeQuantity ?? 0,
                  soldInStrips: line.soldInStrips ?? false,
                  stripQuantity: stripQty,
                  mrp: toDecimal4(mrp),
                  ptr: toDecimal4(ptr),
                  pts: pts > 0 ? toDecimal4(pts) : null,
                  rate: toDecimal4(rate),
                  discountPercent: toDecimal4(line.discountPercent ?? 0),
                  discountAmount: toDecimal4(calculations.discountAmount),
                  taxPercent: toDecimal4(taxPercent),
                  cgstPercent: toDecimal4(calculations.cgstPercent),
                  sgstPercent: toDecimal4(calculations.sgstPercent),
                  igstPercent: toDecimal4(calculations.igstPercent),
                  cgstAmount: toDecimal4(calculations.cgstAmount),
                  sgstAmount: toDecimal4(calculations.sgstAmount),
                  igstAmount: toDecimal4(calculations.igstAmount),
                  taxableAmount: toDecimal4(calculations.taxableAmount),
                  lineTotal: toDecimal4(calculations.lineTotal),
                  savingPercent: mrp > 0 ? toDecimal4(calculations.savingPercent) : null,
                  savingValue: toDecimal4(calculations.savingValue)
                };
              })
            );
            const subtotal = linesData.reduce((sum, line) => sum + toNumber10(line.taxableAmount), 0);
            const totalDiscount = linesData.reduce((sum, line) => sum + toNumber10(line.discountAmount), 0);
            const cgstTotal = linesData.reduce((sum, line) => sum + toNumber10(line.cgstAmount), 0);
            const sgstTotal = linesData.reduce((sum, line) => sum + toNumber10(line.sgstAmount), 0);
            const igstTotal = linesData.reduce((sum, line) => sum + toNumber10(line.igstAmount), 0);
            const totalTax = cgstTotal + sgstTotal + igstTotal;
            const totalBeforeRoundOff = subtotal + totalTax;
            const roundOff = Math.round(totalBeforeRoundOff) - totalBeforeRoundOff;
            const totalAmount = totalBeforeRoundOff + roundOff;
            await tx.billLine.createMany({
              data: linesData.map((line) => ({
                billId: id,
                ...line
              }))
            });
            await tx.bill.update({
              where: { id },
              data: {
                subtotal: toDecimal4(subtotal),
                totalDiscount: toDecimal4(totalDiscount),
                totalTax: toDecimal4(totalTax),
                cgstTotal: toDecimal4(cgstTotal),
                sgstTotal: toDecimal4(sgstTotal),
                igstTotal: toDecimal4(igstTotal),
                roundOff: toDecimal4(roundOff),
                totalAmount: toDecimal4(totalAmount),
                ...payload.remarks !== void 0 && { remarks: payload.remarks },
                ...payload.notes !== void 0 && { notes: payload.notes },
                ...payload.challanNumber !== void 0 && { challanNumber: payload.challanNumber },
                ...payload.orderNumber !== void 0 && { orderNumber: payload.orderNumber }
              }
            });
          } else {
            await tx.bill.update({
              where: { id },
              data: {
                ...payload.remarks !== void 0 && { remarks: payload.remarks },
                ...payload.notes !== void 0 && { notes: payload.notes },
                ...payload.challanNumber !== void 0 && { challanNumber: payload.challanNumber },
                ...payload.orderNumber !== void 0 && { orderNumber: payload.orderNumber }
              }
            });
          }
          const currentVersion = await tx.billAuditVersion.findFirst({
            where: { billId: id },
            orderBy: { version: "desc" }
          });
          const nextVersion = (currentVersion?.version ?? 0) + 1;
          await tx.billAuditVersion.create({
            data: {
              billId: id,
              version: nextVersion,
              action: "UPDATE",
              changesJson: JSON.stringify(payload)
            }
          });
          logAuditAsync({
            entity: "Bill",
            entityId: id,
            action: "UPDATE",
            details: { billNumber: existing.billNumber }
          });
          const updated = await tx.bill.findUnique({
            where: { id },
            include: {
              customer: true,
              supplier: true,
              mr: true,
              doctor: true,
              lines: true
            }
          });
          if (!updated) {
            throw new Error("Bill not found after update");
          }
          return mapBill(updated);
        },
        {
          timeout: 15e3
          // 15 second timeout for bill updates with line recalculation
        }
      );
    };
    finalizeBill = async (id, userId) => {
      const prisma2 = getPrismaClient();
      return prisma2.$transaction(
        async (tx) => {
          const bill = await tx.bill.findUnique({
            where: { id },
            include: {
              lines: {
                include: {
                  batch: true,
                  product: true
                }
              }
            }
          });
          if (!bill) {
            throw new Error("Bill not found");
          }
          if (bill.status === "FINALIZED") {
            throw new Error("Bill is already finalized");
          }
          if (bill.status === "CANCELLED") {
            throw new Error("Cannot finalize cancelled bill");
          }
          const { validateBill: validateBill2 } = await Promise.resolve().then(() => (init_validationService(), validationService_exports));
          const validation = await validateBill2({
            billType: bill.billType,
            billDate: bill.billDate,
            customerId: bill.customerId,
            supplierId: bill.supplierId,
            totalAmount: Number(bill.totalAmount),
            lines: bill.lines.map((line) => ({
              productId: line.productId,
              batchId: line.batchId,
              rate: Number(line.rate),
              quantity: line.quantity,
              discountPercent: Number(line.discountPercent),
              mrp: line.batch ? Number(line.batch.mrp) : void 0
            }))
          }, id, userId);
          if (validation.warnings.length > 0) {
            console.warn("Bill validation warnings on finalization:", validation.warnings);
            for (const warning of validation.warnings) {
              logAuditAsync({
                entity: "Bill",
                entityId: id,
                action: "VALIDATION_WARNING",
                userId,
                details: {
                  warningType: warning.type,
                  severity: warning.severity,
                  message: warning.message,
                  billNumber: bill.billNumber
                }
              });
            }
          }
          const { validateBillGSTCompliance: validateBillGSTCompliance2 } = await Promise.resolve().then(() => (init_gstComplianceService(), gstComplianceService_exports));
          const gstValidation = await validateBillGSTCompliance2(id);
          if (!gstValidation.compliant) {
            throw new Error(`GST compliance errors: ${gstValidation.errors.join("; ")}`);
          }
          if (gstValidation.warnings.length > 0) {
            console.warn("GST compliance warnings:", gstValidation.warnings);
          }
          if (bill.billType === "SALES") {
            const { validateBillScheduleCompliance: validateBillScheduleCompliance2 } = await Promise.resolve().then(() => (init_drugScheduleService(), drugScheduleService_exports));
            const scheduleValidation = await validateBillScheduleCompliance2(
              id,
              bill.lines.map((l) => ({ productId: l.productId })),
              bill.doctorId,
              bill.billType
            );
            if (!scheduleValidation.compliant) {
              throw new Error(`Drug schedule compliance errors: ${scheduleValidation.errors.join("; ")}`);
            }
            if (scheduleValidation.warnings.length > 0) {
              console.warn("Drug schedule warnings:", scheduleValidation.warnings);
            }
          }
          for (const line of bill.lines) {
            if (line.product?.isBatchManaged) {
              if (!line.batchId || !line.batch) {
                throw new Error(`Product ${line.productName} requires a batch but none is assigned`);
              }
              if (bill.billType === "SALES" || bill.billType === "CREDIT_NOTE") {
                if (line.quantity > line.batch.quantity) {
                  throw new Error(`Insufficient stock for batch ${line.batch.batchNumber}. Available: ${line.batch.quantity}, Required: ${line.quantity}`);
                }
                const { isBatchExpired: isBatchExpired2, isNearExpiry: isNearExpiry3, getDaysUntilExpiry: getDaysUntilExpiry2 } = await Promise.resolve().then(() => (init_fefoService(), fefoService_exports));
                const expiryDate = line.batch.expiryDate;
                if (isBatchExpired2(expiryDate)) {
                  const daysExpired = Math.abs(getDaysUntilExpiry2(expiryDate));
                  throw new Error(
                    `Cannot sell expired batch ${line.batch.batchNumber}. Expired ${daysExpired} days ago.`
                  );
                }
                if (isNearExpiry3(expiryDate)) {
                  const daysUntil = getDaysUntilExpiry2(expiryDate);
                  console.warn(
                    `\u26A0\uFE0F Near-expiry batch: ${line.batch.batchNumber} expires in ${daysUntil} days`
                  );
                }
              }
            }
          }
          const { createLedgerEntry: createLedgerEntry2 } = await Promise.resolve().then(() => (init_stockLedgerService(), stockLedgerService_exports));
          for (const line of bill.lines) {
            if (line.batchId && line.batch) {
              if (bill.billType === "SALES" || bill.billType === "CREDIT_NOTE") {
                await createLedgerEntry2({
                  productId: line.productId,
                  batchId: line.batchId,
                  movementType: bill.billType === "CREDIT_NOTE" ? "CREDIT_NOTE" : "SALE",
                  reference: bill.billNumber,
                  quantityChange: -line.quantity,
                  narration: `${bill.billType} bill ${bill.billNumber}`,
                  tx
                });
              } else if (bill.billType === "PURCHASE") {
                await createLedgerEntry2({
                  productId: line.productId,
                  batchId: line.batchId,
                  movementType: "PURCHASE",
                  reference: bill.billNumber,
                  quantityChange: line.quantity,
                  narration: `Purchase bill ${bill.billNumber}`,
                  tx
                });
              }
            }
          }
          const finalized = await tx.bill.update({
            where: { id },
            data: {
              status: "FINALIZED",
              finalizedAt: /* @__PURE__ */ new Date(),
              finalizedBy: userId ?? null
            },
            include: {
              customer: true,
              supplier: true,
              mr: true,
              doctor: true,
              lines: true
            }
          });
          const currentVersion = await tx.billAuditVersion.findFirst({
            where: { billId: id },
            orderBy: { version: "desc" }
          });
          const nextVersion = (currentVersion?.version ?? 0) + 1;
          await tx.billAuditVersion.create({
            data: {
              billId: id,
              version: nextVersion,
              action: "FINALIZE",
              performedBy: userId ?? null
            }
          });
          logAuditAsync({
            entity: "Bill",
            entityId: id,
            action: "FINALIZE",
            userId,
            details: { billNumber: bill.billNumber }
          });
          return mapBill(finalized);
        },
        {
          timeout: 3e4
          // Increased to 30s for complex finalization with stock ledger updates
        }
      );
    };
    cancelBill = async (id, reason, userId) => {
      const prisma2 = getPrismaClient();
      return prisma2.$transaction(
        async (tx) => {
          const bill = await tx.bill.findUnique({
            where: { id },
            include: {
              lines: {
                include: {
                  batch: true
                }
              }
            }
          });
          if (!bill) {
            throw new Error("Bill not found");
          }
          if (bill.status === "CANCELLED") {
            throw new Error("Bill is already cancelled");
          }
          const { createLedgerEntry: createLedgerEntry2 } = await Promise.resolve().then(() => (init_stockLedgerService(), stockLedgerService_exports));
          if (bill.status === "FINALIZED") {
            for (const line of bill.lines) {
              if (line.batchId && line.batch) {
                if (bill.billType === "SALES" || bill.billType === "CREDIT_NOTE") {
                  await createLedgerEntry2({
                    productId: line.productId,
                    batchId: line.batchId,
                    movementType: "RETURN",
                    reference: `CANCEL-${bill.billNumber}`,
                    quantityChange: line.quantity,
                    narration: `Cancelled ${bill.billType} bill ${bill.billNumber}`,
                    tx
                  });
                } else if (bill.billType === "PURCHASE") {
                  if (line.batch.quantity < line.quantity) {
                    throw new Error(`Insufficient stock to cancel. Batch ${line.batch.batchNumber} has ${line.batch.quantity}, but bill requires ${line.quantity}`);
                  }
                  await createLedgerEntry2({
                    productId: line.productId,
                    batchId: line.batchId,
                    movementType: "ADJUSTMENT",
                    reference: `CANCEL-${bill.billNumber}`,
                    quantityChange: -line.quantity,
                    narration: `Cancelled purchase bill ${bill.billNumber}`,
                    tx
                  });
                }
              }
            }
          }
          const cancelled = await tx.bill.update({
            where: { id },
            data: {
              status: "CANCELLED",
              cancelledAt: /* @__PURE__ */ new Date(),
              cancelledBy: userId ?? null,
              cancellationReason: reason ?? null
            },
            include: {
              customer: true,
              supplier: true,
              mr: true,
              doctor: true,
              lines: true
            }
          });
          const currentVersion = await tx.billAuditVersion.findFirst({
            where: { billId: id },
            orderBy: { version: "desc" }
          });
          const nextVersion = (currentVersion?.version ?? 0) + 1;
          await tx.billAuditVersion.create({
            data: {
              billId: id,
              version: nextVersion,
              action: "CANCEL",
              performedBy: userId ?? null,
              notes: reason
            }
          });
          logAuditAsync({
            entity: "Bill",
            entityId: id,
            action: "CANCEL",
            userId,
            details: { billNumber: bill.billNumber, reason }
          });
          return mapBill(cancelled);
        },
        {
          timeout: 15e3
          // 15 second timeout for cancellation with stock reversal
        }
      );
    };
    getBillById = async (id) => {
      const prisma2 = getPrismaClient();
      const bill = await safeQuery(
        () => prisma2.bill.findUnique({
          where: { id },
          include: {
            customer: true,
            supplier: true,
            mr: true,
            doctor: true,
            lines: true
          }
        }),
        1e4,
        "getBillById"
      );
      if (!bill) {
        throw new Error("Bill not found");
      }
      return mapBill(bill);
    };
    listBills = async (filters) => {
      const prisma2 = getPrismaClient();
      const page = filters?.page ?? 1;
      const pageSize = filters?.pageSize ?? 50;
      const skip = (page - 1) * pageSize;
      const where = {
        deletedAt: null
        // Exclude deleted bills
      };
      if (filters?.billType) {
        where.billType = filters.billType;
      }
      if (filters?.status) {
        where.status = filters.status;
      }
      if (filters?.customerId) {
        where.customerId = filters.customerId;
      }
      if (filters?.supplierId) {
        where.supplierId = filters.supplierId;
      }
      if (filters?.fromDate || filters?.toDate) {
        where.billDate = {};
        if (filters.fromDate) {
          where.billDate.gte = new Date(filters.fromDate);
        }
        if (filters.toDate) {
          where.billDate.lte = new Date(filters.toDate);
        }
      }
      const [bills, total] = await Promise.all([
        safeQuery(
          () => prisma2.bill.findMany({
            where,
            skip,
            take: pageSize,
            orderBy: { billDate: "desc" },
            include: {
              customer: true,
              supplier: true,
              mr: true,
              doctor: true,
              lines: true
            }
          }),
          15e3,
          "listBills findMany"
        ),
        safeQuery(
          () => prisma2.bill.count({ where }),
          1e4,
          "listBills count"
        )
      ]);
      return {
        bills: bills.map(mapBill),
        total,
        page,
        pageSize,
        totalPages: Math.ceil(total / pageSize)
      };
    };
    deleteBill = async (id, userId, reason, force) => {
      const { safeDeleteBill: safeDeleteBill2 } = await Promise.resolve().then(() => (init_safeDeleteService(), safeDeleteService_exports));
      if (!userId) {
        throw new Error("User ID is required for deletion");
      }
      await safeDeleteBill2(id, { userId, reason, force });
    };
  }
});

// electron/src/templates/defaultTemplateLoader.ts
function loadDefaultA4Template() {
  let htmlPath = path6.join(ROOT_TEMPLATE_DIR, "default-a4-bill.html");
  let cssPath = path6.join(ROOT_TEMPLATE_DIR, "default-a4-bill.css");
  if (!fs5.existsSync(htmlPath)) {
    htmlPath = path6.join(ELECTRON_TEMPLATE_DIR, "default-a4-bill.html");
    cssPath = path6.join(ELECTRON_TEMPLATE_DIR, "default-a4-bill.css");
  }
  const html = fs5.readFileSync(htmlPath, "utf-8");
  const css = fs5.readFileSync(cssPath, "utf-8");
  return { html, css };
}
function getDefaultA4TemplatePlaceholders() {
  return [
    // Company placeholders (both formats)
    "{{company.name}}",
    "{{companyName}}",
    "{{company.address}}",
    "{{address}}",
    "{{company.phone}}",
    "{{phone}}",
    "{{company.email}}",
    "{{email}}",
    "{{company.gstin}}",
    "{{gstin}}",
    "{{company.dlNo}}",
    "{{dlNo1}}",
    "{{dlNo2}}",
    "{{company.fssaiNumber}}",
    "{{fssaiNumber}}",
    "{{company.state}}",
    "{{state}}",
    "{{company.stateCode}}",
    "{{stateCode}}",
    "{{logoPath}}",
    "{{signaturePath}}",
    // Bill placeholders (both formats)
    "{{bill.billNumber}}",
    "{{billNumber}}",
    "{{invoiceNumber}}",
    "{{bill.billDate}}",
    "{{billDate}}",
    "{{invoiceDate}}",
    "{{bill.dueDate}}",
    "{{dueDate}}",
    "{{bill.challanNumber}}",
    "{{challanNumber}}",
    "{{bill.orderNumber}}",
    "{{orderNumber}}",
    "{{bill.remarks}}",
    "{{remarks}}",
    "{{bill.subtotal}}",
    "{{subtotal}}",
    "{{bill.totalDiscount}}",
    "{{totalDiscount}}",
    "{{bill.cgstTotal}}",
    "{{cgstTotal}}",
    "{{bill.sgstTotal}}",
    "{{sgstTotal}}",
    "{{bill.igstTotal}}",
    "{{igstTotal}}",
    "{{bill.roundOff}}",
    "{{roundOff}}",
    "{{bill.totalAmount}}",
    "{{totalAmount}}",
    "{{bill.totalSavingPercent}}",
    "{{totalSavingPercent}}",
    "{{bill.totalSavingValue}}",
    "{{totalSavingValue}}",
    // Customer placeholders (both formats)
    "{{bill.customerName}}",
    "{{customerName}}",
    "{{bill.customerAddress}}",
    "{{customerAddress}}",
    "{{customerAddressLine1}}",
    "{{customerAddressLine2}}",
    "{{customerCity}}",
    "{{customerPostalCode}}",
    "{{bill.customerPhone}}",
    "{{customerPhone}}",
    "{{bill.customerEmail}}",
    "{{customerEmail}}",
    "{{bill.customerGstin}}",
    "{{customerGstin}}",
    "{{customerPanNumber}}",
    "{{customerDlNo}}",
    "{{customerDlNo2}}",
    "{{customerState}}",
    "{{customerStateCode}}",
    // Line items (both formats)
    "{{#each bill.lines}}",
    "{{#each lines}}",
    "{{this.lineNumber}}",
    "{{lineNumber}}",
    "{{this.loc}}",
    "{{loc}}",
    "{{this.hsnCode}}",
    "{{hsnCode}}",
    "{{this.productName}}",
    "{{productName}}",
    "{{this.manufacturer}}",
    "{{manufacturer}}",
    "{{this.batchNumber}}",
    "{{batchNumber}}",
    "{{this.expiryDate}}",
    "{{expiryDate}}",
    "{{this.packSize}}",
    "{{packSize}}",
    "{{this.mrp}}",
    "{{mrp}}",
    "{{this.rate}}",
    "{{rate}}",
    "{{this.quantity}}",
    "{{quantity}}",
    "{{this.freeQuantity}}",
    "{{freeQuantity}}",
    "{{this.discountPercent}}",
    "{{discountPercent}}",
    "{{this.taxPercent}}",
    "{{taxPercent}}",
    "{{this.cgstAmount}}",
    "{{cgstAmount}}",
    "{{this.sgstAmount}}",
    "{{sgstAmount}}",
    "{{this.taxableAmount}}",
    "{{taxableAmount}}",
    "{{this.lineTotal}}",
    "{{lineTotal}}",
    "{{/each}}",
    // GST Summary
    "{{#each bill.gstSummary}}",
    "{{this.rate}}",
    "{{cgstRate}}",
    "{{sgstRate}}",
    "{{this.taxable}}",
    "{{taxable}}",
    "{{this.cgst}}",
    "{{cgst}}",
    "{{this.sgst}}",
    "{{sgst}}",
    "{{this.total}}",
    "{{total}}",
    "{{/each}}",
    // Format helpers
    "{{formatCurrency",
    "{{numberToWords",
    // CSS injection
    "{{cssContent}}",
    // Handlebars helpers
    "{{#if",
    "{{#each",
    "{{/if}}",
    "{{/each}}",
    "{{else}}"
  ];
}
var fs5, path6, ROOT_TEMPLATE_DIR, ELECTRON_TEMPLATE_DIR;
var init_defaultTemplateLoader = __esm({
  "electron/src/templates/defaultTemplateLoader.ts"() {
    "use strict";
    fs5 = __toESM(require("fs"));
    path6 = __toESM(require("path"));
    ROOT_TEMPLATE_DIR = path6.join(process.cwd(), "templates");
    ELECTRON_TEMPLATE_DIR = path6.join(__dirname, "templates");
  }
});

// electron/src/services/billTemplateLayoutService.ts
function validateLayoutJson(layout) {
  const errors = [];
  const warnings = [];
  if (!layout || typeof layout !== "object") {
    errors.push("Layout must be an object");
    return { valid: false, errors, warnings };
  }
  if (!layout.meta) {
    errors.push("Layout is missing meta section");
  }
  if (!Array.isArray(layout.blocks)) {
    errors.push("Layout blocks must be an array");
  }
  return {
    valid: errors.length === 0,
    errors,
    warnings
  };
}
function generateHtmlFromLayout(layout) {
  const pageTitle = "Invoice";
  const css = `@page { margin: 10mm; }
@media print {
  body { -webkit-print-color-adjust: exact; }
}
body {
  font-family: ${layout.meta.fontFamily || 'system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif'};
  font-size: ${layout.meta.baseFontSize || 11}px;
  line-height: ${layout.meta.lineHeight || 1.2};
}
.table {
  width: 100%;
  border-collapse: collapse;
}
.table th, .table td {
  border: 1px solid #000;
  padding: 2px 4px;
  font-size: inherit;
}
.header {
  text-align: center;
  margin-bottom: 4px;
  font-weight: 600;
}
.footer {
  margin-top: 8px;
  font-size: 0.85em;
}`;
  const html = `<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>${pageTitle}</title>
  <style>{{cssContent}}</style>
</head>
<body>
  <div class="header">{{companyName}}<br/>TAX INVOICE</div>

  <table class="table">
    <tr>
      <td>
        <strong>Buyer:</strong><br/>
        {{customerName}}<br/>
        {{customerAddress}}<br/>
        GSTIN: {{customerGstin}}
      </td>
      <td>
        <strong>Invoice No:</strong> {{billNumber}}<br/>
        <strong>Date:</strong> {{billDate}}<br/>
        <strong>Challan:</strong> {{challanNumber}}<br/>
        <strong>Order No:</strong> {{orderNumber}}
      </td>
    </tr>
  </table>

  <table class="table" style="margin-top: 4px;">
    <thead>
      <tr>
        <th>Sr</th>
        <th>HSN</th>
        <th>Product</th>
        <th>Batch</th>
        <th>Expiry</th>
        <th>Qty</th>
        <th>Rate</th>
        <th>GST %</th>
        <th>Amount</th>
      </tr>
    </thead>
    <tbody>
      {{#each bill.lines}}
      <tr>
        <td>{{lineNumber}}</td>
        <td>{{hsnCode}}</td>
        <td>{{productName}}</td>
        <td>{{batchNumber}}</td>
        <td>{{expiryDate}}</td>
        <td>{{quantity}}</td>
        <td>{{rate}}</td>
        <td>{{taxPercent}}</td>
        <td>{{lineTotal}}</td>
      </tr>
      {{/each}}
    </tbody>
  </table>

  <table class="table" style="margin-top: 4px;">
    <tr>
      <td style="width: 60%;">
        Amount in words: {{numberToWords totalAmount}}
      </td>
      <td>
        Subtotal: {{subtotal}}<br/>
        Discount: {{totalDiscount}}<br/>
        Tax: {{totalTax}}<br/>
        Round Off: {{roundOff}}<br/>
        <strong>Net Amount: {{totalAmount}}</strong>
      </td>
    </tr>
  </table>

  <div class="footer">
    Subject to jurisdiction. E. & O.E.
  </div>
</body>
</html>`;
  return { html, css };
}
var init_billTemplateLayoutService = __esm({
  "electron/src/services/billTemplateLayoutService.ts"() {
    "use strict";
  }
});

// electron/src/services/templateCache.ts
var templateCache_exports = {};
__export(templateCache_exports, {
  getCachedTemplates: () => getCachedTemplates,
  invalidateTemplateCache: () => invalidateTemplateCache,
  setCachedTemplates: () => setCachedTemplates
});
var templateCache, CACHE_TTL, getCachedTemplates, setCachedTemplates, invalidateTemplateCache;
var init_templateCache = __esm({
  "electron/src/services/templateCache.ts"() {
    "use strict";
    templateCache = {
      templates: [],
      lastUpdated: null,
      cacheKey: "all"
    };
    CACHE_TTL = 5 * 60 * 1e3;
    getCachedTemplates = (cacheKey = "all") => {
      if (templateCache.cacheKey === cacheKey && templateCache.lastUpdated) {
        const age = Date.now() - templateCache.lastUpdated.getTime();
        if (age < CACHE_TTL) {
          return templateCache.templates;
        }
      }
      return null;
    };
    setCachedTemplates = (templates, cacheKey = "all") => {
      templateCache = {
        templates,
        lastUpdated: /* @__PURE__ */ new Date(),
        cacheKey
      };
    };
    invalidateTemplateCache = () => {
      templateCache = {
        templates: [],
        lastUpdated: null,
        cacheKey: "all"
      };
    };
  }
});

// electron/src/services/templateValidationService.ts
var templateValidationService_exports = {};
__export(templateValidationService_exports, {
  cloneTemplate: () => cloneTemplate,
  getTemplateVersions: () => getTemplateVersions,
  isSystemTemplate: () => isSystemTemplate,
  restoreTemplateVersion: () => restoreTemplateVersion,
  validateTemplate: () => validateTemplate,
  validateTemplateCSS: () => validateTemplateCSS,
  validateTemplatePlaceholders: () => validateTemplatePlaceholders,
  validateTemplateStructure: () => validateTemplateStructure
});
function validateTemplateStructure(htmlContent) {
  const errors = [];
  const warnings = [];
  if (!htmlContent.includes("<table") && !htmlContent.includes("<TABLE")) {
    warnings.push("Template should use table-based layout for proper alignment");
  }
  if (!htmlContent.includes("@media print") && !htmlContent.includes("@page")) {
    warnings.push("Template should include print media queries for better printing");
  }
  const backgroundColorMatches = htmlContent.match(/background.*color|bgcolor/gi);
  if (backgroundColorMatches && backgroundColorMatches.length > 5) {
    warnings.push("Template has many background colors. Consider using minimal colors for printing");
  }
  if (!htmlContent.includes("<!DOCTYPE") && !htmlContent.includes("<html")) {
    errors.push("Template must be valid HTML");
  }
  return {
    valid: errors.length === 0,
    errors,
    warnings
  };
}
function hasAnyAlias(content, aliases) {
  return aliases.some((alias) => content.includes(alias));
}
function validateTemplatePlaceholders(htmlContent) {
  const errors = [];
  const warnings = [];
  const missingFields = [];
  for (const [logicalField, aliases] of Object.entries(LOGICAL_FIELDS)) {
    if (!hasAnyAlias(htmlContent, aliases)) {
      missingFields.push(logicalField);
      warnings.push(`Recommended field missing: ${logicalField} (accepts: ${aliases.slice(0, 2).join(", ")}...)`);
    }
  }
  for (const field of RECOMMENDED_FIELDS) {
    if (!hasAnyAlias(htmlContent, field.aliases)) {
      warnings.push(`Recommended placeholder missing: ${field.logical} (for GST compliance)`);
    }
  }
  const placeholderRegex = /\{\{[^}]+\}\}/g;
  const placeholders = htmlContent.match(placeholderRegex) || [];
  const validPlaceholders = getDefaultA4TemplatePlaceholders();
  for (const placeholder of placeholders) {
    if (placeholder.startsWith("{{#") || placeholder.startsWith("{{/") || placeholder.startsWith("{{if") || placeholder.startsWith("{{else") || placeholder.startsWith("{{!") || placeholder.includes("formatCurrency") || placeholder.includes("numberToWords")) {
      continue;
    }
    const isValid = validPlaceholders.some((vp) => {
      if (placeholder === vp) return true;
      if (vp.includes("{{this.") && placeholder.includes("{{this.")) {
        return true;
      }
      if (vp.includes("formatCurrency") && placeholder.includes("formatCurrency")) {
        return true;
      }
      if (vp.includes("numberToWords") && placeholder.includes("numberToWords")) {
        return true;
      }
      return false;
    });
    if (!isValid) {
      if (!placeholder.includes("formatCurrency") && !placeholder.includes("numberToWords")) {
        warnings.push(`Unknown placeholder: ${placeholder}`);
      }
    }
  }
  return {
    valid: true,
    // Always valid - warnings don't block
    errors: [],
    // No hard errors
    warnings,
    missingFields
  };
}
function validateTemplateCSS(cssContent) {
  const errors = [];
  const warnings = [];
  if (!cssContent.includes("@media print") && !cssContent.includes("@page")) {
    warnings.push("CSS should include print media queries");
  }
  const bgColorMatches = cssContent.match(/background.*color|background-color/gi);
  if (bgColorMatches && bgColorMatches.length > 10) {
    warnings.push("CSS has many background colors. Consider minimal colors for printing");
  }
  if (!cssContent.includes("table") && !cssContent.includes("border")) {
    warnings.push("CSS should include table styling for proper bill layout");
  }
  return {
    valid: errors.length === 0,
    errors,
    warnings
  };
}
function validateTemplate(htmlContent, cssContent) {
  const structureValidation = validateTemplateStructure(htmlContent);
  const placeholderValidation = validateTemplatePlaceholders(htmlContent);
  const cssValidation = validateTemplateCSS(cssContent);
  const allErrors = [
    ...structureValidation.errors,
    // Only structural errors (invalid HTML)
    ...cssValidation.errors
    // Only CSS errors (invalid CSS)
    // Placeholder validation never produces errors
  ];
  const allWarnings = [
    ...structureValidation.warnings,
    ...placeholderValidation.warnings,
    ...cssValidation.warnings
  ];
  if (allWarnings.length > 0) {
    const { logger: logger2 } = (init_logger(), __toCommonJS(logger_exports));
    logger2.warn("Template validation warnings", { warnings: allWarnings });
  }
  return {
    valid: allErrors.length === 0,
    // Only structural/CSS errors block
    errors: allErrors,
    warnings: allWarnings,
    missingFields: placeholderValidation.missingFields
  };
}
async function isSystemTemplate(templateId) {
  const prisma2 = getPrismaClient();
  const template = await prisma2.billTemplate.findUnique({
    where: { id: templateId },
    select: { name: true, createdBy: true }
  });
  if (!template) {
    return false;
  }
  return template.createdBy === null || template.name.startsWith("System:");
}
async function cloneTemplate(sourceTemplateId, newName, userId) {
  const prisma2 = getPrismaClient();
  const { createBillTemplate: createBillTemplate2 } = await Promise.resolve().then(() => (init_billTemplateService(), billTemplateService_exports));
  const sourceTemplate = await prisma2.billTemplate.findUnique({
    where: { id: sourceTemplateId }
  });
  if (!sourceTemplate) {
    throw new Error("Source template not found");
  }
  const cloned = await createBillTemplate2({
    name: newName,
    description: `Cloned from: ${sourceTemplate.name}`,
    templateType: sourceTemplate.templateType,
    isDefault: false,
    htmlContent: sourceTemplate.htmlContent,
    cssContent: sourceTemplate.cssContent,
    placeholders: sourceTemplate.placeholders ? JSON.parse(sourceTemplate.placeholders) : void 0
  }, userId);
  return cloned.id;
}
async function getTemplateVersions(templateId) {
  const prisma2 = getPrismaClient();
  const versions = await prisma2.billTemplateVersion.findMany({
    where: { templateId },
    include: {
      createdByUser: {
        select: { fullName: true }
      }
    },
    orderBy: { version: "desc" }
  });
  return versions.map((v) => ({
    version: v.version,
    createdAt: v.createdAt,
    createdBy: v.createdBy,
    createdByUser: v.createdByUser?.fullName || null,
    changeNotes: v.changeNotes
  }));
}
async function restoreTemplateVersion(templateId, version, userId) {
  const prisma2 = getPrismaClient();
  const { updateBillTemplate: updateBillTemplate2 } = await Promise.resolve().then(() => (init_billTemplateService(), billTemplateService_exports));
  const versionData = await prisma2.billTemplateVersion.findUnique({
    where: {
      templateId_version: {
        templateId,
        version
      }
    }
  });
  if (!versionData) {
    throw new Error("Template version not found");
  }
  const isSystem = await isSystemTemplate(templateId);
  if (isSystem) {
    throw new Error("Cannot restore system template. Clone it first to create a user template.");
  }
  await updateBillTemplate2(
    templateId,
    {
      htmlContent: versionData.htmlContent,
      cssContent: versionData.cssContent
    },
    userId
  );
}
var LOGICAL_FIELDS, RECOMMENDED_FIELDS;
var init_templateValidationService = __esm({
  "electron/src/services/templateValidationService.ts"() {
    "use strict";
    init_prismaClient();
    init_defaultTemplateLoader();
    LOGICAL_FIELDS = {
      billNumber: [
        "{{bill.billNumber}}",
        "{{billNumber}}",
        "{{invoice.number}}",
        "{{number}}",
        "{{bill.invoiceNumber}}",
        "{{invoiceNumber}}"
      ],
      billDate: [
        "{{bill.billDate}}",
        "{{billDate}}",
        "{{invoice.date}}",
        "{{date}}",
        "{{bill.invoiceDate}}",
        "{{invoiceDate}}"
      ],
      totalAmount: [
        "{{bill.totalAmount}}",
        "{{totalAmount}}",
        "{{invoice.total}}",
        "{{total}}",
        "{{bill.grandTotal}}",
        "{{grandTotal}}"
      ],
      linesLoop: [
        "{{#each bill.lines}}",
        "{{#each lines}}",
        "{{#each items}}",
        "{{#each bill.items}}",
        "{{#each invoice.lines}}"
      ],
      productName: [
        "{{this.productName}}",
        "{{productName}}",
        "{{this.name}}",
        "{{name}}",
        "{{this.itemName}}",
        "{{itemName}}"
      ],
      quantity: [
        "{{this.quantity}}",
        "{{quantity}}",
        "{{this.qty}}",
        "{{qty}}"
      ],
      rate: [
        "{{this.rate}}",
        "{{rate}}",
        "{{this.price}}",
        "{{price}}",
        "{{this.unitPrice}}",
        "{{unitPrice}}"
      ],
      lineTotal: [
        "{{this.lineTotal}}",
        "{{lineTotal}}",
        "{{this.amount}}",
        "{{amount}}",
        "{{this.total}}",
        "{{total}}"
      ]
    };
    RECOMMENDED_FIELDS = [
      { logical: "companyName", aliases: ["{{company.name}}", "{{companyName}}", "{{company.name}}"] },
      { logical: "companyGstin", aliases: ["{{company.gstin}}", "{{gstin}}", "{{company.gstNumber}}"] },
      { logical: "customerName", aliases: ["{{bill.customerName}}", "{{customerName}}", "{{customer.name}}"] },
      { logical: "customerGstin", aliases: ["{{bill.customerGstin}}", "{{customerGstin}}", "{{customer.gstin}}"] },
      { logical: "hsnCode", aliases: ["{{this.hsnCode}}", "{{hsnCode}}", "{{this.hsn}}"] },
      { logical: "cgstTotal", aliases: ["{{bill.cgstTotal}}", "{{cgstTotal}}", "{{cgst}}"] },
      { logical: "sgstTotal", aliases: ["{{bill.sgstTotal}}", "{{sgstTotal}}", "{{sgst}}"] },
      { logical: "igstTotal", aliases: ["{{bill.igstTotal}}", "{{igstTotal}}", "{{igst}}"] }
    ];
  }
});

// electron/src/services/billTemplateService.ts
var billTemplateService_exports = {};
__export(billTemplateService_exports, {
  cloneBillTemplate: () => cloneBillTemplate,
  createBillTemplate: () => createBillTemplate,
  deleteBillTemplate: () => deleteBillTemplate,
  getBillTemplateById: () => getBillTemplateById,
  getDefaultBillTemplate: () => getDefaultBillTemplate,
  initializeDefaultTemplate: () => initializeDefaultTemplate,
  listBillTemplates: () => listBillTemplates,
  setDefaultBillTemplate: () => setDefaultBillTemplate,
  updateBillTemplate: () => updateBillTemplate
});
var import_client18, mapBillTemplate, listBillTemplates, getBillTemplateById, getDefaultBillTemplate, createBillTemplate, updateBillTemplate, deleteBillTemplate, setDefaultBillTemplate, cloneBillTemplate, initializeDefaultTemplate;
var init_billTemplateService = __esm({
  "electron/src/services/billTemplateService.ts"() {
    "use strict";
    import_client18 = require("@prisma/client");
    init_prismaClient();
    init_auditService();
    init_defaultTemplateLoader();
    init_billTemplateLayoutService();
    mapBillTemplate = (template) => ({
      id: template.id,
      name: template.name,
      description: template.description ?? void 0,
      templateType: template.templateType,
      isDefault: template.isDefault,
      version: template.version,
      htmlContent: template.htmlContent,
      cssContent: template.cssContent,
      placeholders: template.placeholders ? JSON.parse(template.placeholders) : void 0,
      isActive: template.isActive,
      createdAt: template.createdAt.toISOString(),
      updatedAt: template.updatedAt.toISOString(),
      createdBy: template.createdBy ?? void 0,
      updatedBy: template.updatedBy ?? void 0,
      layoutJson: template.layoutJson ?? void 0,
      generatedHtml: template.generatedHtml ?? void 0,
      editorMode: template.editorMode ?? "VISUAL",
      isSystem: template.createdBy === null || template.name.startsWith("System:")
    });
    listBillTemplates = async (filters) => {
      const { getCachedTemplates: getCachedTemplates2, setCachedTemplates: setCachedTemplates2 } = await Promise.resolve().then(() => (init_templateCache(), templateCache_exports));
      const cacheKey = filters?.templateType || "all";
      const cached = getCachedTemplates2(cacheKey);
      if (cached) {
        if (filters?.templateType) {
          return cached.filter((t) => t.templateType === filters.templateType);
        }
        return cached;
      }
      const prisma2 = getPrismaClient();
      const templates = await prisma2.billTemplate.findMany({
        where: {
          isActive: true,
          ...filters?.templateType && { templateType: filters.templateType }
        },
        orderBy: [
          { isDefault: "desc" },
          { createdAt: "desc" }
        ]
      });
      const mapped = templates.map(mapBillTemplate);
      setCachedTemplates2(mapped, cacheKey);
      return mapped;
    };
    getBillTemplateById = async (id) => {
      const prisma2 = getPrismaClient();
      const template = await prisma2.billTemplate.findUnique({
        where: { id }
      });
      if (!template) {
        throw new Error("Template not found");
      }
      return mapBillTemplate(template);
    };
    getDefaultBillTemplate = async (templateType = "A4") => {
      const prisma2 = getPrismaClient();
      const template = await prisma2.billTemplate.findFirst({
        where: {
          templateType,
          isDefault: true,
          isActive: true
        }
      });
      if (!template) {
        return null;
      }
      return mapBillTemplate(template);
    };
    createBillTemplate = async (payload, userId) => {
      if (!payload.name || !payload.htmlContent) {
        throw new Error("Name and HTML content are required");
      }
      const cssContent = payload.cssContent || "";
      const { validateTemplate: validateTemplate2 } = await Promise.resolve().then(() => (init_templateValidationService(), templateValidationService_exports));
      const validation = validateTemplate2(payload.htmlContent, payload.cssContent);
      if (!validation.valid) {
        throw new Error(`Template validation failed: ${validation.errors.join("; ")}`);
      }
      if (validation.warnings.length > 0) {
        const { logger: logger2 } = (init_logger(), __toCommonJS(logger_exports));
        logger2.warn("Template validation warnings (template will be saved)", {
          warnings: validation.warnings,
          missingFields: validation.missingFields
        });
      }
      const prisma2 = getPrismaClient();
      return prisma2.$transaction(
        async (tx) => {
          if (payload.isDefault) {
            await tx.billTemplate.updateMany({
              where: {
                templateType: payload.templateType,
                isDefault: true
              },
              data: {
                isDefault: false
              }
            });
          }
          let htmlContent = payload.htmlContent;
          let finalCssContent = cssContent;
          let layoutJson = null;
          let generatedHtml = null;
          let editorMode = payload.editorMode ?? "VISUAL";
          if (payload.layoutJson) {
            const layoutValidation = validateLayoutJson(payload.layoutJson);
            if (!layoutValidation.valid) {
              throw new Error(`Layout validation failed: ${layoutValidation.errors.join("; ")}`);
            }
            const generated = generateHtmlFromLayout(payload.layoutJson);
            htmlContent = generated.html;
            finalCssContent = generated.css;
            layoutJson = payload.layoutJson;
            generatedHtml = generated.html;
            editorMode = editorMode || "VISUAL";
          }
          const template = await tx.billTemplate.create({
            data: {
              name: payload.name,
              description: payload.description,
              templateType: payload.templateType,
              isDefault: payload.isDefault ?? false,
              htmlContent,
              cssContent: finalCssContent,
              // The following fields are present in the Prisma schema; cast is to satisfy older generated types
              layoutJson,
              generatedHtml,
              editorMode,
              placeholders: payload.placeholders ? JSON.stringify(payload.placeholders) : null,
              isActive: true,
              version: 1,
              createdBy: userId ?? null
            }
          });
          await tx.billTemplateVersion.create({
            data: {
              templateId: template.id,
              version: 1,
              htmlContent,
              cssContent: finalCssContent,
              layoutJson: layoutJson ? JSON.stringify(layoutJson) : null,
              generatedHtml,
              changeNotes: "Initial version",
              createdBy: userId ?? null
            }
          });
          const { logAuditAsync: logAuditAsync2 } = await Promise.resolve().then(() => (init_auditService(), auditService_exports));
          logAuditAsync2({
            entity: "BillTemplate",
            entityId: template.id,
            action: "CREATE",
            userId,
            details: { name: payload.name, templateType: payload.templateType }
          });
          const result = mapBillTemplate(template);
          const { invalidateTemplateCache: invalidateTemplateCache2 } = await Promise.resolve().then(() => (init_templateCache(), templateCache_exports));
          invalidateTemplateCache2();
          return result;
        },
        { timeout: 1e4 }
      );
    };
    updateBillTemplate = async (id, payload, userId) => {
      const prisma2 = getPrismaClient();
      return prisma2.$transaction(
        async (tx) => {
          const existing = await tx.billTemplate.findUnique({
            where: { id }
          });
          if (!existing) {
            throw new Error("Template not found");
          }
          const { isSystemTemplate: isSystemTemplate2 } = await Promise.resolve().then(() => (init_templateValidationService(), templateValidationService_exports));
          const isSystem = await isSystemTemplate2(id);
          if (isSystem) {
            throw new Error("Cannot update system template. Clone it first to create a user template.");
          }
          if (payload.htmlContent || payload.cssContent || payload.layoutJson) {
            const existingAny = existing;
            let nextHtmlContent = payload.htmlContent ?? existingAny.htmlContent;
            let nextCssContent = payload.cssContent ?? existingAny.cssContent;
            let nextLayoutJson = existingAny.layoutJson;
            let nextGeneratedHtml = existingAny.generatedHtml;
            if (payload.layoutJson) {
              const layoutValidation = validateLayoutJson(payload.layoutJson);
              if (!layoutValidation.valid) {
                throw new Error(`Layout validation failed: ${layoutValidation.errors.join("; ")}`);
              }
              const generated = generateHtmlFromLayout(payload.layoutJson);
              nextHtmlContent = generated.html;
              nextCssContent = generated.css;
              nextLayoutJson = payload.layoutJson;
              nextGeneratedHtml = generated.html;
            }
            const { validateTemplate: validateTemplate2 } = await Promise.resolve().then(() => (init_templateValidationService(), templateValidationService_exports));
            const validation = validateTemplate2(nextHtmlContent, nextCssContent);
            if (!validation.valid) {
              throw new Error(`Template validation failed: ${validation.errors.join("; ")}`);
            }
            if (validation.warnings.length > 0) {
              const { logger: logger2 } = (init_logger(), __toCommonJS(logger_exports));
              logger2.warn("Template validation warnings (template will be updated)", {
                warnings: validation.warnings,
                missingFields: validation.missingFields
              });
            }
          }
          if (payload.isDefault) {
            await tx.billTemplate.updateMany({
              where: {
                templateType: existing.templateType,
                isDefault: true,
                id: { not: id }
              },
              data: {
                isDefault: false
              }
            });
          }
          const currentVersion = await tx.billTemplateVersion.findFirst({
            where: { templateId: id },
            orderBy: { version: "desc" }
          });
          const nextVersion = (currentVersion?.version ?? 0) + 1;
          const contentChanged = !!(payload.htmlContent || payload.cssContent || payload.layoutJson);
          if (contentChanged) {
            const latestHtml = payload.layoutJson ? generateHtmlFromLayout(payload.layoutJson).html : payload.htmlContent ?? existing.htmlContent;
            const latestCss = payload.layoutJson ? generateHtmlFromLayout(payload.layoutJson).css : payload.cssContent ?? existing.cssContent;
            await tx.billTemplateVersion.create({
              data: {
                templateId: id,
                version: nextVersion,
                htmlContent: latestHtml,
                cssContent: latestCss,
                layoutJson: payload.layoutJson ?? existing.layoutJson ? JSON.stringify(payload.layoutJson ?? existing.layoutJson) : null,
                generatedHtml: payload.layoutJson ? latestHtml : existing.generatedHtml,
                changeNotes: "Template updated",
                createdBy: userId ?? null
              }
            });
          }
          const updated = await tx.billTemplate.update({
            where: { id },
            data: {
              ...payload.name !== void 0 && { name: payload.name },
              ...payload.description !== void 0 && { description: payload.description },
              ...payload.isDefault !== void 0 && { isDefault: payload.isDefault },
              ...payload.htmlContent !== void 0 && { htmlContent: payload.htmlContent },
              ...payload.cssContent !== void 0 && { cssContent: payload.cssContent },
              ...payload.placeholders !== void 0 && {
                placeholders: payload.placeholders ? JSON.stringify(payload.placeholders) : null
              },
              ...payload.layoutJson !== void 0 && { layoutJson: payload.layoutJson },
              ...payload.layoutJson !== void 0 && {
                generatedHtml: payload.layoutJson ? generateHtmlFromLayout(payload.layoutJson).html : existing.generatedHtml
              },
              ...contentChanged && { version: nextVersion },
              updatedBy: userId ?? null
            }
          });
          const { logAuditAsync: logAuditAsync2 } = await Promise.resolve().then(() => (init_auditService(), auditService_exports));
          logAuditAsync2({
            entity: "BillTemplate",
            entityId: id,
            action: "UPDATE",
            userId,
            details: { name: existing.name }
          });
          const result = mapBillTemplate(updated);
          const { invalidateTemplateCache: invalidateTemplateCache2 } = await Promise.resolve().then(() => (init_templateCache(), templateCache_exports));
          invalidateTemplateCache2();
          return result;
        },
        { timeout: 1e4 }
      );
    };
    deleteBillTemplate = async (id) => {
      const prisma2 = getPrismaClient();
      const template = await prisma2.billTemplate.findUnique({
        where: { id }
      });
      if (!template) {
        throw new Error("Template not found");
      }
      const { isSystemTemplate: isSystemTemplate2 } = await Promise.resolve().then(() => (init_templateValidationService(), templateValidationService_exports));
      const isSystem = await isSystemTemplate2(id);
      if (isSystem) {
        throw new Error("Cannot delete system template");
      }
      if (template.isDefault) {
        throw new Error("Cannot delete default template. Set another template as default first.");
      }
      await prisma2.billTemplate.update({
        where: { id },
        data: {
          isActive: false
        }
      });
      logAuditAsync({
        entity: "BillTemplate",
        entityId: id,
        action: "DELETE",
        details: { name: template.name }
      });
    };
    setDefaultBillTemplate = async (id) => {
      const prisma2 = getPrismaClient();
      return prisma2.$transaction(
        async (tx) => {
          const template = await tx.billTemplate.findUnique({
            where: { id }
          });
          if (!template) {
            throw new Error("Template not found");
          }
          await tx.billTemplate.updateMany({
            where: {
              templateType: template.templateType,
              isDefault: true,
              id: { not: id }
            },
            data: {
              isDefault: false
            }
          });
          const updated = await tx.billTemplate.update({
            where: { id },
            data: {
              isDefault: true
            }
          });
          logAuditAsync({
            entity: "BillTemplate",
            entityId: id,
            action: "SET_DEFAULT",
            details: { name: template.name }
          });
          const result = mapBillTemplate(updated);
          const { invalidateTemplateCache: invalidateTemplateCache2 } = await Promise.resolve().then(() => (init_templateCache(), templateCache_exports));
          invalidateTemplateCache2();
          return result;
        },
        { timeout: 1e4 }
      );
    };
    cloneBillTemplate = async (id, name, userId) => {
      const prisma2 = getPrismaClient();
      const source = await prisma2.billTemplate.findUnique({
        where: { id }
      });
      if (!source) {
        throw new Error("Template not found");
      }
      return createBillTemplate({
        name,
        description: `Cloned from ${source.name}`,
        templateType: source.templateType,
        htmlContent: source.htmlContent,
        cssContent: source.cssContent,
        placeholders: source.placeholders ? JSON.parse(source.placeholders) : void 0,
        isDefault: false
      }, userId);
    };
    initializeDefaultTemplate = async (userId) => {
      const prisma2 = getPrismaClient();
      const originalExists = await prisma2.billTemplate.findFirst({
        where: { name: "Original Template", isActive: true }
      });
      if (!originalExists) {
        const { html, css } = loadDefaultA4Template();
        const placeholders = getDefaultA4TemplatePlaceholders();
        await createBillTemplate({
          name: "Original Template",
          description: "Original bill template restored from default template",
          templateType: "A4",
          htmlContent: html,
          cssContent: css,
          placeholders,
          isDefault: true
        }, userId);
      } else {
        const defaultExists = await prisma2.billTemplate.findFirst({
          where: { isDefault: true, isActive: true }
        });
        if (!defaultExists) {
          await prisma2.billTemplate.update({
            where: { id: originalExists.id },
            data: { isDefault: true }
          });
        }
      }
      const ultraFastExists = await prisma2.billTemplate.findFirst({
        where: { name: "Ultra-Fast", isActive: true }
      });
      if (!ultraFastExists) {
        const { html, css } = loadDefaultA4Template();
        const placeholders = getDefaultA4TemplatePlaceholders();
        await createBillTemplate({
          name: "Ultra-Fast",
          description: "Ultra-fast pharma-style bill template matching reference photos exactly",
          templateType: "A4",
          htmlContent: html,
          cssContent: css,
          placeholders,
          isDefault: false
        }, userId);
      }
      const standardExists = await prisma2.billTemplate.findFirst({
        where: { name: "Standard Detailed Invoice", isActive: true }
      });
      if (!standardExists) {
        const { html, css } = loadDefaultA4Template();
        const placeholders = getDefaultA4TemplatePlaceholders();
        await createBillTemplate({
          name: "Standard Detailed Invoice",
          description: "Standard detailed invoice with comprehensive item and tax breakdown",
          templateType: "A4",
          htmlContent: html,
          cssContent: css,
          placeholders,
          isDefault: false
        }, userId);
      }
      const detailedGstExists = await prisma2.billTemplate.findFirst({
        where: { name: "Detailed GST Template", isActive: true }
      });
      if (!detailedGstExists) {
        const { html, css } = loadDefaultA4Template();
        const placeholders = getDefaultA4TemplatePlaceholders();
        await createBillTemplate({
          name: "Detailed GST Template",
          description: "Detailed GST-compliant invoice with comprehensive tax breakdown and HSN codes",
          templateType: "A4",
          htmlContent: html,
          cssContent: css,
          placeholders,
          isDefault: false
        }, userId);
      }
      const pharmaExists = await prisma2.billTemplate.findFirst({
        where: { name: "Pharma-Style", isActive: true }
      });
      if (!pharmaExists) {
        const { html, css } = loadDefaultA4Template();
        const placeholders = getDefaultA4TemplatePlaceholders();
        await createBillTemplate({
          name: "Pharma-Style",
          description: "Pharma-style bill template with table layout, headers, spacing matching reference photos",
          templateType: "A4",
          htmlContent: html,
          cssContent: css,
          placeholders,
          isDefault: false
        }, userId);
      }
      const simpleFastExists = await prisma2.billTemplate.findFirst({
        where: { name: "Simple Fast Template", isActive: true }
      });
      if (!simpleFastExists) {
        const { html, css } = loadDefaultA4Template();
        const placeholders = getDefaultA4TemplatePlaceholders();
        await createBillTemplate({
          name: "Simple Fast Template",
          description: "Simple and fast template for quick billing",
          templateType: "A4",
          htmlContent: html,
          cssContent: css,
          placeholders,
          isDefault: false
        }, userId);
      }
      const thermalExists = await prisma2.billTemplate.findFirst({
        where: { name: "Thermal (80mm)", isActive: true }
      });
      if (!thermalExists) {
        const thermalHtml = `<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Thermal Bill</title>
  <style>{{cssContent}}</style>
</head>
<body>
  <div class="thermal-bill">
    <div class="bill-header">
      <div class="company-name">{{company.name}}</div>
      <div class="company-address">{{company.address}}</div>
      <div class="company-contact">
        {{company.phone}}{{#if company.email}} | {{company.email}}{{/if}}
      </div>
      <div class="company-gst">
        {{company.gstin}}{{#if company.dlNo}} | DL: {{company.dlNo}}{{/if}}
      </div>
    </div>
    <div class="bill-meta">
      <div>Invoice No: {{bill.billNumber}}</div>
      <div>Date: {{bill.billDate}}</div>
    </div>
    <div class="customer-info">
      <div>To: {{bill.customerName}}</div>
      {{#if bill.customerAddress}}<div>{{bill.customerAddress}}</div>{{/if}}
      {{#if bill.customerGstin}}<div>GSTIN: {{bill.customerGstin}}</div>{{/if}}
    </div>
    <table class="items-table">
      <thead>
        <tr>
          <th>Item</th>
          <th>Qty</th>
          <th>Rate</th>
          <th>Amount</th>
        </tr>
      </thead>
      <tbody>
        {{#each bill.lines}}
        <tr>
          <td>{{this.productName}}</td>
          <td>{{this.quantity}}</td>
          <td>{{this.rate}}</td>
          <td>{{this.lineTotal}}</td>
        </tr>
        {{/each}}
      </tbody>
    </table>
    <div class="bill-footer">
      <div>Subtotal: {{bill.subtotal}}</div>
      <div>Tax: {{bill.totalTax}}</div>
      <div><strong>Total: {{bill.totalAmount}}</strong></div>
    </div>
  </div>
</body>
</html>`;
        const thermalCss = `@media print {
  @page {
    size: 80mm auto;
    margin: 0;
  }
}

.thermal-bill {
  width: 80mm;
  font-family: 'Courier New', monospace;
  font-size: 12px;
  padding: 10px;
}

.bill-header {
  text-align: center;
  margin-bottom: 10px;
  border-bottom: 1px dashed #000;
  padding-bottom: 10px;
}

.company-name {
  font-weight: bold;
  font-size: 14px;
  margin-bottom: 5px;
}

.company-address,
.company-contact,
.company-gst {
  font-size: 10px;
  margin: 2px 0;
}

.bill-meta {
  margin: 10px 0;
  font-size: 10px;
  display: flex;
  justify-content: space-between;
}

.customer-info {
  margin: 10px 0;
  font-size: 10px;
  border-top: 1px dashed #000;
  border-bottom: 1px dashed #000;
  padding: 5px 0;
}

.items-table {
  width: 100%;
  margin: 10px 0;
  font-size: 10px;
  border-collapse: collapse;
}

.items-table th,
.items-table td {
  padding: 3px;
  text-align: left;
  border-bottom: 1px dashed #ccc;
}

.items-table th {
  font-weight: bold;
  border-bottom: 1px solid #000;
}

.bill-footer {
  margin-top: 10px;
  padding-top: 10px;
  border-top: 1px dashed #000;
  font-size: 11px;
}

.bill-footer div {
  display: flex;
  justify-content: space-between;
  margin: 3px 0;
}

.bill-footer strong {
  font-size: 13px;
}`;
        await createBillTemplate({
          name: "Thermal (80mm)",
          description: "Thermal printer compatible 80mm bill template",
          templateType: "THERMAL_3INCH",
          htmlContent: thermalHtml,
          cssContent: thermalCss,
          placeholders: getDefaultA4TemplatePlaceholders(),
          isDefault: false
        }, userId);
      }
    };
  }
});

// node_modules/is-obj/index.js
var require_is_obj = __commonJS({
  "node_modules/is-obj/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (value) => {
      const type = typeof value;
      return value !== null && (type === "object" || type === "function");
    };
  }
});

// node_modules/dot-prop/index.js
var require_dot_prop = __commonJS({
  "node_modules/dot-prop/index.js"(exports2, module2) {
    "use strict";
    var isObj = require_is_obj();
    var disallowedKeys = /* @__PURE__ */ new Set([
      "__proto__",
      "prototype",
      "constructor"
    ]);
    var isValidPath = (pathSegments) => !pathSegments.some((segment) => disallowedKeys.has(segment));
    function getPathSegments(path16) {
      const pathArray = path16.split(".");
      const parts = [];
      for (let i = 0; i < pathArray.length; i++) {
        let p = pathArray[i];
        while (p[p.length - 1] === "\\" && pathArray[i + 1] !== void 0) {
          p = p.slice(0, -1) + ".";
          p += pathArray[++i];
        }
        parts.push(p);
      }
      if (!isValidPath(parts)) {
        return [];
      }
      return parts;
    }
    module2.exports = {
      get(object, path16, value) {
        if (!isObj(object) || typeof path16 !== "string") {
          return value === void 0 ? object : value;
        }
        const pathArray = getPathSegments(path16);
        if (pathArray.length === 0) {
          return;
        }
        for (let i = 0; i < pathArray.length; i++) {
          object = object[pathArray[i]];
          if (object === void 0 || object === null) {
            if (i !== pathArray.length - 1) {
              return value;
            }
            break;
          }
        }
        return object === void 0 ? value : object;
      },
      set(object, path16, value) {
        if (!isObj(object) || typeof path16 !== "string") {
          return object;
        }
        const root = object;
        const pathArray = getPathSegments(path16);
        for (let i = 0; i < pathArray.length; i++) {
          const p = pathArray[i];
          if (!isObj(object[p])) {
            object[p] = {};
          }
          if (i === pathArray.length - 1) {
            object[p] = value;
          }
          object = object[p];
        }
        return root;
      },
      delete(object, path16) {
        if (!isObj(object) || typeof path16 !== "string") {
          return false;
        }
        const pathArray = getPathSegments(path16);
        for (let i = 0; i < pathArray.length; i++) {
          const p = pathArray[i];
          if (i === pathArray.length - 1) {
            delete object[p];
            return true;
          }
          object = object[p];
          if (!isObj(object)) {
            return false;
          }
        }
      },
      has(object, path16) {
        if (!isObj(object) || typeof path16 !== "string") {
          return false;
        }
        const pathArray = getPathSegments(path16);
        if (pathArray.length === 0) {
          return false;
        }
        for (let i = 0; i < pathArray.length; i++) {
          if (isObj(object)) {
            if (!(pathArray[i] in object)) {
              return false;
            }
            object = object[pathArray[i]];
          } else {
            return false;
          }
        }
        return true;
      }
    };
  }
});

// node_modules/path-exists/index.js
var require_path_exists = __commonJS({
  "node_modules/path-exists/index.js"(exports2, module2) {
    "use strict";
    var fs14 = require("fs");
    module2.exports = (fp) => new Promise((resolve) => {
      fs14.access(fp, (err) => {
        resolve(!err);
      });
    });
    module2.exports.sync = (fp) => {
      try {
        fs14.accessSync(fp);
        return true;
      } catch (err) {
        return false;
      }
    };
  }
});

// node_modules/p-try/index.js
var require_p_try = __commonJS({
  "node_modules/p-try/index.js"(exports2, module2) {
    "use strict";
    var pTry = (fn, ...arguments_) => new Promise((resolve) => {
      resolve(fn(...arguments_));
    });
    module2.exports = pTry;
    module2.exports.default = pTry;
  }
});

// node_modules/p-limit/index.js
var require_p_limit = __commonJS({
  "node_modules/p-limit/index.js"(exports2, module2) {
    "use strict";
    var pTry = require_p_try();
    var pLimit = (concurrency) => {
      if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
        return Promise.reject(new TypeError("Expected `concurrency` to be a number from 1 and up"));
      }
      const queue = [];
      let activeCount = 0;
      const next = () => {
        activeCount--;
        if (queue.length > 0) {
          queue.shift()();
        }
      };
      const run = (fn, resolve, ...args) => {
        activeCount++;
        const result = pTry(fn, ...args);
        resolve(result);
        result.then(next, next);
      };
      const enqueue = (fn, resolve, ...args) => {
        if (activeCount < concurrency) {
          run(fn, resolve, ...args);
        } else {
          queue.push(run.bind(null, fn, resolve, ...args));
        }
      };
      const generator = (fn, ...args) => new Promise((resolve) => enqueue(fn, resolve, ...args));
      Object.defineProperties(generator, {
        activeCount: {
          get: () => activeCount
        },
        pendingCount: {
          get: () => queue.length
        },
        clearQueue: {
          value: () => {
            queue.length = 0;
          }
        }
      });
      return generator;
    };
    module2.exports = pLimit;
    module2.exports.default = pLimit;
  }
});

// node_modules/p-locate/index.js
var require_p_locate = __commonJS({
  "node_modules/p-locate/index.js"(exports2, module2) {
    "use strict";
    var pLimit = require_p_limit();
    var EndError = class extends Error {
      constructor(value) {
        super();
        this.value = value;
      }
    };
    var testElement = (el, tester) => Promise.resolve(el).then(tester);
    var finder = (el) => Promise.all(el).then((val) => val[1] === true && Promise.reject(new EndError(val[0])));
    module2.exports = (iterable, tester, opts) => {
      opts = Object.assign({
        concurrency: Infinity,
        preserveOrder: true
      }, opts);
      const limit = pLimit(opts.concurrency);
      const items = [...iterable].map((el) => [el, limit(testElement, el, tester)]);
      const checkLimit = pLimit(opts.preserveOrder ? 1 : Infinity);
      return Promise.all(items.map((el) => checkLimit(finder, el))).then(() => {
      }).catch((err) => err instanceof EndError ? err.value : Promise.reject(err));
    };
  }
});

// node_modules/locate-path/index.js
var require_locate_path = __commonJS({
  "node_modules/locate-path/index.js"(exports2, module2) {
    "use strict";
    var path16 = require("path");
    var pathExists = require_path_exists();
    var pLocate = require_p_locate();
    module2.exports = (iterable, options) => {
      options = Object.assign({
        cwd: process.cwd()
      }, options);
      return pLocate(iterable, (el) => pathExists(path16.resolve(options.cwd, el)), options);
    };
    module2.exports.sync = (iterable, options) => {
      options = Object.assign({
        cwd: process.cwd()
      }, options);
      for (const el of iterable) {
        if (pathExists.sync(path16.resolve(options.cwd, el))) {
          return el;
        }
      }
    };
  }
});

// node_modules/find-up/index.js
var require_find_up = __commonJS({
  "node_modules/find-up/index.js"(exports2, module2) {
    "use strict";
    var path16 = require("path");
    var locatePath = require_locate_path();
    module2.exports = (filename, opts = {}) => {
      const startDir = path16.resolve(opts.cwd || "");
      const { root } = path16.parse(startDir);
      const filenames = [].concat(filename);
      return new Promise((resolve) => {
        (function find(dir) {
          locatePath(filenames, { cwd: dir }).then((file) => {
            if (file) {
              resolve(path16.join(dir, file));
            } else if (dir === root) {
              resolve(null);
            } else {
              find(path16.dirname(dir));
            }
          });
        })(startDir);
      });
    };
    module2.exports.sync = (filename, opts = {}) => {
      let dir = path16.resolve(opts.cwd || "");
      const { root } = path16.parse(dir);
      const filenames = [].concat(filename);
      while (true) {
        const file = locatePath.sync(filenames, { cwd: dir });
        if (file) {
          return path16.join(dir, file);
        }
        if (dir === root) {
          return null;
        }
        dir = path16.dirname(dir);
      }
    };
  }
});

// node_modules/pkg-up/index.js
var require_pkg_up = __commonJS({
  "node_modules/pkg-up/index.js"(exports2, module2) {
    "use strict";
    var findUp = require_find_up();
    module2.exports = async ({ cwd } = {}) => findUp("package.json", { cwd });
    module2.exports.sync = ({ cwd } = {}) => findUp.sync("package.json", { cwd });
  }
});

// node_modules/env-paths/index.js
var require_env_paths = __commonJS({
  "node_modules/env-paths/index.js"(exports2, module2) {
    "use strict";
    var path16 = require("path");
    var os = require("os");
    var homedir = os.homedir();
    var tmpdir = os.tmpdir();
    var { env } = process;
    var macos = (name) => {
      const library = path16.join(homedir, "Library");
      return {
        data: path16.join(library, "Application Support", name),
        config: path16.join(library, "Preferences", name),
        cache: path16.join(library, "Caches", name),
        log: path16.join(library, "Logs", name),
        temp: path16.join(tmpdir, name)
      };
    };
    var windows = (name) => {
      const appData = env.APPDATA || path16.join(homedir, "AppData", "Roaming");
      const localAppData = env.LOCALAPPDATA || path16.join(homedir, "AppData", "Local");
      return {
        // Data/config/cache/log are invented by me as Windows isn't opinionated about this
        data: path16.join(localAppData, name, "Data"),
        config: path16.join(appData, name, "Config"),
        cache: path16.join(localAppData, name, "Cache"),
        log: path16.join(localAppData, name, "Log"),
        temp: path16.join(tmpdir, name)
      };
    };
    var linux = (name) => {
      const username = path16.basename(homedir);
      return {
        data: path16.join(env.XDG_DATA_HOME || path16.join(homedir, ".local", "share"), name),
        config: path16.join(env.XDG_CONFIG_HOME || path16.join(homedir, ".config"), name),
        cache: path16.join(env.XDG_CACHE_HOME || path16.join(homedir, ".cache"), name),
        // https://wiki.debian.org/XDGBaseDirectorySpecification#state
        log: path16.join(env.XDG_STATE_HOME || path16.join(homedir, ".local", "state"), name),
        temp: path16.join(tmpdir, username, name)
      };
    };
    var envPaths = (name, options) => {
      if (typeof name !== "string") {
        throw new TypeError(`Expected string, got ${typeof name}`);
      }
      options = Object.assign({ suffix: "nodejs" }, options);
      if (options.suffix) {
        name += `-${options.suffix}`;
      }
      if (process.platform === "darwin") {
        return macos(name);
      }
      if (process.platform === "win32") {
        return windows(name);
      }
      return linux(name);
    };
    module2.exports = envPaths;
    module2.exports.default = envPaths;
  }
});

// node_modules/atomically/dist/consts.js
var require_consts = __commonJS({
  "node_modules/atomically/dist/consts.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NOOP = exports2.LIMIT_FILES_DESCRIPTORS = exports2.LIMIT_BASENAME_LENGTH = exports2.IS_USER_ROOT = exports2.IS_POSIX = exports2.DEFAULT_TIMEOUT_SYNC = exports2.DEFAULT_TIMEOUT_ASYNC = exports2.DEFAULT_WRITE_OPTIONS = exports2.DEFAULT_READ_OPTIONS = exports2.DEFAULT_FOLDER_MODE = exports2.DEFAULT_FILE_MODE = exports2.DEFAULT_ENCODING = void 0;
    var DEFAULT_ENCODING = "utf8";
    exports2.DEFAULT_ENCODING = DEFAULT_ENCODING;
    var DEFAULT_FILE_MODE = 438;
    exports2.DEFAULT_FILE_MODE = DEFAULT_FILE_MODE;
    var DEFAULT_FOLDER_MODE = 511;
    exports2.DEFAULT_FOLDER_MODE = DEFAULT_FOLDER_MODE;
    var DEFAULT_READ_OPTIONS = {};
    exports2.DEFAULT_READ_OPTIONS = DEFAULT_READ_OPTIONS;
    var DEFAULT_WRITE_OPTIONS = {};
    exports2.DEFAULT_WRITE_OPTIONS = DEFAULT_WRITE_OPTIONS;
    var DEFAULT_TIMEOUT_ASYNC = 5e3;
    exports2.DEFAULT_TIMEOUT_ASYNC = DEFAULT_TIMEOUT_ASYNC;
    var DEFAULT_TIMEOUT_SYNC = 100;
    exports2.DEFAULT_TIMEOUT_SYNC = DEFAULT_TIMEOUT_SYNC;
    var IS_POSIX = !!process.getuid;
    exports2.IS_POSIX = IS_POSIX;
    var IS_USER_ROOT = process.getuid ? !process.getuid() : false;
    exports2.IS_USER_ROOT = IS_USER_ROOT;
    var LIMIT_BASENAME_LENGTH = 128;
    exports2.LIMIT_BASENAME_LENGTH = LIMIT_BASENAME_LENGTH;
    var LIMIT_FILES_DESCRIPTORS = 1e4;
    exports2.LIMIT_FILES_DESCRIPTORS = LIMIT_FILES_DESCRIPTORS;
    var NOOP = () => {
    };
    exports2.NOOP = NOOP;
  }
});

// node_modules/atomically/dist/utils/attemptify.js
var require_attemptify = __commonJS({
  "node_modules/atomically/dist/utils/attemptify.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.attemptifySync = exports2.attemptifyAsync = void 0;
    var consts_1 = require_consts();
    var attemptifyAsync = (fn, onError = consts_1.NOOP) => {
      return function() {
        return fn.apply(void 0, arguments).catch(onError);
      };
    };
    exports2.attemptifyAsync = attemptifyAsync;
    var attemptifySync = (fn, onError = consts_1.NOOP) => {
      return function() {
        try {
          return fn.apply(void 0, arguments);
        } catch (error) {
          return onError(error);
        }
      };
    };
    exports2.attemptifySync = attemptifySync;
  }
});

// node_modules/atomically/dist/utils/fs_handlers.js
var require_fs_handlers = __commonJS({
  "node_modules/atomically/dist/utils/fs_handlers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var consts_1 = require_consts();
    var Handlers = {
      isChangeErrorOk: (error) => {
        const { code } = error;
        if (code === "ENOSYS")
          return true;
        if (!consts_1.IS_USER_ROOT && (code === "EINVAL" || code === "EPERM"))
          return true;
        return false;
      },
      isRetriableError: (error) => {
        const { code } = error;
        if (code === "EMFILE" || code === "ENFILE" || code === "EAGAIN" || code === "EBUSY" || code === "EACCESS" || code === "EACCS" || code === "EPERM")
          return true;
        return false;
      },
      onChangeError: (error) => {
        if (Handlers.isChangeErrorOk(error))
          return;
        throw error;
      }
    };
    exports2.default = Handlers;
  }
});

// node_modules/atomically/dist/utils/retryify_queue.js
var require_retryify_queue = __commonJS({
  "node_modules/atomically/dist/utils/retryify_queue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var consts_1 = require_consts();
    var RetryfyQueue = {
      interval: 25,
      intervalId: void 0,
      limit: consts_1.LIMIT_FILES_DESCRIPTORS,
      queueActive: /* @__PURE__ */ new Set(),
      queueWaiting: /* @__PURE__ */ new Set(),
      init: () => {
        if (RetryfyQueue.intervalId)
          return;
        RetryfyQueue.intervalId = setInterval(RetryfyQueue.tick, RetryfyQueue.interval);
      },
      reset: () => {
        if (!RetryfyQueue.intervalId)
          return;
        clearInterval(RetryfyQueue.intervalId);
        delete RetryfyQueue.intervalId;
      },
      add: (fn) => {
        RetryfyQueue.queueWaiting.add(fn);
        if (RetryfyQueue.queueActive.size < RetryfyQueue.limit / 2) {
          RetryfyQueue.tick();
        } else {
          RetryfyQueue.init();
        }
      },
      remove: (fn) => {
        RetryfyQueue.queueWaiting.delete(fn);
        RetryfyQueue.queueActive.delete(fn);
      },
      schedule: () => {
        return new Promise((resolve) => {
          const cleanup = () => RetryfyQueue.remove(resolver);
          const resolver = () => resolve(cleanup);
          RetryfyQueue.add(resolver);
        });
      },
      tick: () => {
        if (RetryfyQueue.queueActive.size >= RetryfyQueue.limit)
          return;
        if (!RetryfyQueue.queueWaiting.size)
          return RetryfyQueue.reset();
        for (const fn of RetryfyQueue.queueWaiting) {
          if (RetryfyQueue.queueActive.size >= RetryfyQueue.limit)
            break;
          RetryfyQueue.queueWaiting.delete(fn);
          RetryfyQueue.queueActive.add(fn);
          fn();
        }
      }
    };
    exports2.default = RetryfyQueue;
  }
});

// node_modules/atomically/dist/utils/retryify.js
var require_retryify = __commonJS({
  "node_modules/atomically/dist/utils/retryify.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.retryifySync = exports2.retryifyAsync = void 0;
    var retryify_queue_1 = require_retryify_queue();
    var retryifyAsync = (fn, isRetriableError) => {
      return function(timestamp) {
        return function attempt() {
          return retryify_queue_1.default.schedule().then((cleanup) => {
            return fn.apply(void 0, arguments).then((result) => {
              cleanup();
              return result;
            }, (error) => {
              cleanup();
              if (Date.now() >= timestamp)
                throw error;
              if (isRetriableError(error)) {
                const delay = Math.round(100 + 400 * Math.random()), delayPromise = new Promise((resolve) => setTimeout(resolve, delay));
                return delayPromise.then(() => attempt.apply(void 0, arguments));
              }
              throw error;
            });
          });
        };
      };
    };
    exports2.retryifyAsync = retryifyAsync;
    var retryifySync = (fn, isRetriableError) => {
      return function(timestamp) {
        return function attempt() {
          try {
            return fn.apply(void 0, arguments);
          } catch (error) {
            if (Date.now() > timestamp)
              throw error;
            if (isRetriableError(error))
              return attempt.apply(void 0, arguments);
            throw error;
          }
        };
      };
    };
    exports2.retryifySync = retryifySync;
  }
});

// node_modules/atomically/dist/utils/fs.js
var require_fs = __commonJS({
  "node_modules/atomically/dist/utils/fs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var fs14 = require("fs");
    var util_1 = require("util");
    var attemptify_1 = require_attemptify();
    var fs_handlers_1 = require_fs_handlers();
    var retryify_1 = require_retryify();
    var FS = {
      chmodAttempt: attemptify_1.attemptifyAsync(util_1.promisify(fs14.chmod), fs_handlers_1.default.onChangeError),
      chownAttempt: attemptify_1.attemptifyAsync(util_1.promisify(fs14.chown), fs_handlers_1.default.onChangeError),
      closeAttempt: attemptify_1.attemptifyAsync(util_1.promisify(fs14.close)),
      fsyncAttempt: attemptify_1.attemptifyAsync(util_1.promisify(fs14.fsync)),
      mkdirAttempt: attemptify_1.attemptifyAsync(util_1.promisify(fs14.mkdir)),
      realpathAttempt: attemptify_1.attemptifyAsync(util_1.promisify(fs14.realpath)),
      statAttempt: attemptify_1.attemptifyAsync(util_1.promisify(fs14.stat)),
      unlinkAttempt: attemptify_1.attemptifyAsync(util_1.promisify(fs14.unlink)),
      closeRetry: retryify_1.retryifyAsync(util_1.promisify(fs14.close), fs_handlers_1.default.isRetriableError),
      fsyncRetry: retryify_1.retryifyAsync(util_1.promisify(fs14.fsync), fs_handlers_1.default.isRetriableError),
      openRetry: retryify_1.retryifyAsync(util_1.promisify(fs14.open), fs_handlers_1.default.isRetriableError),
      readFileRetry: retryify_1.retryifyAsync(util_1.promisify(fs14.readFile), fs_handlers_1.default.isRetriableError),
      renameRetry: retryify_1.retryifyAsync(util_1.promisify(fs14.rename), fs_handlers_1.default.isRetriableError),
      statRetry: retryify_1.retryifyAsync(util_1.promisify(fs14.stat), fs_handlers_1.default.isRetriableError),
      writeRetry: retryify_1.retryifyAsync(util_1.promisify(fs14.write), fs_handlers_1.default.isRetriableError),
      chmodSyncAttempt: attemptify_1.attemptifySync(fs14.chmodSync, fs_handlers_1.default.onChangeError),
      chownSyncAttempt: attemptify_1.attemptifySync(fs14.chownSync, fs_handlers_1.default.onChangeError),
      closeSyncAttempt: attemptify_1.attemptifySync(fs14.closeSync),
      mkdirSyncAttempt: attemptify_1.attemptifySync(fs14.mkdirSync),
      realpathSyncAttempt: attemptify_1.attemptifySync(fs14.realpathSync),
      statSyncAttempt: attemptify_1.attemptifySync(fs14.statSync),
      unlinkSyncAttempt: attemptify_1.attemptifySync(fs14.unlinkSync),
      closeSyncRetry: retryify_1.retryifySync(fs14.closeSync, fs_handlers_1.default.isRetriableError),
      fsyncSyncRetry: retryify_1.retryifySync(fs14.fsyncSync, fs_handlers_1.default.isRetriableError),
      openSyncRetry: retryify_1.retryifySync(fs14.openSync, fs_handlers_1.default.isRetriableError),
      readFileSyncRetry: retryify_1.retryifySync(fs14.readFileSync, fs_handlers_1.default.isRetriableError),
      renameSyncRetry: retryify_1.retryifySync(fs14.renameSync, fs_handlers_1.default.isRetriableError),
      statSyncRetry: retryify_1.retryifySync(fs14.statSync, fs_handlers_1.default.isRetriableError),
      writeSyncRetry: retryify_1.retryifySync(fs14.writeSync, fs_handlers_1.default.isRetriableError)
    };
    exports2.default = FS;
  }
});

// node_modules/atomically/dist/utils/lang.js
var require_lang = __commonJS({
  "node_modules/atomically/dist/utils/lang.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Lang = {
      isFunction: (x) => {
        return typeof x === "function";
      },
      isString: (x) => {
        return typeof x === "string";
      },
      isUndefined: (x) => {
        return typeof x === "undefined";
      }
    };
    exports2.default = Lang;
  }
});

// node_modules/atomically/dist/utils/scheduler.js
var require_scheduler = __commonJS({
  "node_modules/atomically/dist/utils/scheduler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Queues = {};
    var Scheduler = {
      next: (id) => {
        const queue = Queues[id];
        if (!queue)
          return;
        queue.shift();
        const job = queue[0];
        if (job) {
          job(() => Scheduler.next(id));
        } else {
          delete Queues[id];
        }
      },
      schedule: (id) => {
        return new Promise((resolve) => {
          let queue = Queues[id];
          if (!queue)
            queue = Queues[id] = [];
          queue.push(resolve);
          if (queue.length > 1)
            return;
          resolve(() => Scheduler.next(id));
        });
      }
    };
    exports2.default = Scheduler;
  }
});

// node_modules/atomically/dist/utils/temp.js
var require_temp = __commonJS({
  "node_modules/atomically/dist/utils/temp.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var path16 = require("path");
    var consts_1 = require_consts();
    var fs_1 = require_fs();
    var Temp = {
      store: {},
      create: (filePath) => {
        const randomness = `000000${Math.floor(Math.random() * 16777215).toString(16)}`.slice(-6), timestamp = Date.now().toString().slice(-10), prefix = "tmp-", suffix = `.${prefix}${timestamp}${randomness}`, tempPath = `${filePath}${suffix}`;
        return tempPath;
      },
      get: (filePath, creator, purge = true) => {
        const tempPath = Temp.truncate(creator(filePath));
        if (tempPath in Temp.store)
          return Temp.get(filePath, creator, purge);
        Temp.store[tempPath] = purge;
        const disposer = () => delete Temp.store[tempPath];
        return [tempPath, disposer];
      },
      purge: (filePath) => {
        if (!Temp.store[filePath])
          return;
        delete Temp.store[filePath];
        fs_1.default.unlinkAttempt(filePath);
      },
      purgeSync: (filePath) => {
        if (!Temp.store[filePath])
          return;
        delete Temp.store[filePath];
        fs_1.default.unlinkSyncAttempt(filePath);
      },
      purgeSyncAll: () => {
        for (const filePath in Temp.store) {
          Temp.purgeSync(filePath);
        }
      },
      truncate: (filePath) => {
        const basename2 = path16.basename(filePath);
        if (basename2.length <= consts_1.LIMIT_BASENAME_LENGTH)
          return filePath;
        const truncable = /^(\.?)(.*?)((?:\.[^.]+)?(?:\.tmp-\d{10}[a-f0-9]{6})?)$/.exec(basename2);
        if (!truncable)
          return filePath;
        const truncationLength = basename2.length - consts_1.LIMIT_BASENAME_LENGTH;
        return `${filePath.slice(0, -basename2.length)}${truncable[1]}${truncable[2].slice(0, -truncationLength)}${truncable[3]}`;
      }
    };
    process.on("exit", Temp.purgeSyncAll);
    exports2.default = Temp;
  }
});

// node_modules/atomically/dist/index.js
var require_dist = __commonJS({
  "node_modules/atomically/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.writeFileSync = exports2.writeFile = exports2.readFileSync = exports2.readFile = void 0;
    var path16 = require("path");
    var consts_1 = require_consts();
    var fs_1 = require_fs();
    var lang_1 = require_lang();
    var scheduler_1 = require_scheduler();
    var temp_1 = require_temp();
    function readFile(filePath, options = consts_1.DEFAULT_READ_OPTIONS) {
      var _a;
      if (lang_1.default.isString(options))
        return readFile(filePath, { encoding: options });
      const timeout = Date.now() + ((_a = options.timeout) !== null && _a !== void 0 ? _a : consts_1.DEFAULT_TIMEOUT_ASYNC);
      return fs_1.default.readFileRetry(timeout)(filePath, options);
    }
    exports2.readFile = readFile;
    function readFileSync6(filePath, options = consts_1.DEFAULT_READ_OPTIONS) {
      var _a;
      if (lang_1.default.isString(options))
        return readFileSync6(filePath, { encoding: options });
      const timeout = Date.now() + ((_a = options.timeout) !== null && _a !== void 0 ? _a : consts_1.DEFAULT_TIMEOUT_SYNC);
      return fs_1.default.readFileSyncRetry(timeout)(filePath, options);
    }
    exports2.readFileSync = readFileSync6;
    var writeFile = (filePath, data, options, callback) => {
      if (lang_1.default.isFunction(options))
        return writeFile(filePath, data, consts_1.DEFAULT_WRITE_OPTIONS, options);
      const promise = writeFileAsync(filePath, data, options);
      if (callback)
        promise.then(callback, callback);
      return promise;
    };
    exports2.writeFile = writeFile;
    var writeFileAsync = async (filePath, data, options = consts_1.DEFAULT_WRITE_OPTIONS) => {
      var _a;
      if (lang_1.default.isString(options))
        return writeFileAsync(filePath, data, { encoding: options });
      const timeout = Date.now() + ((_a = options.timeout) !== null && _a !== void 0 ? _a : consts_1.DEFAULT_TIMEOUT_ASYNC);
      let schedulerCustomDisposer = null, schedulerDisposer = null, tempDisposer = null, tempPath = null, fd = null;
      try {
        if (options.schedule)
          schedulerCustomDisposer = await options.schedule(filePath);
        schedulerDisposer = await scheduler_1.default.schedule(filePath);
        filePath = await fs_1.default.realpathAttempt(filePath) || filePath;
        [tempPath, tempDisposer] = temp_1.default.get(filePath, options.tmpCreate || temp_1.default.create, !(options.tmpPurge === false));
        const useStatChown = consts_1.IS_POSIX && lang_1.default.isUndefined(options.chown), useStatMode = lang_1.default.isUndefined(options.mode);
        if (useStatChown || useStatMode) {
          const stat = await fs_1.default.statAttempt(filePath);
          if (stat) {
            options = { ...options };
            if (useStatChown)
              options.chown = { uid: stat.uid, gid: stat.gid };
            if (useStatMode)
              options.mode = stat.mode;
          }
        }
        const parentPath = path16.dirname(filePath);
        await fs_1.default.mkdirAttempt(parentPath, {
          mode: consts_1.DEFAULT_FOLDER_MODE,
          recursive: true
        });
        fd = await fs_1.default.openRetry(timeout)(tempPath, "w", options.mode || consts_1.DEFAULT_FILE_MODE);
        if (options.tmpCreated)
          options.tmpCreated(tempPath);
        if (lang_1.default.isString(data)) {
          await fs_1.default.writeRetry(timeout)(fd, data, 0, options.encoding || consts_1.DEFAULT_ENCODING);
        } else if (!lang_1.default.isUndefined(data)) {
          await fs_1.default.writeRetry(timeout)(fd, data, 0, data.length, 0);
        }
        if (options.fsync !== false) {
          if (options.fsyncWait !== false) {
            await fs_1.default.fsyncRetry(timeout)(fd);
          } else {
            fs_1.default.fsyncAttempt(fd);
          }
        }
        await fs_1.default.closeRetry(timeout)(fd);
        fd = null;
        if (options.chown)
          await fs_1.default.chownAttempt(tempPath, options.chown.uid, options.chown.gid);
        if (options.mode)
          await fs_1.default.chmodAttempt(tempPath, options.mode);
        try {
          await fs_1.default.renameRetry(timeout)(tempPath, filePath);
        } catch (error) {
          if (error.code !== "ENAMETOOLONG")
            throw error;
          await fs_1.default.renameRetry(timeout)(tempPath, temp_1.default.truncate(filePath));
        }
        tempDisposer();
        tempPath = null;
      } finally {
        if (fd)
          await fs_1.default.closeAttempt(fd);
        if (tempPath)
          temp_1.default.purge(tempPath);
        if (schedulerCustomDisposer)
          schedulerCustomDisposer();
        if (schedulerDisposer)
          schedulerDisposer();
      }
    };
    var writeFileSync8 = (filePath, data, options = consts_1.DEFAULT_WRITE_OPTIONS) => {
      var _a;
      if (lang_1.default.isString(options))
        return writeFileSync8(filePath, data, { encoding: options });
      const timeout = Date.now() + ((_a = options.timeout) !== null && _a !== void 0 ? _a : consts_1.DEFAULT_TIMEOUT_SYNC);
      let tempDisposer = null, tempPath = null, fd = null;
      try {
        filePath = fs_1.default.realpathSyncAttempt(filePath) || filePath;
        [tempPath, tempDisposer] = temp_1.default.get(filePath, options.tmpCreate || temp_1.default.create, !(options.tmpPurge === false));
        const useStatChown = consts_1.IS_POSIX && lang_1.default.isUndefined(options.chown), useStatMode = lang_1.default.isUndefined(options.mode);
        if (useStatChown || useStatMode) {
          const stat = fs_1.default.statSyncAttempt(filePath);
          if (stat) {
            options = { ...options };
            if (useStatChown)
              options.chown = { uid: stat.uid, gid: stat.gid };
            if (useStatMode)
              options.mode = stat.mode;
          }
        }
        const parentPath = path16.dirname(filePath);
        fs_1.default.mkdirSyncAttempt(parentPath, {
          mode: consts_1.DEFAULT_FOLDER_MODE,
          recursive: true
        });
        fd = fs_1.default.openSyncRetry(timeout)(tempPath, "w", options.mode || consts_1.DEFAULT_FILE_MODE);
        if (options.tmpCreated)
          options.tmpCreated(tempPath);
        if (lang_1.default.isString(data)) {
          fs_1.default.writeSyncRetry(timeout)(fd, data, 0, options.encoding || consts_1.DEFAULT_ENCODING);
        } else if (!lang_1.default.isUndefined(data)) {
          fs_1.default.writeSyncRetry(timeout)(fd, data, 0, data.length, 0);
        }
        if (options.fsync !== false) {
          if (options.fsyncWait !== false) {
            fs_1.default.fsyncSyncRetry(timeout)(fd);
          } else {
            fs_1.default.fsyncAttempt(fd);
          }
        }
        fs_1.default.closeSyncRetry(timeout)(fd);
        fd = null;
        if (options.chown)
          fs_1.default.chownSyncAttempt(tempPath, options.chown.uid, options.chown.gid);
        if (options.mode)
          fs_1.default.chmodSyncAttempt(tempPath, options.mode);
        try {
          fs_1.default.renameSyncRetry(timeout)(tempPath, filePath);
        } catch (error) {
          if (error.code !== "ENAMETOOLONG")
            throw error;
          fs_1.default.renameSyncRetry(timeout)(tempPath, temp_1.default.truncate(filePath));
        }
        tempDisposer();
        tempPath = null;
      } finally {
        if (fd)
          fs_1.default.closeSyncAttempt(fd);
        if (tempPath)
          temp_1.default.purge(tempPath);
      }
    };
    exports2.writeFileSync = writeFileSync8;
  }
});

// node_modules/conf/node_modules/ajv/dist/compile/codegen/code.js
var require_code = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/compile/codegen/code.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.regexpCode = exports2.getEsmExportName = exports2.getProperty = exports2.safeStringify = exports2.stringify = exports2.strConcat = exports2.addCodeArg = exports2.str = exports2._ = exports2.nil = exports2._Code = exports2.Name = exports2.IDENTIFIER = exports2._CodeOrName = void 0;
    var _CodeOrName = class {
    };
    exports2._CodeOrName = _CodeOrName;
    exports2.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    var Name = class extends _CodeOrName {
      constructor(s) {
        super();
        if (!exports2.IDENTIFIER.test(s))
          throw new Error("CodeGen: name must be a valid identifier");
        this.str = s;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return false;
      }
      get names() {
        return { [this.str]: 1 };
      }
    };
    exports2.Name = Name;
    var _Code = class extends _CodeOrName {
      constructor(code) {
        super();
        this._items = typeof code === "string" ? [code] : code;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1)
          return false;
        const item = this._items[0];
        return item === "" || item === '""';
      }
      get str() {
        var _a;
        return (_a = this._str) !== null && _a !== void 0 ? _a : this._str = this._items.reduce((s, c) => `${s}${c}`, "");
      }
      get names() {
        var _a;
        return (_a = this._names) !== null && _a !== void 0 ? _a : this._names = this._items.reduce((names, c) => {
          if (c instanceof Name)
            names[c.str] = (names[c.str] || 0) + 1;
          return names;
        }, {});
      }
    };
    exports2._Code = _Code;
    exports2.nil = new _Code("");
    function _(strs, ...args) {
      const code = [strs[0]];
      let i = 0;
      while (i < args.length) {
        addCodeArg(code, args[i]);
        code.push(strs[++i]);
      }
      return new _Code(code);
    }
    exports2._ = _;
    var plus = new _Code("+");
    function str(strs, ...args) {
      const expr = [safeStringify(strs[0])];
      let i = 0;
      while (i < args.length) {
        expr.push(plus);
        addCodeArg(expr, args[i]);
        expr.push(plus, safeStringify(strs[++i]));
      }
      optimize(expr);
      return new _Code(expr);
    }
    exports2.str = str;
    function addCodeArg(code, arg) {
      if (arg instanceof _Code)
        code.push(...arg._items);
      else if (arg instanceof Name)
        code.push(arg);
      else
        code.push(interpolate(arg));
    }
    exports2.addCodeArg = addCodeArg;
    function optimize(expr) {
      let i = 1;
      while (i < expr.length - 1) {
        if (expr[i] === plus) {
          const res = mergeExprItems(expr[i - 1], expr[i + 1]);
          if (res !== void 0) {
            expr.splice(i - 1, 3, res);
            continue;
          }
          expr[i++] = "+";
        }
        i++;
      }
    }
    function mergeExprItems(a, b) {
      if (b === '""')
        return a;
      if (a === '""')
        return b;
      if (typeof a == "string") {
        if (b instanceof Name || a[a.length - 1] !== '"')
          return;
        if (typeof b != "string")
          return `${a.slice(0, -1)}${b}"`;
        if (b[0] === '"')
          return a.slice(0, -1) + b.slice(1);
        return;
      }
      if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
        return `"${a}${b.slice(1)}`;
      return;
    }
    function strConcat(c1, c2) {
      return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
    }
    exports2.strConcat = strConcat;
    function interpolate(x) {
      return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
    }
    function stringify(x) {
      return new _Code(safeStringify(x));
    }
    exports2.stringify = stringify;
    function safeStringify(x) {
      return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    exports2.safeStringify = safeStringify;
    function getProperty(key) {
      return typeof key == "string" && exports2.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
    }
    exports2.getProperty = getProperty;
    function getEsmExportName(key) {
      if (typeof key == "string" && exports2.IDENTIFIER.test(key)) {
        return new _Code(`${key}`);
      }
      throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
    }
    exports2.getEsmExportName = getEsmExportName;
    function regexpCode(rx) {
      return new _Code(rx.toString());
    }
    exports2.regexpCode = regexpCode;
  }
});

// node_modules/conf/node_modules/ajv/dist/compile/codegen/scope.js
var require_scope2 = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/compile/codegen/scope.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ValueScope = exports2.ValueScopeName = exports2.Scope = exports2.varKinds = exports2.UsedValueState = void 0;
    var code_1 = require_code();
    var ValueError = class extends Error {
      constructor(name) {
        super(`CodeGen: "code" for ${name} not defined`);
        this.value = name.value;
      }
    };
    var UsedValueState;
    (function(UsedValueState2) {
      UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
      UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
    })(UsedValueState || (exports2.UsedValueState = UsedValueState = {}));
    exports2.varKinds = {
      const: new code_1.Name("const"),
      let: new code_1.Name("let"),
      var: new code_1.Name("var")
    };
    var Scope = class {
      constructor({ prefixes, parent } = {}) {
        this._names = {};
        this._prefixes = prefixes;
        this._parent = parent;
      }
      toName(nameOrPrefix) {
        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
      }
      name(prefix) {
        return new code_1.Name(this._newName(prefix));
      }
      _newName(prefix) {
        const ng = this._names[prefix] || this._nameGroup(prefix);
        return `${prefix}${ng.index++}`;
      }
      _nameGroup(prefix) {
        var _a, _b;
        if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
          throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
        }
        return this._names[prefix] = { prefix, index: 0 };
      }
    };
    exports2.Scope = Scope;
    var ValueScopeName = class extends code_1.Name {
      constructor(prefix, nameStr) {
        super(nameStr);
        this.prefix = prefix;
      }
      setValue(value, { property, itemIndex }) {
        this.value = value;
        this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;
      }
    };
    exports2.ValueScopeName = ValueScopeName;
    var line = (0, code_1._)`\n`;
    var ValueScope = class extends Scope {
      constructor(opts) {
        super(opts);
        this._values = {};
        this._scope = opts.scope;
        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
      }
      get() {
        return this._scope;
      }
      name(prefix) {
        return new ValueScopeName(prefix, this._newName(prefix));
      }
      value(nameOrPrefix, value) {
        var _a;
        if (value.ref === void 0)
          throw new Error("CodeGen: ref must be passed in value");
        const name = this.toName(nameOrPrefix);
        const { prefix } = name;
        const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
        let vs = this._values[prefix];
        if (vs) {
          const _name = vs.get(valueKey);
          if (_name)
            return _name;
        } else {
          vs = this._values[prefix] = /* @__PURE__ */ new Map();
        }
        vs.set(valueKey, name);
        const s = this._scope[prefix] || (this._scope[prefix] = []);
        const itemIndex = s.length;
        s[itemIndex] = value.ref;
        name.setValue(value, { property: prefix, itemIndex });
        return name;
      }
      getValue(prefix, keyOrRef) {
        const vs = this._values[prefix];
        if (!vs)
          return;
        return vs.get(keyOrRef);
      }
      scopeRefs(scopeName, values = this._values) {
        return this._reduceValues(values, (name) => {
          if (name.scopePath === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return (0, code_1._)`${scopeName}${name.scopePath}`;
        });
      }
      scopeCode(values = this._values, usedValues, getCode) {
        return this._reduceValues(values, (name) => {
          if (name.value === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return name.value.code;
        }, usedValues, getCode);
      }
      _reduceValues(values, valueCode, usedValues = {}, getCode) {
        let code = code_1.nil;
        for (const prefix in values) {
          const vs = values[prefix];
          if (!vs)
            continue;
          const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
          vs.forEach((name) => {
            if (nameSet.has(name))
              return;
            nameSet.set(name, UsedValueState.Started);
            let c = valueCode(name);
            if (c) {
              const def = this.opts.es5 ? exports2.varKinds.var : exports2.varKinds.const;
              code = (0, code_1._)`${code}${def} ${name} = ${c};${this.opts._n}`;
            } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {
              code = (0, code_1._)`${code}${c}${this.opts._n}`;
            } else {
              throw new ValueError(name);
            }
            nameSet.set(name, UsedValueState.Completed);
          });
        }
        return code;
      }
    };
    exports2.ValueScope = ValueScope;
  }
});

// node_modules/conf/node_modules/ajv/dist/compile/codegen/index.js
var require_codegen = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/compile/codegen/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.or = exports2.and = exports2.not = exports2.CodeGen = exports2.operators = exports2.varKinds = exports2.ValueScopeName = exports2.ValueScope = exports2.Scope = exports2.Name = exports2.regexpCode = exports2.stringify = exports2.getProperty = exports2.nil = exports2.strConcat = exports2.str = exports2._ = void 0;
    var code_1 = require_code();
    var scope_1 = require_scope2();
    var code_2 = require_code();
    Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
      return code_2._;
    } });
    Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
      return code_2.str;
    } });
    Object.defineProperty(exports2, "strConcat", { enumerable: true, get: function() {
      return code_2.strConcat;
    } });
    Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
      return code_2.nil;
    } });
    Object.defineProperty(exports2, "getProperty", { enumerable: true, get: function() {
      return code_2.getProperty;
    } });
    Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
      return code_2.stringify;
    } });
    Object.defineProperty(exports2, "regexpCode", { enumerable: true, get: function() {
      return code_2.regexpCode;
    } });
    Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
      return code_2.Name;
    } });
    var scope_2 = require_scope2();
    Object.defineProperty(exports2, "Scope", { enumerable: true, get: function() {
      return scope_2.Scope;
    } });
    Object.defineProperty(exports2, "ValueScope", { enumerable: true, get: function() {
      return scope_2.ValueScope;
    } });
    Object.defineProperty(exports2, "ValueScopeName", { enumerable: true, get: function() {
      return scope_2.ValueScopeName;
    } });
    Object.defineProperty(exports2, "varKinds", { enumerable: true, get: function() {
      return scope_2.varKinds;
    } });
    exports2.operators = {
      GT: new code_1._Code(">"),
      GTE: new code_1._Code(">="),
      LT: new code_1._Code("<"),
      LTE: new code_1._Code("<="),
      EQ: new code_1._Code("==="),
      NEQ: new code_1._Code("!=="),
      NOT: new code_1._Code("!"),
      OR: new code_1._Code("||"),
      AND: new code_1._Code("&&"),
      ADD: new code_1._Code("+")
    };
    var Node = class {
      optimizeNodes() {
        return this;
      }
      optimizeNames(_names, _constants) {
        return this;
      }
    };
    var Def = class extends Node {
      constructor(varKind, name, rhs) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.rhs = rhs;
      }
      render({ es5, _n }) {
        const varKind = es5 ? scope_1.varKinds.var : this.varKind;
        const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${varKind} ${this.name}${rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (!names[this.name.str])
          return;
        if (this.rhs)
          this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
      }
    };
    var Assign = class extends Node {
      constructor(lhs, rhs, sideEffects) {
        super();
        this.lhs = lhs;
        this.rhs = rhs;
        this.sideEffects = sideEffects;
      }
      render({ _n }) {
        return `${this.lhs} = ${this.rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)
          return;
        this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
        return addExprNames(names, this.rhs);
      }
    };
    var AssignOp = class extends Assign {
      constructor(lhs, op, rhs, sideEffects) {
        super(lhs, rhs, sideEffects);
        this.op = op;
      }
      render({ _n }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
      }
    };
    var Label = class extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        return `${this.label}:` + _n;
      }
    };
    var Break = class extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        const label = this.label ? ` ${this.label}` : "";
        return `break${label};` + _n;
      }
    };
    var Throw = class extends Node {
      constructor(error) {
        super();
        this.error = error;
      }
      render({ _n }) {
        return `throw ${this.error};` + _n;
      }
      get names() {
        return this.error.names;
      }
    };
    var AnyCode = class extends Node {
      constructor(code) {
        super();
        this.code = code;
      }
      render({ _n }) {
        return `${this.code};` + _n;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(names, constants) {
        this.code = optimizeExpr(this.code, names, constants);
        return this;
      }
      get names() {
        return this.code instanceof code_1._CodeOrName ? this.code.names : {};
      }
    };
    var ParentNode = class extends Node {
      constructor(nodes = []) {
        super();
        this.nodes = nodes;
      }
      render(opts) {
        return this.nodes.reduce((code, n) => code + n.render(opts), "");
      }
      optimizeNodes() {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i].optimizeNodes();
          if (Array.isArray(n))
            nodes.splice(i, 1, ...n);
          else if (n)
            nodes[i] = n;
          else
            nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      optimizeNames(names, constants) {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i];
          if (n.optimizeNames(names, constants))
            continue;
          subtractNames(names, n.names);
          nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((names, n) => addNames(names, n.names), {});
      }
    };
    var BlockNode = class extends ParentNode {
      render(opts) {
        return "{" + opts._n + super.render(opts) + "}" + opts._n;
      }
    };
    var Root = class extends ParentNode {
    };
    var Else = class extends BlockNode {
    };
    Else.kind = "else";
    var If = class _If extends BlockNode {
      constructor(condition, nodes) {
        super(nodes);
        this.condition = condition;
      }
      render(opts) {
        let code = `if(${this.condition})` + super.render(opts);
        if (this.else)
          code += "else " + this.else.render(opts);
        return code;
      }
      optimizeNodes() {
        super.optimizeNodes();
        const cond = this.condition;
        if (cond === true)
          return this.nodes;
        let e = this.else;
        if (e) {
          const ns = e.optimizeNodes();
          e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
        }
        if (e) {
          if (cond === false)
            return e instanceof _If ? e : e.nodes;
          if (this.nodes.length)
            return this;
          return new _If(not(cond), e instanceof _If ? [e] : e.nodes);
        }
        if (cond === false || !this.nodes.length)
          return void 0;
        return this;
      }
      optimizeNames(names, constants) {
        var _a;
        this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
        if (!(super.optimizeNames(names, constants) || this.else))
          return;
        this.condition = optimizeExpr(this.condition, names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        addExprNames(names, this.condition);
        if (this.else)
          addNames(names, this.else.names);
        return names;
      }
    };
    If.kind = "if";
    var For = class extends BlockNode {
    };
    For.kind = "for";
    var ForLoop = class extends For {
      constructor(iteration) {
        super();
        this.iteration = iteration;
      }
      render(opts) {
        return `for(${this.iteration})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
          return;
        this.iteration = optimizeExpr(this.iteration, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iteration.names);
      }
    };
    var ForRange = class extends For {
      constructor(varKind, name, from, to) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.from = from;
        this.to = to;
      }
      render(opts) {
        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
        const { name, from, to } = this;
        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
      }
      get names() {
        const names = addExprNames(super.names, this.from);
        return addExprNames(names, this.to);
      }
    };
    var ForIter = class extends For {
      constructor(loop, varKind, name, iterable) {
        super();
        this.loop = loop;
        this.varKind = varKind;
        this.name = name;
        this.iterable = iterable;
      }
      render(opts) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
          return;
        this.iterable = optimizeExpr(this.iterable, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iterable.names);
      }
    };
    var Func = class extends BlockNode {
      constructor(name, args, async) {
        super();
        this.name = name;
        this.args = args;
        this.async = async;
      }
      render(opts) {
        const _async = this.async ? "async " : "";
        return `${_async}function ${this.name}(${this.args})` + super.render(opts);
      }
    };
    Func.kind = "func";
    var Return = class extends ParentNode {
      render(opts) {
        return "return " + super.render(opts);
      }
    };
    Return.kind = "return";
    var Try = class extends BlockNode {
      render(opts) {
        let code = "try" + super.render(opts);
        if (this.catch)
          code += this.catch.render(opts);
        if (this.finally)
          code += this.finally.render(opts);
        return code;
      }
      optimizeNodes() {
        var _a, _b;
        super.optimizeNodes();
        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
        return this;
      }
      optimizeNames(names, constants) {
        var _a, _b;
        super.optimizeNames(names, constants);
        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        if (this.catch)
          addNames(names, this.catch.names);
        if (this.finally)
          addNames(names, this.finally.names);
        return names;
      }
    };
    var Catch = class extends BlockNode {
      constructor(error) {
        super();
        this.error = error;
      }
      render(opts) {
        return `catch(${this.error})` + super.render(opts);
      }
    };
    Catch.kind = "catch";
    var Finally = class extends BlockNode {
      render(opts) {
        return "finally" + super.render(opts);
      }
    };
    Finally.kind = "finally";
    var CodeGen = class {
      constructor(extScope, opts = {}) {
        this._values = {};
        this._blockStarts = [];
        this._constants = {};
        this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
        this._extScope = extScope;
        this._scope = new scope_1.Scope({ parent: extScope });
        this._nodes = [new Root()];
      }
      toString() {
        return this._root.render(this.opts);
      }
      // returns unique name in the internal scope
      name(prefix) {
        return this._scope.name(prefix);
      }
      // reserves unique name in the external scope
      scopeName(prefix) {
        return this._extScope.name(prefix);
      }
      // reserves unique name in the external scope and assigns value to it
      scopeValue(prefixOrName, value) {
        const name = this._extScope.value(prefixOrName, value);
        const vs = this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set());
        vs.add(name);
        return name;
      }
      getScopeValue(prefix, keyOrRef) {
        return this._extScope.getValue(prefix, keyOrRef);
      }
      // return code that assigns values in the external scope to the names that are used internally
      // (same names that were returned by gen.scopeName or gen.scopeValue)
      scopeRefs(scopeName) {
        return this._extScope.scopeRefs(scopeName, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(varKind, nameOrPrefix, rhs, constant) {
        const name = this._scope.toName(nameOrPrefix);
        if (rhs !== void 0 && constant)
          this._constants[name.str] = rhs;
        this._leafNode(new Def(varKind, name, rhs));
        return name;
      }
      // `const` declaration (`var` in es5 mode)
      const(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
      }
      // `let` declaration with optional assignment (`var` in es5 mode)
      let(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
      }
      // `var` declaration with optional assignment
      var(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
      }
      // assignment code
      assign(lhs, rhs, sideEffects) {
        return this._leafNode(new Assign(lhs, rhs, sideEffects));
      }
      // `+=` code
      add(lhs, rhs) {
        return this._leafNode(new AssignOp(lhs, exports2.operators.ADD, rhs));
      }
      // appends passed SafeExpr to code or executes Block
      code(c) {
        if (typeof c == "function")
          c();
        else if (c !== code_1.nil)
          this._leafNode(new AnyCode(c));
        return this;
      }
      // returns code for object literal for the passed argument list of key-value pairs
      object(...keyValues) {
        const code = ["{"];
        for (const [key, value] of keyValues) {
          if (code.length > 1)
            code.push(",");
          code.push(key);
          if (key !== value || this.opts.es5) {
            code.push(":");
            (0, code_1.addCodeArg)(code, value);
          }
        }
        code.push("}");
        return new code_1._Code(code);
      }
      // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
      if(condition, thenBody, elseBody) {
        this._blockNode(new If(condition));
        if (thenBody && elseBody) {
          this.code(thenBody).else().code(elseBody).endIf();
        } else if (thenBody) {
          this.code(thenBody).endIf();
        } else if (elseBody) {
          throw new Error('CodeGen: "else" body without "then" body');
        }
        return this;
      }
      // `else if` clause - invalid without `if` or after `else` clauses
      elseIf(condition) {
        return this._elseNode(new If(condition));
      }
      // `else` clause - only valid after `if` or `else if` clauses
      else() {
        return this._elseNode(new Else());
      }
      // end `if` statement (needed if gen.if was used only with condition)
      endIf() {
        return this._endBlockNode(If, Else);
      }
      _for(node, forBody) {
        this._blockNode(node);
        if (forBody)
          this.code(forBody).endFor();
        return this;
      }
      // a generic `for` clause (or statement if `forBody` is passed)
      for(iteration, forBody) {
        return this._for(new ForLoop(iteration), forBody);
      }
      // `for` statement for a range of values
      forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
      }
      // `for-of` statement (in es5 mode replace with a normal for loop)
      forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
        const name = this._scope.toName(nameOrPrefix);
        if (this.opts.es5) {
          const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
          return this.forRange("_i", 0, (0, code_1._)`${arr}.length`, (i) => {
            this.var(name, (0, code_1._)`${arr}[${i}]`);
            forBody(name);
          });
        }
        return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
      }
      // `for-in` statement.
      // With option `ownProperties` replaced with a `for-of` loop for object keys
      forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
        if (this.opts.ownProperties) {
          return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);
        }
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
      }
      // end `for` loop
      endFor() {
        return this._endBlockNode(For);
      }
      // `label` statement
      label(label) {
        return this._leafNode(new Label(label));
      }
      // `break` statement
      break(label) {
        return this._leafNode(new Break(label));
      }
      // `return` statement
      return(value) {
        const node = new Return();
        this._blockNode(node);
        this.code(value);
        if (node.nodes.length !== 1)
          throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(Return);
      }
      // `try` statement
      try(tryBody, catchCode, finallyCode) {
        if (!catchCode && !finallyCode)
          throw new Error('CodeGen: "try" without "catch" and "finally"');
        const node = new Try();
        this._blockNode(node);
        this.code(tryBody);
        if (catchCode) {
          const error = this.name("e");
          this._currNode = node.catch = new Catch(error);
          catchCode(error);
        }
        if (finallyCode) {
          this._currNode = node.finally = new Finally();
          this.code(finallyCode);
        }
        return this._endBlockNode(Catch, Finally);
      }
      // `throw` statement
      throw(error) {
        return this._leafNode(new Throw(error));
      }
      // start self-balancing block
      block(body, nodeCount) {
        this._blockStarts.push(this._nodes.length);
        if (body)
          this.code(body).endBlock(nodeCount);
        return this;
      }
      // end the current self-balancing block
      endBlock(nodeCount) {
        const len = this._blockStarts.pop();
        if (len === void 0)
          throw new Error("CodeGen: not in self-balancing block");
        const toClose = this._nodes.length - len;
        if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
          throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
        }
        this._nodes.length = len;
        return this;
      }
      // `function` heading (or definition if funcBody is passed)
      func(name, args = code_1.nil, async, funcBody) {
        this._blockNode(new Func(name, args, async));
        if (funcBody)
          this.code(funcBody).endFunc();
        return this;
      }
      // end function definition
      endFunc() {
        return this._endBlockNode(Func);
      }
      optimize(n = 1) {
        while (n-- > 0) {
          this._root.optimizeNodes();
          this._root.optimizeNames(this._root.names, this._constants);
        }
      }
      _leafNode(node) {
        this._currNode.nodes.push(node);
        return this;
      }
      _blockNode(node) {
        this._currNode.nodes.push(node);
        this._nodes.push(node);
      }
      _endBlockNode(N1, N2) {
        const n = this._currNode;
        if (n instanceof N1 || N2 && n instanceof N2) {
          this._nodes.pop();
          return this;
        }
        throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
      }
      _elseNode(node) {
        const n = this._currNode;
        if (!(n instanceof If)) {
          throw new Error('CodeGen: "else" without "if"');
        }
        this._currNode = n.else = node;
        return this;
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        const ns = this._nodes;
        return ns[ns.length - 1];
      }
      set _currNode(node) {
        const ns = this._nodes;
        ns[ns.length - 1] = node;
      }
    };
    exports2.CodeGen = CodeGen;
    function addNames(names, from) {
      for (const n in from)
        names[n] = (names[n] || 0) + (from[n] || 0);
      return names;
    }
    function addExprNames(names, from) {
      return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
    }
    function optimizeExpr(expr, names, constants) {
      if (expr instanceof code_1.Name)
        return replaceName(expr);
      if (!canOptimize(expr))
        return expr;
      return new code_1._Code(expr._items.reduce((items, c) => {
        if (c instanceof code_1.Name)
          c = replaceName(c);
        if (c instanceof code_1._Code)
          items.push(...c._items);
        else
          items.push(c);
        return items;
      }, []));
      function replaceName(n) {
        const c = constants[n.str];
        if (c === void 0 || names[n.str] !== 1)
          return n;
        delete names[n.str];
        return c;
      }
      function canOptimize(e) {
        return e instanceof code_1._Code && e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== void 0);
      }
    }
    function subtractNames(names, from) {
      for (const n in from)
        names[n] = (names[n] || 0) - (from[n] || 0);
    }
    function not(x) {
      return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._)`!${par(x)}`;
    }
    exports2.not = not;
    var andCode = mappend(exports2.operators.AND);
    function and(...args) {
      return args.reduce(andCode);
    }
    exports2.and = and;
    var orCode = mappend(exports2.operators.OR);
    function or(...args) {
      return args.reduce(orCode);
    }
    exports2.or = or;
    function mappend(op) {
      return (x, y) => x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._)`${par(x)} ${op} ${par(y)}`;
    }
    function par(x) {
      return x instanceof code_1.Name ? x : (0, code_1._)`(${x})`;
    }
  }
});

// node_modules/conf/node_modules/ajv/dist/compile/util.js
var require_util = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/compile/util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.checkStrictMode = exports2.getErrorPath = exports2.Type = exports2.useFunc = exports2.setEvaluated = exports2.evaluatedPropsToName = exports2.mergeEvaluated = exports2.eachItem = exports2.unescapeJsonPointer = exports2.escapeJsonPointer = exports2.escapeFragment = exports2.unescapeFragment = exports2.schemaRefOrVal = exports2.schemaHasRulesButRef = exports2.schemaHasRules = exports2.checkUnknownRules = exports2.alwaysValidSchema = exports2.toHash = void 0;
    var codegen_1 = require_codegen();
    var code_1 = require_code();
    function toHash(arr) {
      const hash = {};
      for (const item of arr)
        hash[item] = true;
      return hash;
    }
    exports2.toHash = toHash;
    function alwaysValidSchema(it, schema) {
      if (typeof schema == "boolean")
        return schema;
      if (Object.keys(schema).length === 0)
        return true;
      checkUnknownRules(it, schema);
      return !schemaHasRules(schema, it.self.RULES.all);
    }
    exports2.alwaysValidSchema = alwaysValidSchema;
    function checkUnknownRules(it, schema = it.schema) {
      const { opts, self: self2 } = it;
      if (!opts.strictSchema)
        return;
      if (typeof schema === "boolean")
        return;
      const rules = self2.RULES.keywords;
      for (const key in schema) {
        if (!rules[key])
          checkStrictMode(it, `unknown keyword: "${key}"`);
      }
    }
    exports2.checkUnknownRules = checkUnknownRules;
    function schemaHasRules(schema, rules) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (rules[key])
          return true;
      return false;
    }
    exports2.schemaHasRules = schemaHasRules;
    function schemaHasRulesButRef(schema, RULES) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (key !== "$ref" && RULES.all[key])
          return true;
      return false;
    }
    exports2.schemaHasRulesButRef = schemaHasRulesButRef;
    function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
      if (!$data) {
        if (typeof schema == "number" || typeof schema == "boolean")
          return schema;
        if (typeof schema == "string")
          return (0, codegen_1._)`${schema}`;
      }
      return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;
    }
    exports2.schemaRefOrVal = schemaRefOrVal;
    function unescapeFragment(str) {
      return unescapeJsonPointer(decodeURIComponent(str));
    }
    exports2.unescapeFragment = unescapeFragment;
    function escapeFragment(str) {
      return encodeURIComponent(escapeJsonPointer(str));
    }
    exports2.escapeFragment = escapeFragment;
    function escapeJsonPointer(str) {
      if (typeof str == "number")
        return `${str}`;
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    exports2.escapeJsonPointer = escapeJsonPointer;
    function unescapeJsonPointer(str) {
      return str.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    exports2.unescapeJsonPointer = unescapeJsonPointer;
    function eachItem(xs, f) {
      if (Array.isArray(xs)) {
        for (const x of xs)
          f(x);
      } else {
        f(xs);
      }
    }
    exports2.eachItem = eachItem;
    function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {
      return (gen, from, to, toName) => {
        const res = to === void 0 ? from : to instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);
        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
      };
    }
    exports2.mergeEvaluated = {
      props: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => {
          gen.if((0, codegen_1._)`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._)`${to} || {}`).code((0, codegen_1._)`Object.assign(${to}, ${from})`));
        }),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => {
          if (from === true) {
            gen.assign(to, true);
          } else {
            gen.assign(to, (0, codegen_1._)`${to} || {}`);
            setEvaluated(gen, to, from);
          }
        }),
        mergeValues: (from, to) => from === true ? true : { ...from, ...to },
        resultToName: evaluatedPropsToName
      }),
      items: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._)`${to} > ${from} ? ${to} : ${from}`)),
        mergeValues: (from, to) => from === true ? true : Math.max(from, to),
        resultToName: (gen, items) => gen.var("items", items)
      })
    };
    function evaluatedPropsToName(gen, ps) {
      if (ps === true)
        return gen.var("props", true);
      const props = gen.var("props", (0, codegen_1._)`{}`);
      if (ps !== void 0)
        setEvaluated(gen, props, ps);
      return props;
    }
    exports2.evaluatedPropsToName = evaluatedPropsToName;
    function setEvaluated(gen, props, ps) {
      Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p)}`, true));
    }
    exports2.setEvaluated = setEvaluated;
    var snippets = {};
    function useFunc(gen, f) {
      return gen.scopeValue("func", {
        ref: f,
        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))
      });
    }
    exports2.useFunc = useFunc;
    var Type;
    (function(Type2) {
      Type2[Type2["Num"] = 0] = "Num";
      Type2[Type2["Str"] = 1] = "Str";
    })(Type || (exports2.Type = Type = {}));
    function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
      if (dataProp instanceof codegen_1.Name) {
        const isNumber = dataPropType === Type.Num;
        return jsPropertySyntax ? isNumber ? (0, codegen_1._)`"[" + ${dataProp} + "]"` : (0, codegen_1._)`"['" + ${dataProp} + "']"` : isNumber ? (0, codegen_1._)`"/" + ${dataProp}` : (0, codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
      }
      return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
    }
    exports2.getErrorPath = getErrorPath;
    function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
      if (!mode)
        return;
      msg = `strict mode: ${msg}`;
      if (mode === true)
        throw new Error(msg);
      it.self.logger.warn(msg);
    }
    exports2.checkStrictMode = checkStrictMode;
  }
});

// node_modules/conf/node_modules/ajv/dist/compile/names.js
var require_names = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/compile/names.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var names = {
      // validation function arguments
      data: new codegen_1.Name("data"),
      // data passed to validation function
      // args passed from referencing schema
      valCxt: new codegen_1.Name("valCxt"),
      // validation/data context - should not be used directly, it is destructured to the names below
      instancePath: new codegen_1.Name("instancePath"),
      parentData: new codegen_1.Name("parentData"),
      parentDataProperty: new codegen_1.Name("parentDataProperty"),
      rootData: new codegen_1.Name("rootData"),
      // root data - same as the data passed to the first/top validation function
      dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
      // used to support recursiveRef and dynamicRef
      // function scoped variables
      vErrors: new codegen_1.Name("vErrors"),
      // null or array of validation errors
      errors: new codegen_1.Name("errors"),
      // counter of validation errors
      this: new codegen_1.Name("this"),
      // "globals"
      self: new codegen_1.Name("self"),
      scope: new codegen_1.Name("scope"),
      // JTD serialize/parse name for JSON string and position
      json: new codegen_1.Name("json"),
      jsonPos: new codegen_1.Name("jsonPos"),
      jsonLen: new codegen_1.Name("jsonLen"),
      jsonPart: new codegen_1.Name("jsonPart")
    };
    exports2.default = names;
  }
});

// node_modules/conf/node_modules/ajv/dist/compile/errors.js
var require_errors = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/compile/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.extendErrors = exports2.resetErrorsCount = exports2.reportExtraError = exports2.reportError = exports2.keyword$DataError = exports2.keywordError = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var names_1 = require_names();
    exports2.keywordError = {
      message: ({ keyword }) => (0, codegen_1.str)`must pass "${keyword}" keyword validation`
    };
    exports2.keyword$DataError = {
      message: ({ keyword, schemaType }) => schemaType ? (0, codegen_1.str)`"${keyword}" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`"${keyword}" keyword is invalid ($data)`
    };
    function reportError(cxt, error = exports2.keywordError, errorPaths, overrideAllErrors) {
      const { it } = cxt;
      const { gen, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
        addError(gen, errObj);
      } else {
        returnErrors(it, (0, codegen_1._)`[${errObj}]`);
      }
    }
    exports2.reportError = reportError;
    function reportExtraError(cxt, error = exports2.keywordError, errorPaths) {
      const { it } = cxt;
      const { gen, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      addError(gen, errObj);
      if (!(compositeRule || allErrors)) {
        returnErrors(it, names_1.default.vErrors);
      }
    }
    exports2.reportExtraError = reportExtraError;
    function resetErrorsCount(gen, errsCount) {
      gen.assign(names_1.default.errors, errsCount);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
    }
    exports2.resetErrorsCount = resetErrorsCount;
    function extendErrors({ gen, keyword, schemaValue, data, errsCount, it }) {
      if (errsCount === void 0)
        throw new Error("ajv implementation error");
      const err = gen.name("err");
      gen.forRange("i", errsCount, names_1.default.errors, (i) => {
        gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`);
        gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._)`${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));
        gen.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it.errSchemaPath}/${keyword}`);
        if (it.opts.verbose) {
          gen.assign((0, codegen_1._)`${err}.schema`, schemaValue);
          gen.assign((0, codegen_1._)`${err}.data`, data);
        }
      });
    }
    exports2.extendErrors = extendErrors;
    function addError(gen, errObj) {
      const err = gen.const("err", errObj);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`);
      gen.code((0, codegen_1._)`${names_1.default.errors}++`);
    }
    function returnErrors(it, errs) {
      const { gen, validateName, schemaEnv } = it;
      if (schemaEnv.$async) {
        gen.throw((0, codegen_1._)`new ${it.ValidationError}(${errs})`);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, errs);
        gen.return(false);
      }
    }
    var E = {
      keyword: new codegen_1.Name("keyword"),
      schemaPath: new codegen_1.Name("schemaPath"),
      // also used in JTD errors
      params: new codegen_1.Name("params"),
      propertyName: new codegen_1.Name("propertyName"),
      message: new codegen_1.Name("message"),
      schema: new codegen_1.Name("schema"),
      parentSchema: new codegen_1.Name("parentSchema")
    };
    function errorObjectCode(cxt, error, errorPaths) {
      const { createErrors } = cxt.it;
      if (createErrors === false)
        return (0, codegen_1._)`{}`;
      return errorObject(cxt, error, errorPaths);
    }
    function errorObject(cxt, error, errorPaths = {}) {
      const { gen, it } = cxt;
      const keyValues = [
        errorInstancePath(it, errorPaths),
        errorSchemaPath(cxt, errorPaths)
      ];
      extraErrorProps(cxt, error, keyValues);
      return gen.object(...keyValues);
    }
    function errorInstancePath({ errorPath }, { instancePath }) {
      const instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;
      return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
    }
    function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
      let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword}`;
      if (schemaPath) {
        schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
      }
      return [E.schemaPath, schPath];
    }
    function extraErrorProps(cxt, { params, message }, keyValues) {
      const { keyword, data, schemaValue, it } = cxt;
      const { opts, propertyName, topSchemaRef, schemaPath } = it;
      keyValues.push([E.keyword, keyword], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._)`{}`]);
      if (opts.messages) {
        keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
      }
      if (opts.verbose) {
        keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
      }
      if (propertyName)
        keyValues.push([E.propertyName, propertyName]);
    }
  }
});

// node_modules/conf/node_modules/ajv/dist/compile/validate/boolSchema.js
var require_boolSchema = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/compile/validate/boolSchema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.boolOrEmptySchema = exports2.topBoolOrEmptySchema = void 0;
    var errors_1 = require_errors();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var boolError = {
      message: "boolean schema is false"
    };
    function topBoolOrEmptySchema(it) {
      const { gen, schema, validateName } = it;
      if (schema === false) {
        falseSchemaError(it, false);
      } else if (typeof schema == "object" && schema.$async === true) {
        gen.return(names_1.default.data);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, null);
        gen.return(true);
      }
    }
    exports2.topBoolOrEmptySchema = topBoolOrEmptySchema;
    function boolOrEmptySchema(it, valid) {
      const { gen, schema } = it;
      if (schema === false) {
        gen.var(valid, false);
        falseSchemaError(it);
      } else {
        gen.var(valid, true);
      }
    }
    exports2.boolOrEmptySchema = boolOrEmptySchema;
    function falseSchemaError(it, overrideAllErrors) {
      const { gen, data } = it;
      const cxt = {
        gen,
        keyword: "false schema",
        data,
        schema: false,
        schemaCode: false,
        schemaValue: false,
        params: {},
        it
      };
      (0, errors_1.reportError)(cxt, boolError, void 0, overrideAllErrors);
    }
  }
});

// node_modules/conf/node_modules/ajv/dist/compile/rules.js
var require_rules = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/compile/rules.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getRules = exports2.isJSONType = void 0;
    var _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
    var jsonTypes = new Set(_jsonTypes);
    function isJSONType(x) {
      return typeof x == "string" && jsonTypes.has(x);
    }
    exports2.isJSONType = isJSONType;
    function getRules() {
      const groups = {
        number: { type: "number", rules: [] },
        string: { type: "string", rules: [] },
        array: { type: "array", rules: [] },
        object: { type: "object", rules: [] }
      };
      return {
        types: { ...groups, integer: true, boolean: true, null: true },
        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
        post: { rules: [] },
        all: {},
        keywords: {}
      };
    }
    exports2.getRules = getRules;
  }
});

// node_modules/conf/node_modules/ajv/dist/compile/validate/applicability.js
var require_applicability = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/compile/validate/applicability.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.shouldUseRule = exports2.shouldUseGroup = exports2.schemaHasRulesForType = void 0;
    function schemaHasRulesForType({ schema, self: self2 }, type) {
      const group = self2.RULES.types[type];
      return group && group !== true && shouldUseGroup(schema, group);
    }
    exports2.schemaHasRulesForType = schemaHasRulesForType;
    function shouldUseGroup(schema, group) {
      return group.rules.some((rule) => shouldUseRule(schema, rule));
    }
    exports2.shouldUseGroup = shouldUseGroup;
    function shouldUseRule(schema, rule) {
      var _a;
      return schema[rule.keyword] !== void 0 || ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== void 0));
    }
    exports2.shouldUseRule = shouldUseRule;
  }
});

// node_modules/conf/node_modules/ajv/dist/compile/validate/dataType.js
var require_dataType = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/compile/validate/dataType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.reportTypeError = exports2.checkDataTypes = exports2.checkDataType = exports2.coerceAndCheckDataType = exports2.getJSONTypes = exports2.getSchemaTypes = exports2.DataType = void 0;
    var rules_1 = require_rules();
    var applicability_1 = require_applicability();
    var errors_1 = require_errors();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var DataType;
    (function(DataType2) {
      DataType2[DataType2["Correct"] = 0] = "Correct";
      DataType2[DataType2["Wrong"] = 1] = "Wrong";
    })(DataType || (exports2.DataType = DataType = {}));
    function getSchemaTypes(schema) {
      const types = getJSONTypes(schema.type);
      const hasNull = types.includes("null");
      if (hasNull) {
        if (schema.nullable === false)
          throw new Error("type: null contradicts nullable: false");
      } else {
        if (!types.length && schema.nullable !== void 0) {
          throw new Error('"nullable" cannot be used without "type"');
        }
        if (schema.nullable === true)
          types.push("null");
      }
      return types;
    }
    exports2.getSchemaTypes = getSchemaTypes;
    function getJSONTypes(ts) {
      const types = Array.isArray(ts) ? ts : ts ? [ts] : [];
      if (types.every(rules_1.isJSONType))
        return types;
      throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
    }
    exports2.getJSONTypes = getJSONTypes;
    function coerceAndCheckDataType(it, types) {
      const { gen, data, opts } = it;
      const coerceTo = coerceToTypes(types, opts.coerceTypes);
      const checkTypes = types.length > 0 && !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));
      if (checkTypes) {
        const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
        gen.if(wrongType, () => {
          if (coerceTo.length)
            coerceData(it, types, coerceTo);
          else
            reportTypeError(it);
        });
      }
      return checkTypes;
    }
    exports2.coerceAndCheckDataType = coerceAndCheckDataType;
    var COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
    function coerceToTypes(types, coerceTypes) {
      return coerceTypes ? types.filter((t) => COERCIBLE.has(t) || coerceTypes === "array" && t === "array") : [];
    }
    function coerceData(it, types, coerceTo) {
      const { gen, data, opts } = it;
      const dataType = gen.let("dataType", (0, codegen_1._)`typeof ${data}`);
      const coerced = gen.let("coerced", (0, codegen_1._)`undefined`);
      if (opts.coerceTypes === "array") {
        gen.if((0, codegen_1._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1._)`${data}[0]`).assign(dataType, (0, codegen_1._)`typeof ${data}`).if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));
      }
      gen.if((0, codegen_1._)`${coerced} !== undefined`);
      for (const t of coerceTo) {
        if (COERCIBLE.has(t) || t === "array" && opts.coerceTypes === "array") {
          coerceSpecificType(t);
        }
      }
      gen.else();
      reportTypeError(it);
      gen.endIf();
      gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {
        gen.assign(data, coerced);
        assignParentData(it, coerced);
      });
      function coerceSpecificType(t) {
        switch (t) {
          case "string":
            gen.elseIf((0, codegen_1._)`${dataType} == "number" || ${dataType} == "boolean"`).assign(coerced, (0, codegen_1._)`"" + ${data}`).elseIf((0, codegen_1._)`${data} === null`).assign(coerced, (0, codegen_1._)`""`);
            return;
          case "number":
            gen.elseIf((0, codegen_1._)`${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "integer":
            gen.elseIf((0, codegen_1._)`${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "boolean":
            gen.elseIf((0, codegen_1._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
            return;
          case "null":
            gen.elseIf((0, codegen_1._)`${data} === "" || ${data} === 0 || ${data} === false`);
            gen.assign(coerced, null);
            return;
          case "array":
            gen.elseIf((0, codegen_1._)`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1._)`[${data}]`);
        }
      }
    }
    function assignParentData({ gen, parentData, parentDataProperty }, expr) {
      gen.if((0, codegen_1._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));
    }
    function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
      const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
      let cond;
      switch (dataType) {
        case "null":
          return (0, codegen_1._)`${data} ${EQ} null`;
        case "array":
          cond = (0, codegen_1._)`Array.isArray(${data})`;
          break;
        case "object":
          cond = (0, codegen_1._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
          break;
        case "integer":
          cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);
          break;
        case "number":
          cond = numCond();
          break;
        default:
          return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType}`;
      }
      return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
      function numCond(_cond = codegen_1.nil) {
        return (0, codegen_1.and)((0, codegen_1._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil);
      }
    }
    exports2.checkDataType = checkDataType;
    function checkDataTypes(dataTypes, data, strictNums, correct) {
      if (dataTypes.length === 1) {
        return checkDataType(dataTypes[0], data, strictNums, correct);
      }
      let cond;
      const types = (0, util_1.toHash)(dataTypes);
      if (types.array && types.object) {
        const notObj = (0, codegen_1._)`typeof ${data} != "object"`;
        cond = types.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`;
        delete types.null;
        delete types.array;
        delete types.object;
      } else {
        cond = codegen_1.nil;
      }
      if (types.number)
        delete types.integer;
      for (const t in types)
        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));
      return cond;
    }
    exports2.checkDataTypes = checkDataTypes;
    var typeError = {
      message: ({ schema }) => `must be ${schema}`,
      params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`
    };
    function reportTypeError(it) {
      const cxt = getTypeErrorContext(it);
      (0, errors_1.reportError)(cxt, typeError);
    }
    exports2.reportTypeError = reportTypeError;
    function getTypeErrorContext(it) {
      const { gen, data, schema } = it;
      const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
      return {
        gen,
        keyword: "type",
        data,
        schema: schema.type,
        schemaCode,
        schemaValue: schemaCode,
        parentSchema: schema,
        params: {},
        it
      };
    }
  }
});

// node_modules/conf/node_modules/ajv/dist/compile/validate/defaults.js
var require_defaults = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/compile/validate/defaults.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.assignDefaults = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    function assignDefaults(it, ty) {
      const { properties, items } = it.schema;
      if (ty === "object" && properties) {
        for (const key in properties) {
          assignDefault(it, key, properties[key].default);
        }
      } else if (ty === "array" && Array.isArray(items)) {
        items.forEach((sch, i) => assignDefault(it, i, sch.default));
      }
    }
    exports2.assignDefaults = assignDefaults;
    function assignDefault(it, prop, defaultValue) {
      const { gen, compositeRule, data, opts } = it;
      if (defaultValue === void 0)
        return;
      const childData = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(prop)}`;
      if (compositeRule) {
        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
        return;
      }
      let condition = (0, codegen_1._)`${childData} === undefined`;
      if (opts.useDefaults === "empty") {
        condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`;
      }
      gen.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
    }
  }
});

// node_modules/conf/node_modules/ajv/dist/vocabularies/code.js
var require_code2 = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/vocabularies/code.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateUnion = exports2.validateArray = exports2.usePattern = exports2.callValidateCode = exports2.schemaProperties = exports2.allSchemaProperties = exports2.noPropertyInData = exports2.propertyInData = exports2.isOwnProperty = exports2.hasPropFunc = exports2.reportMissingProp = exports2.checkMissingProp = exports2.checkReportMissingProp = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var names_1 = require_names();
    var util_2 = require_util();
    function checkReportMissingProp(cxt, prop) {
      const { gen, data, it } = cxt;
      gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
        cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, true);
        cxt.error();
      });
    }
    exports2.checkReportMissingProp = checkReportMissingProp;
    function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
      return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));
    }
    exports2.checkMissingProp = checkMissingProp;
    function reportMissingProp(cxt, missing) {
      cxt.setParams({ missingProperty: missing }, true);
      cxt.error();
    }
    exports2.reportMissingProp = reportMissingProp;
    function hasPropFunc(gen) {
      return gen.scopeValue("func", {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        ref: Object.prototype.hasOwnProperty,
        code: (0, codegen_1._)`Object.prototype.hasOwnProperty`
      });
    }
    exports2.hasPropFunc = hasPropFunc;
    function isOwnProperty(gen, data, property) {
      return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
    }
    exports2.isOwnProperty = isOwnProperty;
    function propertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
      return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
    }
    exports2.propertyInData = propertyInData;
    function noPropertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} === undefined`;
      return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
    }
    exports2.noPropertyInData = noPropertyInData;
    function allSchemaProperties(schemaMap) {
      return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
    }
    exports2.allSchemaProperties = allSchemaProperties;
    function schemaProperties(it, schemaMap) {
      return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));
    }
    exports2.schemaProperties = schemaProperties;
    function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
      const dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
      const valCxt = [
        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
        [names_1.default.parentData, it.parentData],
        [names_1.default.parentDataProperty, it.parentDataProperty],
        [names_1.default.rootData, names_1.default.rootData]
      ];
      if (it.opts.dynamicRef)
        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
      const args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
      return context !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context}, ${args})` : (0, codegen_1._)`${func}(${args})`;
    }
    exports2.callValidateCode = callValidateCode;
    var newRegExp = (0, codegen_1._)`new RegExp`;
    function usePattern({ gen, it: { opts } }, pattern) {
      const u = opts.unicodeRegExp ? "u" : "";
      const { regExp } = opts.code;
      const rx = regExp(pattern, u);
      return gen.scopeValue("pattern", {
        key: rx.toString(),
        ref: rx,
        code: (0, codegen_1._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`
      });
    }
    exports2.usePattern = usePattern;
    function validateArray(cxt) {
      const { gen, data, keyword, it } = cxt;
      const valid = gen.name("valid");
      if (it.allErrors) {
        const validArr = gen.let("valid", true);
        validateItems(() => gen.assign(validArr, false));
        return validArr;
      }
      gen.var(valid, true);
      validateItems(() => gen.break());
      return valid;
      function validateItems(notValid) {
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        gen.forRange("i", 0, len, (i) => {
          cxt.subschema({
            keyword,
            dataProp: i,
            dataPropType: util_1.Type.Num
          }, valid);
          gen.if((0, codegen_1.not)(valid), notValid);
        });
      }
    }
    exports2.validateArray = validateArray;
    function validateUnion(cxt) {
      const { gen, schema, keyword, it } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));
      if (alwaysValid && !it.opts.unevaluated)
        return;
      const valid = gen.let("valid", false);
      const schValid = gen.name("_valid");
      gen.block(() => schema.forEach((_sch, i) => {
        const schCxt = cxt.subschema({
          keyword,
          schemaProp: i,
          compositeRule: true
        }, schValid);
        gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`);
        const merged = cxt.mergeValidEvaluated(schCxt, schValid);
        if (!merged)
          gen.if((0, codegen_1.not)(valid));
      }));
      cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
    }
    exports2.validateUnion = validateUnion;
  }
});

// node_modules/conf/node_modules/ajv/dist/compile/validate/keyword.js
var require_keyword = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/compile/validate/keyword.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateKeywordUsage = exports2.validSchemaType = exports2.funcKeywordCode = exports2.macroKeywordCode = void 0;
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var code_1 = require_code2();
    var errors_1 = require_errors();
    function macroKeywordCode(cxt, def) {
      const { gen, keyword, schema, parentSchema, it } = cxt;
      const macroSchema = def.macro.call(it.self, schema, parentSchema, it);
      const schemaRef = useKeyword(gen, keyword, macroSchema);
      if (it.opts.validateSchema !== false)
        it.self.validateSchema(macroSchema, true);
      const valid = gen.name("valid");
      cxt.subschema({
        schema: macroSchema,
        schemaPath: codegen_1.nil,
        errSchemaPath: `${it.errSchemaPath}/${keyword}`,
        topSchemaRef: schemaRef,
        compositeRule: true
      }, valid);
      cxt.pass(valid, () => cxt.error(true));
    }
    exports2.macroKeywordCode = macroKeywordCode;
    function funcKeywordCode(cxt, def) {
      var _a;
      const { gen, keyword, schema, parentSchema, $data, it } = cxt;
      checkAsyncKeyword(it, def);
      const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;
      const validateRef = useKeyword(gen, keyword, validate);
      const valid = gen.let("valid");
      cxt.block$data(valid, validateKeyword);
      cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);
      function validateKeyword() {
        if (def.errors === false) {
          assignValid();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => cxt.error());
        } else {
          const ruleErrs = def.async ? validateAsync() : validateSync();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => addErrs(cxt, ruleErrs));
        }
      }
      function validateAsync() {
        const ruleErrs = gen.let("ruleErrs", null);
        gen.try(() => assignValid((0, codegen_1._)`await `), (e) => gen.assign(valid, false).if((0, codegen_1._)`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e}.errors`), () => gen.throw(e)));
        return ruleErrs;
      }
      function validateSync() {
        const validateErrs = (0, codegen_1._)`${validateRef}.errors`;
        gen.assign(validateErrs, null);
        assignValid(codegen_1.nil);
        return validateErrs;
      }
      function assignValid(_await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil) {
        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
        const passSchema = !("compile" in def && !$data || def.schema === false);
        gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
      }
      function reportErrs(errors) {
        var _a2;
        gen.if((0, codegen_1.not)((_a2 = def.valid) !== null && _a2 !== void 0 ? _a2 : valid), errors);
      }
    }
    exports2.funcKeywordCode = funcKeywordCode;
    function modifyData(cxt) {
      const { gen, data, it } = cxt;
      gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._)`${it.parentData}[${it.parentDataProperty}]`));
    }
    function addErrs(cxt, errs) {
      const { gen } = cxt;
      gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
        (0, errors_1.extendErrors)(cxt);
      }, () => cxt.error());
    }
    function checkAsyncKeyword({ schemaEnv }, def) {
      if (def.async && !schemaEnv.$async)
        throw new Error("async keyword in sync schema");
    }
    function useKeyword(gen, keyword, result) {
      if (result === void 0)
        throw new Error(`keyword "${keyword}" failed to compile`);
      return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
    }
    function validSchemaType(schema, schemaType, allowUndefined = false) {
      return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema) : st === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == "undefined");
    }
    exports2.validSchemaType = validSchemaType;
    function validateKeywordUsage({ schema, opts, self: self2, errSchemaPath }, def, keyword) {
      if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
        throw new Error("ajv implementation error");
      }
      const deps = def.dependencies;
      if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
      }
      if (def.validateSchema) {
        const valid = def.validateSchema(schema[keyword]);
        if (!valid) {
          const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` + self2.errorsText(def.validateSchema.errors);
          if (opts.validateSchema === "log")
            self2.logger.error(msg);
          else
            throw new Error(msg);
        }
      }
    }
    exports2.validateKeywordUsage = validateKeywordUsage;
  }
});

// node_modules/conf/node_modules/ajv/dist/compile/validate/subschema.js
var require_subschema = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/compile/validate/subschema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.extendSubschemaMode = exports2.extendSubschemaData = exports2.getSubschema = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    function getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
      if (keyword !== void 0 && schema !== void 0) {
        throw new Error('both "keyword" and "schema" passed, only one allowed');
      }
      if (keyword !== void 0) {
        const sch = it.schema[keyword];
        return schemaProp === void 0 ? {
          schema: sch,
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword}`
        } : {
          schema: sch[schemaProp],
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`
        };
      }
      if (schema !== void 0) {
        if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
          throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
        }
        return {
          schema,
          schemaPath,
          topSchemaRef,
          errSchemaPath
        };
      }
      throw new Error('either "keyword" or "schema" must be passed');
    }
    exports2.getSubschema = getSubschema;
    function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
      if (data !== void 0 && dataProp !== void 0) {
        throw new Error('both "data" and "dataProp" passed, only one allowed');
      }
      const { gen } = it;
      if (dataProp !== void 0) {
        const { errorPath, dataPathArr, opts } = it;
        const nextData = gen.let("data", (0, codegen_1._)`${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
        dataContextProps(nextData);
        subschema.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
        subschema.parentDataProperty = (0, codegen_1._)`${dataProp}`;
        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
      }
      if (data !== void 0) {
        const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true);
        dataContextProps(nextData);
        if (propertyName !== void 0)
          subschema.propertyName = propertyName;
      }
      if (dataTypes)
        subschema.dataTypes = dataTypes;
      function dataContextProps(_nextData) {
        subschema.data = _nextData;
        subschema.dataLevel = it.dataLevel + 1;
        subschema.dataTypes = [];
        it.definedProperties = /* @__PURE__ */ new Set();
        subschema.parentData = it.data;
        subschema.dataNames = [...it.dataNames, _nextData];
      }
    }
    exports2.extendSubschemaData = extendSubschemaData;
    function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
      if (compositeRule !== void 0)
        subschema.compositeRule = compositeRule;
      if (createErrors !== void 0)
        subschema.createErrors = createErrors;
      if (allErrors !== void 0)
        subschema.allErrors = allErrors;
      subschema.jtdDiscriminator = jtdDiscriminator;
      subschema.jtdMetadata = jtdMetadata;
    }
    exports2.extendSubschemaMode = extendSubschemaMode;
  }
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "node_modules/fast-deep-equal/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function equal(a, b) {
      if (a === b) return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor) return false;
        var length, i, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length) return false;
          for (i = length; i-- !== 0; )
            if (!equal(a[i], b[i])) return false;
          return true;
        }
        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length) return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal(a[key], b[key])) return false;
        }
        return true;
      }
      return a !== a && b !== b;
    };
  }
});

// node_modules/conf/node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = __commonJS({
  "node_modules/conf/node_modules/json-schema-traverse/index.js"(exports2, module2) {
    "use strict";
    var traverse = module2.exports = function(schema, opts, cb) {
      if (typeof opts == "function") {
        cb = opts;
        opts = {};
      }
      cb = opts.cb || cb;
      var pre = typeof cb == "function" ? cb : cb.pre || function() {
      };
      var post = cb.post || function() {
      };
      _traverse(opts, pre, post, schema, "", schema);
    };
    traverse.keywords = {
      additionalItems: true,
      items: true,
      contains: true,
      additionalProperties: true,
      propertyNames: true,
      not: true,
      if: true,
      then: true,
      else: true
    };
    traverse.arrayKeywords = {
      items: true,
      allOf: true,
      anyOf: true,
      oneOf: true
    };
    traverse.propsKeywords = {
      $defs: true,
      definitions: true,
      properties: true,
      patternProperties: true,
      dependencies: true
    };
    traverse.skipKeywords = {
      default: true,
      enum: true,
      const: true,
      required: true,
      maximum: true,
      minimum: true,
      exclusiveMaximum: true,
      exclusiveMinimum: true,
      multipleOf: true,
      maxLength: true,
      minLength: true,
      pattern: true,
      format: true,
      maxItems: true,
      minItems: true,
      uniqueItems: true,
      maxProperties: true,
      minProperties: true
    };
    function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (schema && typeof schema == "object" && !Array.isArray(schema)) {
        pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for (var key in schema) {
          var sch = schema[key];
          if (Array.isArray(sch)) {
            if (key in traverse.arrayKeywords) {
              for (var i = 0; i < sch.length; i++)
                _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
            }
          } else if (key in traverse.propsKeywords) {
            if (sch && typeof sch == "object") {
              for (var prop in sch)
                _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
            }
          } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
            _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
          }
        }
        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      }
    }
    function escapeJsonPtr(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
  }
});

// node_modules/conf/node_modules/ajv/dist/compile/resolve.js
var require_resolve = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/compile/resolve.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getSchemaRefs = exports2.resolveUrl = exports2.normalizeId = exports2._getFullPath = exports2.getFullPath = exports2.inlineRef = void 0;
    var util_1 = require_util();
    var equal = require_fast_deep_equal();
    var traverse = require_json_schema_traverse();
    var SIMPLE_INLINED = /* @__PURE__ */ new Set([
      "type",
      "format",
      "pattern",
      "maxLength",
      "minLength",
      "maxProperties",
      "minProperties",
      "maxItems",
      "minItems",
      "maximum",
      "minimum",
      "uniqueItems",
      "multipleOf",
      "required",
      "enum",
      "const"
    ]);
    function inlineRef(schema, limit = true) {
      if (typeof schema == "boolean")
        return true;
      if (limit === true)
        return !hasRef(schema);
      if (!limit)
        return false;
      return countKeys(schema) <= limit;
    }
    exports2.inlineRef = inlineRef;
    var REF_KEYWORDS = /* @__PURE__ */ new Set([
      "$ref",
      "$recursiveRef",
      "$recursiveAnchor",
      "$dynamicRef",
      "$dynamicAnchor"
    ]);
    function hasRef(schema) {
      for (const key in schema) {
        if (REF_KEYWORDS.has(key))
          return true;
        const sch = schema[key];
        if (Array.isArray(sch) && sch.some(hasRef))
          return true;
        if (typeof sch == "object" && hasRef(sch))
          return true;
      }
      return false;
    }
    function countKeys(schema) {
      let count = 0;
      for (const key in schema) {
        if (key === "$ref")
          return Infinity;
        count++;
        if (SIMPLE_INLINED.has(key))
          continue;
        if (typeof schema[key] == "object") {
          (0, util_1.eachItem)(schema[key], (sch) => count += countKeys(sch));
        }
        if (count === Infinity)
          return Infinity;
      }
      return count;
    }
    function getFullPath(resolver, id = "", normalize) {
      if (normalize !== false)
        id = normalizeId(id);
      const p = resolver.parse(id);
      return _getFullPath(resolver, p);
    }
    exports2.getFullPath = getFullPath;
    function _getFullPath(resolver, p) {
      const serialized = resolver.serialize(p);
      return serialized.split("#")[0] + "#";
    }
    exports2._getFullPath = _getFullPath;
    var TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id) {
      return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
    }
    exports2.normalizeId = normalizeId;
    function resolveUrl(resolver, baseId, id) {
      id = normalizeId(id);
      return resolver.resolve(baseId, id);
    }
    exports2.resolveUrl = resolveUrl;
    var ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
    function getSchemaRefs(schema, baseId) {
      if (typeof schema == "boolean")
        return {};
      const { schemaId, uriResolver } = this.opts;
      const schId = normalizeId(schema[schemaId] || baseId);
      const baseIds = { "": schId };
      const pathPrefix = getFullPath(uriResolver, schId, false);
      const localRefs = {};
      const schemaRefs = /* @__PURE__ */ new Set();
      traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
        if (parentJsonPtr === void 0)
          return;
        const fullPath = pathPrefix + jsonPtr;
        let innerBaseId = baseIds[parentJsonPtr];
        if (typeof sch[schemaId] == "string")
          innerBaseId = addRef.call(this, sch[schemaId]);
        addAnchor.call(this, sch.$anchor);
        addAnchor.call(this, sch.$dynamicAnchor);
        baseIds[jsonPtr] = innerBaseId;
        function addRef(ref) {
          const _resolve = this.opts.uriResolver.resolve;
          ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref);
          if (schemaRefs.has(ref))
            throw ambiguos(ref);
          schemaRefs.add(ref);
          let schOrRef = this.refs[ref];
          if (typeof schOrRef == "string")
            schOrRef = this.refs[schOrRef];
          if (typeof schOrRef == "object") {
            checkAmbiguosRef(sch, schOrRef.schema, ref);
          } else if (ref !== normalizeId(fullPath)) {
            if (ref[0] === "#") {
              checkAmbiguosRef(sch, localRefs[ref], ref);
              localRefs[ref] = sch;
            } else {
              this.refs[ref] = fullPath;
            }
          }
          return ref;
        }
        function addAnchor(anchor) {
          if (typeof anchor == "string") {
            if (!ANCHOR.test(anchor))
              throw new Error(`invalid anchor "${anchor}"`);
            addRef.call(this, `#${anchor}`);
          }
        }
      });
      return localRefs;
      function checkAmbiguosRef(sch1, sch2, ref) {
        if (sch2 !== void 0 && !equal(sch1, sch2))
          throw ambiguos(ref);
      }
      function ambiguos(ref) {
        return new Error(`reference "${ref}" resolves to more than one schema`);
      }
    }
    exports2.getSchemaRefs = getSchemaRefs;
  }
});

// node_modules/conf/node_modules/ajv/dist/compile/validate/index.js
var require_validate = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/compile/validate/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getData = exports2.KeywordCxt = exports2.validateFunctionCode = void 0;
    var boolSchema_1 = require_boolSchema();
    var dataType_1 = require_dataType();
    var applicability_1 = require_applicability();
    var dataType_2 = require_dataType();
    var defaults_1 = require_defaults();
    var keyword_1 = require_keyword();
    var subschema_1 = require_subschema();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var resolve_1 = require_resolve();
    var util_1 = require_util();
    var errors_1 = require_errors();
    function validateFunctionCode(it) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          topSchemaObjCode(it);
          return;
        }
      }
      validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
    }
    exports2.validateFunctionCode = validateFunctionCode;
    function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
      if (opts.code.es5) {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
          gen.code((0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts)}`);
          destructureValCxtES5(gen, opts);
          gen.code(body);
        });
      } else {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
      }
    }
    function destructureValCxt(opts) {
      return (0, codegen_1._)`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
    }
    function destructureValCxtES5(gen, opts) {
      gen.if(names_1.default.valCxt, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
        gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
      }, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`""`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.rootData, names_1.default.data);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
      });
    }
    function topSchemaObjCode(it) {
      const { schema, opts, gen } = it;
      validateFunction(it, () => {
        if (opts.$comment && schema.$comment)
          commentKeyword(it);
        checkNoDefault(it);
        gen.let(names_1.default.vErrors, null);
        gen.let(names_1.default.errors, 0);
        if (opts.unevaluated)
          resetEvaluated(it);
        typeAndKeywords(it);
        returnResults(it);
      });
      return;
    }
    function resetEvaluated(it) {
      const { gen, validateName } = it;
      it.evaluated = gen.const("evaluated", (0, codegen_1._)`${validateName}.evaluated`);
      gen.if((0, codegen_1._)`${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._)`${it.evaluated}.props`, (0, codegen_1._)`undefined`));
      gen.if((0, codegen_1._)`${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._)`${it.evaluated}.items`, (0, codegen_1._)`undefined`));
    }
    function funcSourceUrl(schema, opts) {
      const schId = typeof schema == "object" && schema[opts.schemaId];
      return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;
    }
    function subschemaCode(it, valid) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          subSchemaObjCode(it, valid);
          return;
        }
      }
      (0, boolSchema_1.boolOrEmptySchema)(it, valid);
    }
    function schemaCxtHasRules({ schema, self: self2 }) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (self2.RULES.all[key])
          return true;
      return false;
    }
    function isSchemaObj(it) {
      return typeof it.schema != "boolean";
    }
    function subSchemaObjCode(it, valid) {
      const { schema, gen, opts } = it;
      if (opts.$comment && schema.$comment)
        commentKeyword(it);
      updateContext(it);
      checkAsyncSchema(it);
      const errsCount = gen.const("_errs", names_1.default.errors);
      typeAndKeywords(it, errsCount);
      gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
    }
    function checkKeywords(it) {
      (0, util_1.checkUnknownRules)(it);
      checkRefsAndKeywords(it);
    }
    function typeAndKeywords(it, errsCount) {
      if (it.opts.jtd)
        return schemaKeywords(it, [], false, errsCount);
      const types = (0, dataType_1.getSchemaTypes)(it.schema);
      const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);
      schemaKeywords(it, types, !checkedTypes, errsCount);
    }
    function checkRefsAndKeywords(it) {
      const { schema, errSchemaPath, opts, self: self2 } = it;
      if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self2.RULES)) {
        self2.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
      }
    }
    function checkNoDefault(it) {
      const { schema, opts } = it;
      if (schema.default !== void 0 && opts.useDefaults && opts.strictSchema) {
        (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
      }
    }
    function updateContext(it) {
      const schId = it.schema[it.opts.schemaId];
      if (schId)
        it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
    }
    function checkAsyncSchema(it) {
      if (it.schema.$async && !it.schemaEnv.$async)
        throw new Error("async schema in sync schema");
    }
    function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
      const msg = schema.$comment;
      if (opts.$comment === true) {
        gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
      } else if (typeof opts.$comment == "function") {
        const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;
        const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
        gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
      }
    }
    function returnResults(it) {
      const { gen, schemaEnv, validateName, ValidationError, opts } = it;
      if (schemaEnv.$async) {
        gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`));
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors);
        if (opts.unevaluated)
          assignEvaluated(it);
        gen.return((0, codegen_1._)`${names_1.default.errors} === 0`);
      }
    }
    function assignEvaluated({ gen, evaluated, props, items }) {
      if (props instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.props`, props);
      if (items instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.items`, items);
    }
    function schemaKeywords(it, types, typeErrors, errsCount) {
      const { gen, schema, data, allErrors, opts, self: self2 } = it;
      const { RULES } = self2;
      if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
        gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
        return;
      }
      if (!opts.jtd)
        checkStrictTypes(it, types);
      gen.block(() => {
        for (const group of RULES.rules)
          groupKeywords(group);
        groupKeywords(RULES.post);
      });
      function groupKeywords(group) {
        if (!(0, applicability_1.shouldUseGroup)(schema, group))
          return;
        if (group.type) {
          gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
          iterateKeywords(it, group);
          if (types.length === 1 && types[0] === group.type && typeErrors) {
            gen.else();
            (0, dataType_2.reportTypeError)(it);
          }
          gen.endIf();
        } else {
          iterateKeywords(it, group);
        }
        if (!allErrors)
          gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`);
      }
    }
    function iterateKeywords(it, group) {
      const { gen, schema, opts: { useDefaults } } = it;
      if (useDefaults)
        (0, defaults_1.assignDefaults)(it, group.type);
      gen.block(() => {
        for (const rule of group.rules) {
          if ((0, applicability_1.shouldUseRule)(schema, rule)) {
            keywordCode(it, rule.keyword, rule.definition, group.type);
          }
        }
      });
    }
    function checkStrictTypes(it, types) {
      if (it.schemaEnv.meta || !it.opts.strictTypes)
        return;
      checkContextTypes(it, types);
      if (!it.opts.allowUnionTypes)
        checkMultipleTypes(it, types);
      checkKeywordTypes(it, it.dataTypes);
    }
    function checkContextTypes(it, types) {
      if (!types.length)
        return;
      if (!it.dataTypes.length) {
        it.dataTypes = types;
        return;
      }
      types.forEach((t) => {
        if (!includesType(it.dataTypes, t)) {
          strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);
        }
      });
      narrowSchemaTypes(it, types);
    }
    function checkMultipleTypes(it, ts) {
      if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
        strictTypesError(it, "use allowUnionTypes to allow union type keyword");
      }
    }
    function checkKeywordTypes(it, ts) {
      const rules = it.self.RULES.all;
      for (const keyword in rules) {
        const rule = rules[keyword];
        if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
          const { type } = rule.definition;
          if (type.length && !type.some((t) => hasApplicableType(ts, t))) {
            strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`);
          }
        }
      }
    }
    function hasApplicableType(schTs, kwdT) {
      return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
    }
    function includesType(ts, t) {
      return ts.includes(t) || t === "integer" && ts.includes("number");
    }
    function narrowSchemaTypes(it, withTypes) {
      const ts = [];
      for (const t of it.dataTypes) {
        if (includesType(withTypes, t))
          ts.push(t);
        else if (withTypes.includes("integer") && t === "number")
          ts.push("integer");
      }
      it.dataTypes = ts;
    }
    function strictTypesError(it, msg) {
      const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
      msg += ` at "${schemaPath}" (strictTypes)`;
      (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
    }
    var KeywordCxt = class {
      constructor(it, def, keyword) {
        (0, keyword_1.validateKeywordUsage)(it, def, keyword);
        this.gen = it.gen;
        this.allErrors = it.allErrors;
        this.keyword = keyword;
        this.data = it.data;
        this.schema = it.schema[keyword];
        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;
        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);
        this.schemaType = def.schemaType;
        this.parentSchema = it.schema;
        this.params = {};
        this.it = it;
        this.def = def;
        if (this.$data) {
          this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
        } else {
          this.schemaCode = this.schemaValue;
          if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
            throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
          }
        }
        if ("code" in def ? def.trackErrors : def.errors !== false) {
          this.errsCount = it.gen.const("_errs", names_1.default.errors);
        }
      }
      result(condition, successAction, failAction) {
        this.failResult((0, codegen_1.not)(condition), successAction, failAction);
      }
      failResult(condition, successAction, failAction) {
        this.gen.if(condition);
        if (failAction)
          failAction();
        else
          this.error();
        if (successAction) {
          this.gen.else();
          successAction();
          if (this.allErrors)
            this.gen.endIf();
        } else {
          if (this.allErrors)
            this.gen.endIf();
          else
            this.gen.else();
        }
      }
      pass(condition, failAction) {
        this.failResult((0, codegen_1.not)(condition), void 0, failAction);
      }
      fail(condition) {
        if (condition === void 0) {
          this.error();
          if (!this.allErrors)
            this.gen.if(false);
          return;
        }
        this.gen.if(condition);
        this.error();
        if (this.allErrors)
          this.gen.endIf();
        else
          this.gen.else();
      }
      fail$data(condition) {
        if (!this.$data)
          return this.fail(condition);
        const { schemaCode } = this;
        this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
      }
      error(append, errorParams, errorPaths) {
        if (errorParams) {
          this.setParams(errorParams);
          this._error(append, errorPaths);
          this.setParams({});
          return;
        }
        this._error(append, errorPaths);
      }
      _error(append, errorPaths) {
        ;
        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
      }
      $dataError() {
        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
      }
      reset() {
        if (this.errsCount === void 0)
          throw new Error('add "trackErrors" to keyword definition');
        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
      }
      ok(cond) {
        if (!this.allErrors)
          this.gen.if(cond);
      }
      setParams(obj, assign) {
        if (assign)
          Object.assign(this.params, obj);
        else
          this.params = obj;
      }
      block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
        this.gen.block(() => {
          this.check$data(valid, $dataValid);
          codeBlock();
        });
      }
      check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
        if (!this.$data)
          return;
        const { gen, schemaCode, schemaType, def } = this;
        gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid));
        if (valid !== codegen_1.nil)
          gen.assign(valid, true);
        if (schemaType.length || def.validateSchema) {
          gen.elseIf(this.invalid$data());
          this.$dataError();
          if (valid !== codegen_1.nil)
            gen.assign(valid, false);
        }
        gen.else();
      }
      invalid$data() {
        const { gen, schemaCode, schemaType, def, it } = this;
        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
        function wrong$DataType() {
          if (schemaType.length) {
            if (!(schemaCode instanceof codegen_1.Name))
              throw new Error("ajv implementation error");
            const st = Array.isArray(schemaType) ? schemaType : [schemaType];
            return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
          }
          return codegen_1.nil;
        }
        function invalid$DataSchema() {
          if (def.validateSchema) {
            const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema });
            return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
          }
          return codegen_1.nil;
        }
      }
      subschema(appl, valid) {
        const subschema = (0, subschema_1.getSubschema)(this.it, appl);
        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
        (0, subschema_1.extendSubschemaMode)(subschema, appl);
        const nextContext = { ...this.it, ...subschema, items: void 0, props: void 0 };
        subschemaCode(nextContext, valid);
        return nextContext;
      }
      mergeEvaluated(schemaCxt, toName) {
        const { it, gen } = this;
        if (!it.opts.unevaluated)
          return;
        if (it.props !== true && schemaCxt.props !== void 0) {
          it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
        }
        if (it.items !== true && schemaCxt.items !== void 0) {
          it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
        }
      }
      mergeValidEvaluated(schemaCxt, valid) {
        const { it, gen } = this;
        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
          gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
          return true;
        }
      }
    };
    exports2.KeywordCxt = KeywordCxt;
    function keywordCode(it, keyword, def, ruleType) {
      const cxt = new KeywordCxt(it, def, keyword);
      if ("code" in def) {
        def.code(cxt, ruleType);
      } else if (cxt.$data && def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      } else if ("macro" in def) {
        (0, keyword_1.macroKeywordCode)(cxt, def);
      } else if (def.compile || def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      }
    }
    var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
    var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData($data, { dataLevel, dataNames, dataPathArr }) {
      let jsonPointer;
      let data;
      if ($data === "")
        return names_1.default.rootData;
      if ($data[0] === "/") {
        if (!JSON_POINTER.test($data))
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        jsonPointer = $data;
        data = names_1.default.rootData;
      } else {
        const matches = RELATIVE_JSON_POINTER.exec($data);
        if (!matches)
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        const up = +matches[1];
        jsonPointer = matches[2];
        if (jsonPointer === "#") {
          if (up >= dataLevel)
            throw new Error(errorMsg("property/index", up));
          return dataPathArr[dataLevel - up];
        }
        if (up > dataLevel)
          throw new Error(errorMsg("data", up));
        data = dataNames[dataLevel - up];
        if (!jsonPointer)
          return data;
      }
      let expr = data;
      const segments = jsonPointer.split("/");
      for (const segment of segments) {
        if (segment) {
          data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
          expr = (0, codegen_1._)`${expr} && ${data}`;
        }
      }
      return expr;
      function errorMsg(pointerType, up) {
        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
      }
    }
    exports2.getData = getData;
  }
});

// node_modules/conf/node_modules/ajv/dist/runtime/validation_error.js
var require_validation_error = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/runtime/validation_error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ValidationError = class extends Error {
      constructor(errors) {
        super("validation failed");
        this.errors = errors;
        this.ajv = this.validation = true;
      }
    };
    exports2.default = ValidationError;
  }
});

// node_modules/conf/node_modules/ajv/dist/compile/ref_error.js
var require_ref_error = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/compile/ref_error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var resolve_1 = require_resolve();
    var MissingRefError = class extends Error {
      constructor(resolver, baseId, ref, msg) {
        super(msg || `can't resolve reference ${ref} from id ${baseId}`);
        this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);
        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
      }
    };
    exports2.default = MissingRefError;
  }
});

// node_modules/conf/node_modules/ajv/dist/compile/index.js
var require_compile = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/compile/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveSchema = exports2.getCompilingSchema = exports2.resolveRef = exports2.compileSchema = exports2.SchemaEnv = void 0;
    var codegen_1 = require_codegen();
    var validation_error_1 = require_validation_error();
    var names_1 = require_names();
    var resolve_1 = require_resolve();
    var util_1 = require_util();
    var validate_1 = require_validate();
    var SchemaEnv = class {
      constructor(env) {
        var _a;
        this.refs = {};
        this.dynamicAnchors = {};
        let schema;
        if (typeof env.schema == "object")
          schema = env.schema;
        this.schema = env.schema;
        this.schemaId = env.schemaId;
        this.root = env.root || this;
        this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || "$id"]);
        this.schemaPath = env.schemaPath;
        this.localRefs = env.localRefs;
        this.meta = env.meta;
        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
        this.refs = {};
      }
    };
    exports2.SchemaEnv = SchemaEnv;
    function compileSchema(sch) {
      const _sch = getCompilingSchema.call(this, sch);
      if (_sch)
        return _sch;
      const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
      const { es5, lines } = this.opts.code;
      const { ownProperties } = this.opts;
      const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
      let _ValidationError;
      if (sch.$async) {
        _ValidationError = gen.scopeValue("Error", {
          ref: validation_error_1.default,
          code: (0, codegen_1._)`require("ajv/dist/runtime/validation_error").default`
        });
      }
      const validateName = gen.scopeName("validate");
      sch.validateName = validateName;
      const schemaCxt = {
        gen,
        allErrors: this.opts.allErrors,
        data: names_1.default.data,
        parentData: names_1.default.parentData,
        parentDataProperty: names_1.default.parentDataProperty,
        dataNames: [names_1.default.data],
        dataPathArr: [codegen_1.nil],
        // TODO can its length be used as dataLevel if nil is removed?
        dataLevel: 0,
        dataTypes: [],
        definedProperties: /* @__PURE__ */ new Set(),
        topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) } : { ref: sch.schema }),
        validateName,
        ValidationError: _ValidationError,
        schema: sch.schema,
        schemaEnv: sch,
        rootId,
        baseId: sch.baseId || rootId,
        schemaPath: codegen_1.nil,
        errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
        errorPath: (0, codegen_1._)`""`,
        opts: this.opts,
        self: this
      };
      let sourceCode;
      try {
        this._compilations.add(sch);
        (0, validate_1.validateFunctionCode)(schemaCxt);
        gen.optimize(this.opts.code.optimize);
        const validateCode = gen.toString();
        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
        if (this.opts.code.process)
          sourceCode = this.opts.code.process(sourceCode, sch);
        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
        const validate = makeValidate(this, this.scope.get());
        this.scope.value(validateName, { ref: validate });
        validate.errors = null;
        validate.schema = sch.schema;
        validate.schemaEnv = sch;
        if (sch.$async)
          validate.$async = true;
        if (this.opts.code.source === true) {
          validate.source = { validateName, validateCode, scopeValues: gen._values };
        }
        if (this.opts.unevaluated) {
          const { props, items } = schemaCxt;
          validate.evaluated = {
            props: props instanceof codegen_1.Name ? void 0 : props,
            items: items instanceof codegen_1.Name ? void 0 : items,
            dynamicProps: props instanceof codegen_1.Name,
            dynamicItems: items instanceof codegen_1.Name
          };
          if (validate.source)
            validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);
        }
        sch.validate = validate;
        return sch;
      } catch (e) {
        delete sch.validate;
        delete sch.validateName;
        if (sourceCode)
          this.logger.error("Error compiling schema, function code:", sourceCode);
        throw e;
      } finally {
        this._compilations.delete(sch);
      }
    }
    exports2.compileSchema = compileSchema;
    function resolveRef(root, baseId, ref) {
      var _a;
      ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
      const schOrFunc = root.refs[ref];
      if (schOrFunc)
        return schOrFunc;
      let _sch = resolve.call(this, root, ref);
      if (_sch === void 0) {
        const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref];
        const { schemaId } = this.opts;
        if (schema)
          _sch = new SchemaEnv({ schema, schemaId, root, baseId });
      }
      if (_sch === void 0)
        return;
      return root.refs[ref] = inlineOrCompile.call(this, _sch);
    }
    exports2.resolveRef = resolveRef;
    function inlineOrCompile(sch) {
      if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
        return sch.schema;
      return sch.validate ? sch : compileSchema.call(this, sch);
    }
    function getCompilingSchema(schEnv) {
      for (const sch of this._compilations) {
        if (sameSchemaEnv(sch, schEnv))
          return sch;
      }
    }
    exports2.getCompilingSchema = getCompilingSchema;
    function sameSchemaEnv(s1, s2) {
      return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
    }
    function resolve(root, ref) {
      let sch;
      while (typeof (sch = this.refs[ref]) == "string")
        ref = sch;
      return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
    }
    function resolveSchema(root, ref) {
      const p = this.opts.uriResolver.parse(ref);
      const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);
      let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
      if (Object.keys(root.schema).length > 0 && refPath === baseId) {
        return getJsonPointer.call(this, p, root);
      }
      const id = (0, resolve_1.normalizeId)(refPath);
      const schOrRef = this.refs[id] || this.schemas[id];
      if (typeof schOrRef == "string") {
        const sch = resolveSchema.call(this, root, schOrRef);
        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
          return;
        return getJsonPointer.call(this, p, sch);
      }
      if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
        return;
      if (!schOrRef.validate)
        compileSchema.call(this, schOrRef);
      if (id === (0, resolve_1.normalizeId)(ref)) {
        const { schema } = schOrRef;
        const { schemaId } = this.opts;
        const schId = schema[schemaId];
        if (schId)
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        return new SchemaEnv({ schema, schemaId, root, baseId });
      }
      return getJsonPointer.call(this, p, schOrRef);
    }
    exports2.resolveSchema = resolveSchema;
    var PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
      "properties",
      "patternProperties",
      "enum",
      "dependencies",
      "definitions"
    ]);
    function getJsonPointer(parsedRef, { baseId, schema, root }) {
      var _a;
      if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
        return;
      for (const part of parsedRef.fragment.slice(1).split("/")) {
        if (typeof schema === "boolean")
          return;
        const partSchema = schema[(0, util_1.unescapeFragment)(part)];
        if (partSchema === void 0)
          return;
        schema = partSchema;
        const schId = typeof schema === "object" && schema[this.opts.schemaId];
        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        }
      }
      let env;
      if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
        env = resolveSchema.call(this, root, $ref);
      }
      const { schemaId } = this.opts;
      env = env || new SchemaEnv({ schema, schemaId, root, baseId });
      if (env.schema !== env.root.schema)
        return env;
      return void 0;
    }
  }
});

// node_modules/conf/node_modules/ajv/dist/refs/data.json
var require_data = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/refs/data.json"(exports2, module2) {
    module2.exports = {
      $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
      description: "Meta-schema for $data reference (JSON AnySchema extension proposal)",
      type: "object",
      required: ["$data"],
      properties: {
        $data: {
          type: "string",
          anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }]
        }
      },
      additionalProperties: false
    };
  }
});

// node_modules/fast-uri/lib/utils.js
var require_utils = __commonJS({
  "node_modules/fast-uri/lib/utils.js"(exports2, module2) {
    "use strict";
    var isUUID = RegExp.prototype.test.bind(/^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu);
    var isIPv4 = RegExp.prototype.test.bind(/^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u);
    function stringArrayToHexStripped(input) {
      let acc = "";
      let code = 0;
      let i = 0;
      for (i = 0; i < input.length; i++) {
        code = input[i].charCodeAt(0);
        if (code === 48) {
          continue;
        }
        if (!(code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102)) {
          return "";
        }
        acc += input[i];
        break;
      }
      for (i += 1; i < input.length; i++) {
        code = input[i].charCodeAt(0);
        if (!(code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102)) {
          return "";
        }
        acc += input[i];
      }
      return acc;
    }
    var nonSimpleDomain = RegExp.prototype.test.bind(/[^!"$&'()*+,\-.;=_`a-z{}~]/u);
    function consumeIsZone(buffer) {
      buffer.length = 0;
      return true;
    }
    function consumeHextets(buffer, address, output) {
      if (buffer.length) {
        const hex = stringArrayToHexStripped(buffer);
        if (hex !== "") {
          address.push(hex);
        } else {
          output.error = true;
          return false;
        }
        buffer.length = 0;
      }
      return true;
    }
    function getIPV6(input) {
      let tokenCount = 0;
      const output = { error: false, address: "", zone: "" };
      const address = [];
      const buffer = [];
      let endipv6Encountered = false;
      let endIpv6 = false;
      let consume = consumeHextets;
      for (let i = 0; i < input.length; i++) {
        const cursor = input[i];
        if (cursor === "[" || cursor === "]") {
          continue;
        }
        if (cursor === ":") {
          if (endipv6Encountered === true) {
            endIpv6 = true;
          }
          if (!consume(buffer, address, output)) {
            break;
          }
          if (++tokenCount > 7) {
            output.error = true;
            break;
          }
          if (i > 0 && input[i - 1] === ":") {
            endipv6Encountered = true;
          }
          address.push(":");
          continue;
        } else if (cursor === "%") {
          if (!consume(buffer, address, output)) {
            break;
          }
          consume = consumeIsZone;
        } else {
          buffer.push(cursor);
          continue;
        }
      }
      if (buffer.length) {
        if (consume === consumeIsZone) {
          output.zone = buffer.join("");
        } else if (endIpv6) {
          address.push(buffer.join(""));
        } else {
          address.push(stringArrayToHexStripped(buffer));
        }
      }
      output.address = address.join("");
      return output;
    }
    function normalizeIPv6(host) {
      if (findToken(host, ":") < 2) {
        return { host, isIPV6: false };
      }
      const ipv6 = getIPV6(host);
      if (!ipv6.error) {
        let newHost = ipv6.address;
        let escapedHost = ipv6.address;
        if (ipv6.zone) {
          newHost += "%" + ipv6.zone;
          escapedHost += "%25" + ipv6.zone;
        }
        return { host: newHost, isIPV6: true, escapedHost };
      } else {
        return { host, isIPV6: false };
      }
    }
    function findToken(str, token) {
      let ind = 0;
      for (let i = 0; i < str.length; i++) {
        if (str[i] === token) ind++;
      }
      return ind;
    }
    function removeDotSegments(path16) {
      let input = path16;
      const output = [];
      let nextSlash = -1;
      let len = 0;
      while (len = input.length) {
        if (len === 1) {
          if (input === ".") {
            break;
          } else if (input === "/") {
            output.push("/");
            break;
          } else {
            output.push(input);
            break;
          }
        } else if (len === 2) {
          if (input[0] === ".") {
            if (input[1] === ".") {
              break;
            } else if (input[1] === "/") {
              input = input.slice(2);
              continue;
            }
          } else if (input[0] === "/") {
            if (input[1] === "." || input[1] === "/") {
              output.push("/");
              break;
            }
          }
        } else if (len === 3) {
          if (input === "/..") {
            if (output.length !== 0) {
              output.pop();
            }
            output.push("/");
            break;
          }
        }
        if (input[0] === ".") {
          if (input[1] === ".") {
            if (input[2] === "/") {
              input = input.slice(3);
              continue;
            }
          } else if (input[1] === "/") {
            input = input.slice(2);
            continue;
          }
        } else if (input[0] === "/") {
          if (input[1] === ".") {
            if (input[2] === "/") {
              input = input.slice(2);
              continue;
            } else if (input[2] === ".") {
              if (input[3] === "/") {
                input = input.slice(3);
                if (output.length !== 0) {
                  output.pop();
                }
                continue;
              }
            }
          }
        }
        if ((nextSlash = input.indexOf("/", 1)) === -1) {
          output.push(input);
          break;
        } else {
          output.push(input.slice(0, nextSlash));
          input = input.slice(nextSlash);
        }
      }
      return output.join("");
    }
    function normalizeComponentEncoding(component, esc) {
      const func = esc !== true ? escape : unescape;
      if (component.scheme !== void 0) {
        component.scheme = func(component.scheme);
      }
      if (component.userinfo !== void 0) {
        component.userinfo = func(component.userinfo);
      }
      if (component.host !== void 0) {
        component.host = func(component.host);
      }
      if (component.path !== void 0) {
        component.path = func(component.path);
      }
      if (component.query !== void 0) {
        component.query = func(component.query);
      }
      if (component.fragment !== void 0) {
        component.fragment = func(component.fragment);
      }
      return component;
    }
    function recomposeAuthority(component) {
      const uriTokens = [];
      if (component.userinfo !== void 0) {
        uriTokens.push(component.userinfo);
        uriTokens.push("@");
      }
      if (component.host !== void 0) {
        let host = unescape(component.host);
        if (!isIPv4(host)) {
          const ipV6res = normalizeIPv6(host);
          if (ipV6res.isIPV6 === true) {
            host = `[${ipV6res.escapedHost}]`;
          } else {
            host = component.host;
          }
        }
        uriTokens.push(host);
      }
      if (typeof component.port === "number" || typeof component.port === "string") {
        uriTokens.push(":");
        uriTokens.push(String(component.port));
      }
      return uriTokens.length ? uriTokens.join("") : void 0;
    }
    module2.exports = {
      nonSimpleDomain,
      recomposeAuthority,
      normalizeComponentEncoding,
      removeDotSegments,
      isIPv4,
      isUUID,
      normalizeIPv6,
      stringArrayToHexStripped
    };
  }
});

// node_modules/fast-uri/lib/schemes.js
var require_schemes = __commonJS({
  "node_modules/fast-uri/lib/schemes.js"(exports2, module2) {
    "use strict";
    var { isUUID } = require_utils();
    var URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
    var supportedSchemeNames = (
      /** @type {const} */
      [
        "http",
        "https",
        "ws",
        "wss",
        "urn",
        "urn:uuid"
      ]
    );
    function isValidSchemeName(name) {
      return supportedSchemeNames.indexOf(
        /** @type {*} */
        name
      ) !== -1;
    }
    function wsIsSecure(wsComponent) {
      if (wsComponent.secure === true) {
        return true;
      } else if (wsComponent.secure === false) {
        return false;
      } else if (wsComponent.scheme) {
        return wsComponent.scheme.length === 3 && (wsComponent.scheme[0] === "w" || wsComponent.scheme[0] === "W") && (wsComponent.scheme[1] === "s" || wsComponent.scheme[1] === "S") && (wsComponent.scheme[2] === "s" || wsComponent.scheme[2] === "S");
      } else {
        return false;
      }
    }
    function httpParse(component) {
      if (!component.host) {
        component.error = component.error || "HTTP URIs must have a host.";
      }
      return component;
    }
    function httpSerialize(component) {
      const secure = String(component.scheme).toLowerCase() === "https";
      if (component.port === (secure ? 443 : 80) || component.port === "") {
        component.port = void 0;
      }
      if (!component.path) {
        component.path = "/";
      }
      return component;
    }
    function wsParse(wsComponent) {
      wsComponent.secure = wsIsSecure(wsComponent);
      wsComponent.resourceName = (wsComponent.path || "/") + (wsComponent.query ? "?" + wsComponent.query : "");
      wsComponent.path = void 0;
      wsComponent.query = void 0;
      return wsComponent;
    }
    function wsSerialize(wsComponent) {
      if (wsComponent.port === (wsIsSecure(wsComponent) ? 443 : 80) || wsComponent.port === "") {
        wsComponent.port = void 0;
      }
      if (typeof wsComponent.secure === "boolean") {
        wsComponent.scheme = wsComponent.secure ? "wss" : "ws";
        wsComponent.secure = void 0;
      }
      if (wsComponent.resourceName) {
        const [path16, query] = wsComponent.resourceName.split("?");
        wsComponent.path = path16 && path16 !== "/" ? path16 : void 0;
        wsComponent.query = query;
        wsComponent.resourceName = void 0;
      }
      wsComponent.fragment = void 0;
      return wsComponent;
    }
    function urnParse(urnComponent, options) {
      if (!urnComponent.path) {
        urnComponent.error = "URN can not be parsed";
        return urnComponent;
      }
      const matches = urnComponent.path.match(URN_REG);
      if (matches) {
        const scheme = options.scheme || urnComponent.scheme || "urn";
        urnComponent.nid = matches[1].toLowerCase();
        urnComponent.nss = matches[2];
        const urnScheme = `${scheme}:${options.nid || urnComponent.nid}`;
        const schemeHandler = getSchemeHandler(urnScheme);
        urnComponent.path = void 0;
        if (schemeHandler) {
          urnComponent = schemeHandler.parse(urnComponent, options);
        }
      } else {
        urnComponent.error = urnComponent.error || "URN can not be parsed.";
      }
      return urnComponent;
    }
    function urnSerialize(urnComponent, options) {
      if (urnComponent.nid === void 0) {
        throw new Error("URN without nid cannot be serialized");
      }
      const scheme = options.scheme || urnComponent.scheme || "urn";
      const nid = urnComponent.nid.toLowerCase();
      const urnScheme = `${scheme}:${options.nid || nid}`;
      const schemeHandler = getSchemeHandler(urnScheme);
      if (schemeHandler) {
        urnComponent = schemeHandler.serialize(urnComponent, options);
      }
      const uriComponent = urnComponent;
      const nss = urnComponent.nss;
      uriComponent.path = `${nid || options.nid}:${nss}`;
      options.skipEscape = true;
      return uriComponent;
    }
    function urnuuidParse(urnComponent, options) {
      const uuidComponent = urnComponent;
      uuidComponent.uuid = uuidComponent.nss;
      uuidComponent.nss = void 0;
      if (!options.tolerant && (!uuidComponent.uuid || !isUUID(uuidComponent.uuid))) {
        uuidComponent.error = uuidComponent.error || "UUID is not valid.";
      }
      return uuidComponent;
    }
    function urnuuidSerialize(uuidComponent) {
      const urnComponent = uuidComponent;
      urnComponent.nss = (uuidComponent.uuid || "").toLowerCase();
      return urnComponent;
    }
    var http = (
      /** @type {SchemeHandler} */
      {
        scheme: "http",
        domainHost: true,
        parse: httpParse,
        serialize: httpSerialize
      }
    );
    var https = (
      /** @type {SchemeHandler} */
      {
        scheme: "https",
        domainHost: http.domainHost,
        parse: httpParse,
        serialize: httpSerialize
      }
    );
    var ws = (
      /** @type {SchemeHandler} */
      {
        scheme: "ws",
        domainHost: true,
        parse: wsParse,
        serialize: wsSerialize
      }
    );
    var wss = (
      /** @type {SchemeHandler} */
      {
        scheme: "wss",
        domainHost: ws.domainHost,
        parse: ws.parse,
        serialize: ws.serialize
      }
    );
    var urn = (
      /** @type {SchemeHandler} */
      {
        scheme: "urn",
        parse: urnParse,
        serialize: urnSerialize,
        skipNormalize: true
      }
    );
    var urnuuid = (
      /** @type {SchemeHandler} */
      {
        scheme: "urn:uuid",
        parse: urnuuidParse,
        serialize: urnuuidSerialize,
        skipNormalize: true
      }
    );
    var SCHEMES = (
      /** @type {Record<SchemeName, SchemeHandler>} */
      {
        http,
        https,
        ws,
        wss,
        urn,
        "urn:uuid": urnuuid
      }
    );
    Object.setPrototypeOf(SCHEMES, null);
    function getSchemeHandler(scheme) {
      return scheme && (SCHEMES[
        /** @type {SchemeName} */
        scheme
      ] || SCHEMES[
        /** @type {SchemeName} */
        scheme.toLowerCase()
      ]) || void 0;
    }
    module2.exports = {
      wsIsSecure,
      SCHEMES,
      isValidSchemeName,
      getSchemeHandler
    };
  }
});

// node_modules/fast-uri/index.js
var require_fast_uri = __commonJS({
  "node_modules/fast-uri/index.js"(exports2, module2) {
    "use strict";
    var { normalizeIPv6, removeDotSegments, recomposeAuthority, normalizeComponentEncoding, isIPv4, nonSimpleDomain } = require_utils();
    var { SCHEMES, getSchemeHandler } = require_schemes();
    function normalize(uri, options) {
      if (typeof uri === "string") {
        uri = /** @type {T} */
        serialize(parse(uri, options), options);
      } else if (typeof uri === "object") {
        uri = /** @type {T} */
        parse(serialize(uri, options), options);
      }
      return uri;
    }
    function resolve(baseURI, relativeURI, options) {
      const schemelessOptions = options ? Object.assign({ scheme: "null" }, options) : { scheme: "null" };
      const resolved = resolveComponent(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true);
      schemelessOptions.skipEscape = true;
      return serialize(resolved, schemelessOptions);
    }
    function resolveComponent(base, relative, options, skipNormalization) {
      const target = {};
      if (!skipNormalization) {
        base = parse(serialize(base, options), options);
        relative = parse(serialize(relative, options), options);
      }
      options = options || {};
      if (!options.tolerant && relative.scheme) {
        target.scheme = relative.scheme;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
      } else {
        if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (!relative.path) {
            target.path = base.path;
            if (relative.query !== void 0) {
              target.query = relative.query;
            } else {
              target.query = base.query;
            }
          } else {
            if (relative.path[0] === "/") {
              target.path = removeDotSegments(relative.path);
            } else {
              if ((base.userinfo !== void 0 || base.host !== void 0 || base.port !== void 0) && !base.path) {
                target.path = "/" + relative.path;
              } else if (!base.path) {
                target.path = relative.path;
              } else {
                target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
              }
              target.path = removeDotSegments(target.path);
            }
            target.query = relative.query;
          }
          target.userinfo = base.userinfo;
          target.host = base.host;
          target.port = base.port;
        }
        target.scheme = base.scheme;
      }
      target.fragment = relative.fragment;
      return target;
    }
    function equal(uriA, uriB, options) {
      if (typeof uriA === "string") {
        uriA = unescape(uriA);
        uriA = serialize(normalizeComponentEncoding(parse(uriA, options), true), { ...options, skipEscape: true });
      } else if (typeof uriA === "object") {
        uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true });
      }
      if (typeof uriB === "string") {
        uriB = unescape(uriB);
        uriB = serialize(normalizeComponentEncoding(parse(uriB, options), true), { ...options, skipEscape: true });
      } else if (typeof uriB === "object") {
        uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true });
      }
      return uriA.toLowerCase() === uriB.toLowerCase();
    }
    function serialize(cmpts, opts) {
      const component = {
        host: cmpts.host,
        scheme: cmpts.scheme,
        userinfo: cmpts.userinfo,
        port: cmpts.port,
        path: cmpts.path,
        query: cmpts.query,
        nid: cmpts.nid,
        nss: cmpts.nss,
        uuid: cmpts.uuid,
        fragment: cmpts.fragment,
        reference: cmpts.reference,
        resourceName: cmpts.resourceName,
        secure: cmpts.secure,
        error: ""
      };
      const options = Object.assign({}, opts);
      const uriTokens = [];
      const schemeHandler = getSchemeHandler(options.scheme || component.scheme);
      if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(component, options);
      if (component.path !== void 0) {
        if (!options.skipEscape) {
          component.path = escape(component.path);
          if (component.scheme !== void 0) {
            component.path = component.path.split("%3A").join(":");
          }
        } else {
          component.path = unescape(component.path);
        }
      }
      if (options.reference !== "suffix" && component.scheme) {
        uriTokens.push(component.scheme, ":");
      }
      const authority = recomposeAuthority(component);
      if (authority !== void 0) {
        if (options.reference !== "suffix") {
          uriTokens.push("//");
        }
        uriTokens.push(authority);
        if (component.path && component.path[0] !== "/") {
          uriTokens.push("/");
        }
      }
      if (component.path !== void 0) {
        let s = component.path;
        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
          s = removeDotSegments(s);
        }
        if (authority === void 0 && s[0] === "/" && s[1] === "/") {
          s = "/%2F" + s.slice(2);
        }
        uriTokens.push(s);
      }
      if (component.query !== void 0) {
        uriTokens.push("?", component.query);
      }
      if (component.fragment !== void 0) {
        uriTokens.push("#", component.fragment);
      }
      return uriTokens.join("");
    }
    var URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
    function parse(uri, opts) {
      const options = Object.assign({}, opts);
      const parsed = {
        scheme: void 0,
        userinfo: void 0,
        host: "",
        port: void 0,
        path: "",
        query: void 0,
        fragment: void 0
      };
      let isIP = false;
      if (options.reference === "suffix") {
        if (options.scheme) {
          uri = options.scheme + ":" + uri;
        } else {
          uri = "//" + uri;
        }
      }
      const matches = uri.match(URI_PARSE);
      if (matches) {
        parsed.scheme = matches[1];
        parsed.userinfo = matches[3];
        parsed.host = matches[4];
        parsed.port = parseInt(matches[5], 10);
        parsed.path = matches[6] || "";
        parsed.query = matches[7];
        parsed.fragment = matches[8];
        if (isNaN(parsed.port)) {
          parsed.port = matches[5];
        }
        if (parsed.host) {
          const ipv4result = isIPv4(parsed.host);
          if (ipv4result === false) {
            const ipv6result = normalizeIPv6(parsed.host);
            parsed.host = ipv6result.host.toLowerCase();
            isIP = ipv6result.isIPV6;
          } else {
            isIP = true;
          }
        }
        if (parsed.scheme === void 0 && parsed.userinfo === void 0 && parsed.host === void 0 && parsed.port === void 0 && parsed.query === void 0 && !parsed.path) {
          parsed.reference = "same-document";
        } else if (parsed.scheme === void 0) {
          parsed.reference = "relative";
        } else if (parsed.fragment === void 0) {
          parsed.reference = "absolute";
        } else {
          parsed.reference = "uri";
        }
        if (options.reference && options.reference !== "suffix" && options.reference !== parsed.reference) {
          parsed.error = parsed.error || "URI is not a " + options.reference + " reference.";
        }
        const schemeHandler = getSchemeHandler(options.scheme || parsed.scheme);
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
          if (parsed.host && (options.domainHost || schemeHandler && schemeHandler.domainHost) && isIP === false && nonSimpleDomain(parsed.host)) {
            try {
              parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
            } catch (e) {
              parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e;
            }
          }
        }
        if (!schemeHandler || schemeHandler && !schemeHandler.skipNormalize) {
          if (uri.indexOf("%") !== -1) {
            if (parsed.scheme !== void 0) {
              parsed.scheme = unescape(parsed.scheme);
            }
            if (parsed.host !== void 0) {
              parsed.host = unescape(parsed.host);
            }
          }
          if (parsed.path) {
            parsed.path = escape(unescape(parsed.path));
          }
          if (parsed.fragment) {
            parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment));
          }
        }
        if (schemeHandler && schemeHandler.parse) {
          schemeHandler.parse(parsed, options);
        }
      } else {
        parsed.error = parsed.error || "URI can not be parsed.";
      }
      return parsed;
    }
    var fastUri = {
      SCHEMES,
      normalize,
      resolve,
      resolveComponent,
      equal,
      serialize,
      parse
    };
    module2.exports = fastUri;
    module2.exports.default = fastUri;
    module2.exports.fastUri = fastUri;
  }
});

// node_modules/conf/node_modules/ajv/dist/runtime/uri.js
var require_uri = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/runtime/uri.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var uri = require_fast_uri();
    uri.code = 'require("ajv/dist/runtime/uri").default';
    exports2.default = uri;
  }
});

// node_modules/conf/node_modules/ajv/dist/core.js
var require_core = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/core.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CodeGen = exports2.Name = exports2.nil = exports2.stringify = exports2.str = exports2._ = exports2.KeywordCxt = void 0;
    var validate_1 = require_validate();
    Object.defineProperty(exports2, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports2, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    var ref_error_1 = require_ref_error();
    var rules_1 = require_rules();
    var compile_1 = require_compile();
    var codegen_2 = require_codegen();
    var resolve_1 = require_resolve();
    var dataType_1 = require_dataType();
    var util_1 = require_util();
    var $dataRefSchema = require_data();
    var uri_1 = require_uri();
    var defaultRegExp = (str, flags) => new RegExp(str, flags);
    defaultRegExp.code = "new RegExp";
    var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
    var EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error"
    ]);
    var removedOptions = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now."
    };
    var deprecatedOptions = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode: '"minLength"/"maxLength" account for unicode characters by default.'
    };
    var MAX_EXPRESSION = 200;
    function requiredOptions(o) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
      const s = o.strict;
      const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;
      const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
      const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
      const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
      return {
        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
        uriResolver
      };
    }
    var Ajv = class {
      constructor(opts = {}) {
        this.schemas = {};
        this.refs = {};
        this.formats = {};
        this._compilations = /* @__PURE__ */ new Set();
        this._loading = {};
        this._cache = /* @__PURE__ */ new Map();
        opts = this.opts = { ...opts, ...requiredOptions(opts) };
        const { es5, lines } = this.opts.code;
        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
        this.logger = getLogger(opts.logger);
        const formatOpt = opts.validateFormats;
        opts.validateFormats = false;
        this.RULES = (0, rules_1.getRules)();
        checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
        checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
        this._metaOpts = getMetaSchemaOptions.call(this);
        if (opts.formats)
          addInitialFormats.call(this);
        this._addVocabularies();
        this._addDefaultMetaSchema();
        if (opts.keywords)
          addInitialKeywords.call(this, opts.keywords);
        if (typeof opts.meta == "object")
          this.addMetaSchema(opts.meta);
        addInitialSchemas.call(this);
        opts.validateFormats = formatOpt;
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        const { $data, meta, schemaId } = this.opts;
        let _dataRefSchema = $dataRefSchema;
        if (schemaId === "id") {
          _dataRefSchema = { ...$dataRefSchema };
          _dataRefSchema.id = _dataRefSchema.$id;
          delete _dataRefSchema.$id;
        }
        if (meta && $data)
          this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
      }
      defaultMeta() {
        const { meta, schemaId } = this.opts;
        return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
      }
      validate(schemaKeyRef, data) {
        let v;
        if (typeof schemaKeyRef == "string") {
          v = this.getSchema(schemaKeyRef);
          if (!v)
            throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
        } else {
          v = this.compile(schemaKeyRef);
        }
        const valid = v(data);
        if (!("$async" in v))
          this.errors = v.errors;
        return valid;
      }
      compile(schema, _meta) {
        const sch = this._addSchema(schema, _meta);
        return sch.validate || this._compileSchemaEnv(sch);
      }
      compileAsync(schema, meta) {
        if (typeof this.opts.loadSchema != "function") {
          throw new Error("options.loadSchema should be a function");
        }
        const { loadSchema } = this.opts;
        return runCompileAsync.call(this, schema, meta);
        async function runCompileAsync(_schema, _meta) {
          await loadMetaSchema.call(this, _schema.$schema);
          const sch = this._addSchema(_schema, _meta);
          return sch.validate || _compileAsync.call(this, sch);
        }
        async function loadMetaSchema($ref) {
          if ($ref && !this.getSchema($ref)) {
            await runCompileAsync.call(this, { $ref }, true);
          }
        }
        async function _compileAsync(sch) {
          try {
            return this._compileSchemaEnv(sch);
          } catch (e) {
            if (!(e instanceof ref_error_1.default))
              throw e;
            checkLoaded.call(this, e);
            await loadMissingSchema.call(this, e.missingSchema);
            return _compileAsync.call(this, sch);
          }
        }
        function checkLoaded({ missingSchema: ref, missingRef }) {
          if (this.refs[ref]) {
            throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
          }
        }
        async function loadMissingSchema(ref) {
          const _schema = await _loadSchema.call(this, ref);
          if (!this.refs[ref])
            await loadMetaSchema.call(this, _schema.$schema);
          if (!this.refs[ref])
            this.addSchema(_schema, ref, meta);
        }
        async function _loadSchema(ref) {
          const p = this._loading[ref];
          if (p)
            return p;
          try {
            return await (this._loading[ref] = loadSchema(ref));
          } finally {
            delete this._loading[ref];
          }
        }
      }
      // Adds schema to the instance
      addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
        if (Array.isArray(schema)) {
          for (const sch of schema)
            this.addSchema(sch, void 0, _meta, _validateSchema);
          return this;
        }
        let id;
        if (typeof schema === "object") {
          const { schemaId } = this.opts;
          id = schema[schemaId];
          if (id !== void 0 && typeof id != "string") {
            throw new Error(`schema ${schemaId} must be string`);
          }
        }
        key = (0, resolve_1.normalizeId)(key || id);
        this._checkUnique(key);
        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
        return this;
      }
      // Add schema that will be used to validate other schemas
      // options in META_IGNORE_OPTIONS are alway set to false
      addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
        this.addSchema(schema, key, true, _validateSchema);
        return this;
      }
      //  Validate schema against its meta-schema
      validateSchema(schema, throwOrLogError) {
        if (typeof schema == "boolean")
          return true;
        let $schema;
        $schema = schema.$schema;
        if ($schema !== void 0 && typeof $schema != "string") {
          throw new Error("$schema must be a string");
        }
        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
        if (!$schema) {
          this.logger.warn("meta-schema not available");
          this.errors = null;
          return true;
        }
        const valid = this.validate($schema, schema);
        if (!valid && throwOrLogError) {
          const message = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log")
            this.logger.error(message);
          else
            throw new Error(message);
        }
        return valid;
      }
      // Get compiled schema by `key` or `ref`.
      // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
      getSchema(keyRef) {
        let sch;
        while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
          keyRef = sch;
        if (sch === void 0) {
          const { schemaId } = this.opts;
          const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
          sch = compile_1.resolveSchema.call(this, root, keyRef);
          if (!sch)
            return;
          this.refs[keyRef] = sch;
        }
        return sch.validate || this._compileSchemaEnv(sch);
      }
      // Remove cached schema(s).
      // If no parameter is passed all schemas but meta-schemas are removed.
      // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
      // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
      removeSchema(schemaKeyRef) {
        if (schemaKeyRef instanceof RegExp) {
          this._removeAllSchemas(this.schemas, schemaKeyRef);
          this._removeAllSchemas(this.refs, schemaKeyRef);
          return this;
        }
        switch (typeof schemaKeyRef) {
          case "undefined":
            this._removeAllSchemas(this.schemas);
            this._removeAllSchemas(this.refs);
            this._cache.clear();
            return this;
          case "string": {
            const sch = getSchEnv.call(this, schemaKeyRef);
            if (typeof sch == "object")
              this._cache.delete(sch.schema);
            delete this.schemas[schemaKeyRef];
            delete this.refs[schemaKeyRef];
            return this;
          }
          case "object": {
            const cacheKey = schemaKeyRef;
            this._cache.delete(cacheKey);
            let id = schemaKeyRef[this.opts.schemaId];
            if (id) {
              id = (0, resolve_1.normalizeId)(id);
              delete this.schemas[id];
              delete this.refs[id];
            }
            return this;
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      // add "vocabulary" - a collection of keywords
      addVocabulary(definitions) {
        for (const def of definitions)
          this.addKeyword(def);
        return this;
      }
      addKeyword(kwdOrDef, def) {
        let keyword;
        if (typeof kwdOrDef == "string") {
          keyword = kwdOrDef;
          if (typeof def == "object") {
            this.logger.warn("these parameters are deprecated, see docs for addKeyword");
            def.keyword = keyword;
          }
        } else if (typeof kwdOrDef == "object" && def === void 0) {
          def = kwdOrDef;
          keyword = def.keyword;
          if (Array.isArray(keyword) && !keyword.length) {
            throw new Error("addKeywords: keyword must be string or non-empty array");
          }
        } else {
          throw new Error("invalid addKeywords parameters");
        }
        checkKeyword.call(this, keyword, def);
        if (!def) {
          (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));
          return this;
        }
        keywordMetaschema.call(this, def);
        const definition = {
          ...def,
          type: (0, dataType_1.getJSONTypes)(def.type),
          schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)
        };
        (0, util_1.eachItem)(keyword, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));
        return this;
      }
      getKeyword(keyword) {
        const rule = this.RULES.all[keyword];
        return typeof rule == "object" ? rule.definition : !!rule;
      }
      // Remove keyword
      removeKeyword(keyword) {
        const { RULES } = this;
        delete RULES.keywords[keyword];
        delete RULES.all[keyword];
        for (const group of RULES.rules) {
          const i = group.rules.findIndex((rule) => rule.keyword === keyword);
          if (i >= 0)
            group.rules.splice(i, 1);
        }
        return this;
      }
      // Add format
      addFormat(name, format) {
        if (typeof format == "string")
          format = new RegExp(format);
        this.formats[name] = format;
        return this;
      }
      errorsText(errors = this.errors, { separator = ", ", dataVar = "data" } = {}) {
        if (!errors || errors.length === 0)
          return "No errors";
        return errors.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
      }
      $dataMetaSchema(metaSchema, keywordsJsonPointers) {
        const rules = this.RULES.all;
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        for (const jsonPointer of keywordsJsonPointers) {
          const segments = jsonPointer.split("/").slice(1);
          let keywords = metaSchema;
          for (const seg of segments)
            keywords = keywords[seg];
          for (const key in rules) {
            const rule = rules[key];
            if (typeof rule != "object")
              continue;
            const { $data } = rule.definition;
            const schema = keywords[key];
            if ($data && schema)
              keywords[key] = schemaOrData(schema);
          }
        }
        return metaSchema;
      }
      _removeAllSchemas(schemas, regex) {
        for (const keyRef in schemas) {
          const sch = schemas[keyRef];
          if (!regex || regex.test(keyRef)) {
            if (typeof sch == "string") {
              delete schemas[keyRef];
            } else if (sch && !sch.meta) {
              this._cache.delete(sch.schema);
              delete schemas[keyRef];
            }
          }
        }
      }
      _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
        let id;
        const { schemaId } = this.opts;
        if (typeof schema == "object") {
          id = schema[schemaId];
        } else {
          if (this.opts.jtd)
            throw new Error("schema must be object");
          else if (typeof schema != "boolean")
            throw new Error("schema must be object or boolean");
        }
        let sch = this._cache.get(schema);
        if (sch !== void 0)
          return sch;
        baseId = (0, resolve_1.normalizeId)(id || baseId);
        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
        sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
        this._cache.set(sch.schema, sch);
        if (addSchema && !baseId.startsWith("#")) {
          if (baseId)
            this._checkUnique(baseId);
          this.refs[baseId] = sch;
        }
        if (validateSchema)
          this.validateSchema(schema, true);
        return sch;
      }
      _checkUnique(id) {
        if (this.schemas[id] || this.refs[id]) {
          throw new Error(`schema with key or id "${id}" already exists`);
        }
      }
      _compileSchemaEnv(sch) {
        if (sch.meta)
          this._compileMetaSchema(sch);
        else
          compile_1.compileSchema.call(this, sch);
        if (!sch.validate)
          throw new Error("ajv implementation error");
        return sch.validate;
      }
      _compileMetaSchema(sch) {
        const currentOpts = this.opts;
        this.opts = this._metaOpts;
        try {
          compile_1.compileSchema.call(this, sch);
        } finally {
          this.opts = currentOpts;
        }
      }
    };
    Ajv.ValidationError = validation_error_1.default;
    Ajv.MissingRefError = ref_error_1.default;
    exports2.default = Ajv;
    function checkOptions(checkOpts, options, msg, log2 = "error") {
      for (const key in checkOpts) {
        const opt = key;
        if (opt in options)
          this.logger[log2](`${msg}: option ${key}. ${checkOpts[opt]}`);
      }
    }
    function getSchEnv(keyRef) {
      keyRef = (0, resolve_1.normalizeId)(keyRef);
      return this.schemas[keyRef] || this.refs[keyRef];
    }
    function addInitialSchemas() {
      const optsSchemas = this.opts.schemas;
      if (!optsSchemas)
        return;
      if (Array.isArray(optsSchemas))
        this.addSchema(optsSchemas);
      else
        for (const key in optsSchemas)
          this.addSchema(optsSchemas[key], key);
    }
    function addInitialFormats() {
      for (const name in this.opts.formats) {
        const format = this.opts.formats[name];
        if (format)
          this.addFormat(name, format);
      }
    }
    function addInitialKeywords(defs) {
      if (Array.isArray(defs)) {
        this.addVocabulary(defs);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (const keyword in defs) {
        const def = defs[keyword];
        if (!def.keyword)
          def.keyword = keyword;
        this.addKeyword(def);
      }
    }
    function getMetaSchemaOptions() {
      const metaOpts = { ...this.opts };
      for (const opt of META_IGNORE_OPTIONS)
        delete metaOpts[opt];
      return metaOpts;
    }
    var noLogs = { log() {
    }, warn() {
    }, error() {
    } };
    function getLogger(logger2) {
      if (logger2 === false)
        return noLogs;
      if (logger2 === void 0)
        return console;
      if (logger2.log && logger2.warn && logger2.error)
        return logger2;
      throw new Error("logger must implement log, warn and error methods");
    }
    var KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
    function checkKeyword(keyword, def) {
      const { RULES } = this;
      (0, util_1.eachItem)(keyword, (kwd) => {
        if (RULES.keywords[kwd])
          throw new Error(`Keyword ${kwd} is already defined`);
        if (!KEYWORD_NAME.test(kwd))
          throw new Error(`Keyword ${kwd} has invalid name`);
      });
      if (!def)
        return;
      if (def.$data && !("code" in def || "validate" in def)) {
        throw new Error('$data keyword must have "code" or "validate" function');
      }
    }
    function addRule(keyword, definition, dataType) {
      var _a;
      const post = definition === null || definition === void 0 ? void 0 : definition.post;
      if (dataType && post)
        throw new Error('keyword with "post" flag cannot have "type"');
      const { RULES } = this;
      let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);
      if (!ruleGroup) {
        ruleGroup = { type: dataType, rules: [] };
        RULES.rules.push(ruleGroup);
      }
      RULES.keywords[keyword] = true;
      if (!definition)
        return;
      const rule = {
        keyword,
        definition: {
          ...definition,
          type: (0, dataType_1.getJSONTypes)(definition.type),
          schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
        }
      };
      if (definition.before)
        addBeforeRule.call(this, ruleGroup, rule, definition.before);
      else
        ruleGroup.rules.push(rule);
      RULES.all[keyword] = rule;
      (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));
    }
    function addBeforeRule(ruleGroup, rule, before) {
      const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
      if (i >= 0) {
        ruleGroup.rules.splice(i, 0, rule);
      } else {
        ruleGroup.rules.push(rule);
        this.logger.warn(`rule ${before} is not defined`);
      }
    }
    function keywordMetaschema(def) {
      let { metaSchema } = def;
      if (metaSchema === void 0)
        return;
      if (def.$data && this.opts.$data)
        metaSchema = schemaOrData(metaSchema);
      def.validateSchema = this.compile(metaSchema, true);
    }
    var $dataRef = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
    };
    function schemaOrData(schema) {
      return { anyOf: [schema, $dataRef] };
    }
  }
});

// node_modules/conf/node_modules/ajv/dist/vocabularies/core/id.js
var require_id = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/vocabularies/core/id.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var def = {
      keyword: "id",
      code() {
        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
      }
    };
    exports2.default = def;
  }
});

// node_modules/conf/node_modules/ajv/dist/vocabularies/core/ref.js
var require_ref = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/vocabularies/core/ref.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.callRef = exports2.getValidate = void 0;
    var ref_error_1 = require_ref_error();
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var compile_1 = require_compile();
    var util_1 = require_util();
    var def = {
      keyword: "$ref",
      schemaType: "string",
      code(cxt) {
        const { gen, schema: $ref, it } = cxt;
        const { baseId, schemaEnv: env, validateName, opts, self: self2 } = it;
        const { root } = env;
        if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
          return callRootRef();
        const schOrEnv = compile_1.resolveRef.call(self2, root, baseId, $ref);
        if (schOrEnv === void 0)
          throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
        if (schOrEnv instanceof compile_1.SchemaEnv)
          return callValidate(schOrEnv);
        return inlineRefSchema(schOrEnv);
        function callRootRef() {
          if (env === root)
            return callRef(cxt, validateName, env, env.$async);
          const rootName = gen.scopeValue("root", { ref: root });
          return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);
        }
        function callValidate(sch) {
          const v = getValidate(cxt, sch);
          callRef(cxt, v, sch, sch.$async);
        }
        function inlineRefSchema(sch) {
          const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });
          const valid = gen.name("valid");
          const schCxt = cxt.subschema({
            schema: sch,
            dataTypes: [],
            schemaPath: codegen_1.nil,
            topSchemaRef: schName,
            errSchemaPath: $ref
          }, valid);
          cxt.mergeEvaluated(schCxt);
          cxt.ok(valid);
        }
      }
    };
    function getValidate(cxt, sch) {
      const { gen } = cxt;
      return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
    }
    exports2.getValidate = getValidate;
    function callRef(cxt, v, sch, $async) {
      const { gen, it } = cxt;
      const { allErrors, schemaEnv: env, opts } = it;
      const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
      if ($async)
        callAsyncRef();
      else
        callSyncRef();
      function callAsyncRef() {
        if (!env.$async)
          throw new Error("async schema referenced by sync schema");
        const valid = gen.let("valid");
        gen.try(() => {
          gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);
          addEvaluatedFrom(v);
          if (!allErrors)
            gen.assign(valid, true);
        }, (e) => {
          gen.if((0, codegen_1._)`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
          addErrorsFrom(e);
          if (!allErrors)
            gen.assign(valid, false);
        });
        cxt.ok(valid);
      }
      function callSyncRef() {
        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
      }
      function addErrorsFrom(source) {
        const errs = (0, codegen_1._)`${source}.errors`;
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`);
        gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
      }
      function addEvaluatedFrom(source) {
        var _a;
        if (!it.opts.unevaluated)
          return;
        const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
        if (it.props !== true) {
          if (schEvaluated && !schEvaluated.dynamicProps) {
            if (schEvaluated.props !== void 0) {
              it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);
            }
          } else {
            const props = gen.var("props", (0, codegen_1._)`${source}.evaluated.props`);
            it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
          }
        }
        if (it.items !== true) {
          if (schEvaluated && !schEvaluated.dynamicItems) {
            if (schEvaluated.items !== void 0) {
              it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);
            }
          } else {
            const items = gen.var("items", (0, codegen_1._)`${source}.evaluated.items`);
            it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);
          }
        }
      }
    }
    exports2.callRef = callRef;
    exports2.default = def;
  }
});

// node_modules/conf/node_modules/ajv/dist/vocabularies/core/index.js
var require_core2 = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/vocabularies/core/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var id_1 = require_id();
    var ref_1 = require_ref();
    var core = [
      "$schema",
      "$id",
      "$defs",
      "$vocabulary",
      { keyword: "$comment" },
      "definitions",
      id_1.default,
      ref_1.default
    ];
    exports2.default = core;
  }
});

// node_modules/conf/node_modules/ajv/dist/vocabularies/validation/limitNumber.js
var require_limitNumber = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/vocabularies/validation/limitNumber.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var ops = codegen_1.operators;
    var KWDs = {
      maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    };
    var error = {
      message: ({ keyword, schemaCode }) => (0, codegen_1.str)`must be ${KWDs[keyword].okStr} ${schemaCode}`,
      params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
    };
    var def = {
      keyword: Object.keys(KWDs),
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        cxt.fail$data((0, codegen_1._)`${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/conf/node_modules/ajv/dist/vocabularies/validation/multipleOf.js
var require_multipleOf = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/vocabularies/validation/multipleOf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must be multiple of ${schemaCode}`,
      params: ({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`
    };
    var def = {
      keyword: "multipleOf",
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, schemaCode, it } = cxt;
        const prec = it.opts.multipleOfPrecision;
        const res = gen.let("res");
        const invalid = prec ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1._)`${res} !== parseInt(${res})`;
        cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/conf/node_modules/ajv/dist/runtime/ucs2length.js
var require_ucs2length = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/runtime/ucs2length.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function ucs2length(str) {
      const len = str.length;
      let length = 0;
      let pos = 0;
      let value;
      while (pos < len) {
        length++;
        value = str.charCodeAt(pos++);
        if (value >= 55296 && value <= 56319 && pos < len) {
          value = str.charCodeAt(pos);
          if ((value & 64512) === 56320)
            pos++;
        }
      }
      return length;
    }
    exports2.default = ucs2length;
    ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
  }
});

// node_modules/conf/node_modules/ajv/dist/vocabularies/validation/limitLength.js
var require_limitLength = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/vocabularies/validation/limitLength.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var ucs2length_1 = require_ucs2length();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxLength" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxLength", "minLength"],
      type: "string",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode, it } = cxt;
        const op = keyword === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
        const len = it.opts.unicode === false ? (0, codegen_1._)`${data}.length` : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
        cxt.fail$data((0, codegen_1._)`${len} ${op} ${schemaCode}`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/conf/node_modules/ajv/dist/vocabularies/validation/pattern.js
var require_pattern = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/vocabularies/validation/pattern.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match pattern "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`
    };
    var def = {
      keyword: "pattern",
      type: "string",
      schemaType: "string",
      $data: true,
      error,
      code(cxt) {
        const { data, $data, schema, schemaCode, it } = cxt;
        const u = it.opts.unicodeRegExp ? "u" : "";
        const regExp = $data ? (0, codegen_1._)`(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);
        cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data})`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/conf/node_modules/ajv/dist/vocabularies/validation/limitProperties.js
var require_limitProperties = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/vocabularies/validation/limitProperties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxProperties" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxProperties", "minProperties"],
      type: "object",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`Object.keys(${data}).length ${op} ${schemaCode}`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/conf/node_modules/ajv/dist/vocabularies/validation/required.js
var require_required = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/vocabularies/validation/required.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { missingProperty } }) => (0, codegen_1.str)`must have required property '${missingProperty}'`,
      params: ({ params: { missingProperty } }) => (0, codegen_1._)`{missingProperty: ${missingProperty}}`
    };
    var def = {
      keyword: "required",
      type: "object",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, schema, schemaCode, data, $data, it } = cxt;
        const { opts } = it;
        if (!$data && schema.length === 0)
          return;
        const useLoop = schema.length >= opts.loopRequired;
        if (it.allErrors)
          allErrorsMode();
        else
          exitOnErrorMode();
        if (opts.strictRequired) {
          const props = cxt.parentSchema.properties;
          const { definedProperties } = cxt.it;
          for (const requiredKey of schema) {
            if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
              const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
              const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
              (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
            }
          }
        }
        function allErrorsMode() {
          if (useLoop || $data) {
            cxt.block$data(codegen_1.nil, loopAllRequired);
          } else {
            for (const prop of schema) {
              (0, code_1.checkReportMissingProp)(cxt, prop);
            }
          }
        }
        function exitOnErrorMode() {
          const missing = gen.let("missing");
          if (useLoop || $data) {
            const valid = gen.let("valid", true);
            cxt.block$data(valid, () => loopUntilMissing(missing, valid));
            cxt.ok(valid);
          } else {
            gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));
            (0, code_1.reportMissingProp)(cxt, missing);
            gen.else();
          }
        }
        function loopAllRequired() {
          gen.forOf("prop", schemaCode, (prop) => {
            cxt.setParams({ missingProperty: prop });
            gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
          });
        }
        function loopUntilMissing(missing, valid) {
          cxt.setParams({ missingProperty: missing });
          gen.forOf(missing, schemaCode, () => {
            gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));
            gen.if((0, codegen_1.not)(valid), () => {
              cxt.error();
              gen.break();
            });
          }, codegen_1.nil);
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/conf/node_modules/ajv/dist/vocabularies/validation/limitItems.js
var require_limitItems = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/vocabularies/validation/limitItems.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxItems" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxItems", "minItems"],
      type: "array",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`${data}.length ${op} ${schemaCode}`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/conf/node_modules/ajv/dist/runtime/equal.js
var require_equal = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/runtime/equal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var equal = require_fast_deep_equal();
    equal.code = 'require("ajv/dist/runtime/equal").default';
    exports2.default = equal;
  }
});

// node_modules/conf/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js
var require_uniqueItems = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var dataType_1 = require_dataType();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: ({ params: { i, j } }) => (0, codegen_1.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
      params: ({ params: { i, j } }) => (0, codegen_1._)`{i: ${i}, j: ${j}}`
    };
    var def = {
      keyword: "uniqueItems",
      type: "array",
      schemaType: "boolean",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
        if (!$data && !schema)
          return;
        const valid = gen.let("valid");
        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`);
        cxt.ok(valid);
        function validateUniqueItems() {
          const i = gen.let("i", (0, codegen_1._)`${data}.length`);
          const j = gen.let("j");
          cxt.setParams({ i, j });
          gen.assign(valid, true);
          gen.if((0, codegen_1._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
        }
        function canOptimize() {
          return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
        }
        function loopN(i, j) {
          const item = gen.name("item");
          const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
          const indices = gen.const("indices", (0, codegen_1._)`{}`);
          gen.for((0, codegen_1._)`;${i}--;`, () => {
            gen.let(item, (0, codegen_1._)`${data}[${i}]`);
            gen.if(wrongType, (0, codegen_1._)`continue`);
            if (itemTypes.length > 1)
              gen.if((0, codegen_1._)`typeof ${item} == "string"`, (0, codegen_1._)`${item} += "_"`);
            gen.if((0, codegen_1._)`typeof ${indices}[${item}] == "number"`, () => {
              gen.assign(j, (0, codegen_1._)`${indices}[${item}]`);
              cxt.error();
              gen.assign(valid, false).break();
            }).code((0, codegen_1._)`${indices}[${item}] = ${i}`);
          });
        }
        function loopN2(i, j) {
          const eql = (0, util_1.useFunc)(gen, equal_1.default);
          const outer = gen.name("outer");
          gen.label(outer).for((0, codegen_1._)`;${i}--;`, () => gen.for((0, codegen_1._)`${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._)`${eql}(${data}[${i}], ${data}[${j}])`, () => {
            cxt.error();
            gen.assign(valid, false).break(outer);
          })));
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/conf/node_modules/ajv/dist/vocabularies/validation/const.js
var require_const = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/vocabularies/validation/const.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: "must be equal to constant",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValue: ${schemaCode}}`
    };
    var def = {
      keyword: "const",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schemaCode, schema } = cxt;
        if ($data || schema && typeof schema == "object") {
          cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);
        } else {
          cxt.fail((0, codegen_1._)`${schema} !== ${data}`);
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/conf/node_modules/ajv/dist/vocabularies/validation/enum.js
var require_enum = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/vocabularies/validation/enum.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
    };
    var def = {
      keyword: "enum",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        if (!$data && schema.length === 0)
          throw new Error("enum must have non-empty array");
        const useLoop = schema.length >= it.opts.loopEnum;
        let eql;
        const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1.useFunc)(gen, equal_1.default);
        let valid;
        if (useLoop || $data) {
          valid = gen.let("valid");
          cxt.block$data(valid, loopEnum);
        } else {
          if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
          const vSchema = gen.const("vSchema", schemaCode);
          valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
        }
        cxt.pass(valid);
        function loopEnum() {
          gen.assign(valid, false);
          gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));
        }
        function equalCode(vSchema, i) {
          const sch = schema[i];
          return typeof sch === "object" && sch !== null ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1._)`${data} === ${sch}`;
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/conf/node_modules/ajv/dist/vocabularies/validation/index.js
var require_validation = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/vocabularies/validation/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var limitNumber_1 = require_limitNumber();
    var multipleOf_1 = require_multipleOf();
    var limitLength_1 = require_limitLength();
    var pattern_1 = require_pattern();
    var limitProperties_1 = require_limitProperties();
    var required_1 = require_required();
    var limitItems_1 = require_limitItems();
    var uniqueItems_1 = require_uniqueItems();
    var const_1 = require_const();
    var enum_1 = require_enum();
    var validation = [
      // number
      limitNumber_1.default,
      multipleOf_1.default,
      // string
      limitLength_1.default,
      pattern_1.default,
      // object
      limitProperties_1.default,
      required_1.default,
      // array
      limitItems_1.default,
      uniqueItems_1.default,
      // any
      { keyword: "type", schemaType: ["string", "array"] },
      { keyword: "nullable", schemaType: "boolean" },
      const_1.default,
      enum_1.default
    ];
    exports2.default = validation;
  }
});

// node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js
var require_additionalItems = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateAdditionalItems = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "additionalItems",
      type: "array",
      schemaType: ["boolean", "object"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { parentSchema, it } = cxt;
        const { items } = parentSchema;
        if (!Array.isArray(items)) {
          (0, util_1.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
          return;
        }
        validateAdditionalItems(cxt, items);
      }
    };
    function validateAdditionalItems(cxt, items) {
      const { gen, schema, data, keyword, it } = cxt;
      it.items = true;
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      if (schema === false) {
        cxt.setParams({ len: items.length });
        cxt.pass((0, codegen_1._)`${len} <= ${items.length}`);
      } else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
        const valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items.length}`);
        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));
        cxt.ok(valid);
      }
      function validateItems(valid) {
        gen.forRange("i", items.length, len, (i) => {
          cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);
          if (!it.allErrors)
            gen.if((0, codegen_1.not)(valid), () => gen.break());
        });
      }
    }
    exports2.validateAdditionalItems = validateAdditionalItems;
    exports2.default = def;
  }
});

// node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/items.js
var require_items = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/items.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateTuple = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "array", "boolean"],
      before: "uniqueItems",
      code(cxt) {
        const { schema, it } = cxt;
        if (Array.isArray(schema))
          return validateTuple(cxt, "additionalItems", schema);
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    function validateTuple(cxt, extraItems, schArr = cxt.schema) {
      const { gen, parentSchema, data, keyword, it } = cxt;
      checkStrictTuple(parentSchema);
      if (it.opts.unevaluated && schArr.length && it.items !== true) {
        it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);
      }
      const valid = gen.name("valid");
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      schArr.forEach((sch, i) => {
        if ((0, util_1.alwaysValidSchema)(it, sch))
          return;
        gen.if((0, codegen_1._)`${len} > ${i}`, () => cxt.subschema({
          keyword,
          schemaProp: i,
          dataProp: i
        }, valid));
        cxt.ok(valid);
      });
      function checkStrictTuple(sch) {
        const { opts, errSchemaPath } = it;
        const l = schArr.length;
        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
        if (opts.strictTuples && !fullTuple) {
          const msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
          (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);
        }
      }
    }
    exports2.validateTuple = validateTuple;
    exports2.default = def;
  }
});

// node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js
var require_prefixItems = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var items_1 = require_items();
    var def = {
      keyword: "prefixItems",
      type: "array",
      schemaType: ["array"],
      before: "uniqueItems",
      code: (cxt) => (0, items_1.validateTuple)(cxt, "items")
    };
    exports2.default = def;
  }
});

// node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/items2020.js
var require_items2020 = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/items2020.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    var additionalItems_1 = require_additionalItems();
    var error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { schema, parentSchema, it } = cxt;
        const { prefixItems } = parentSchema;
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        if (prefixItems)
          (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);
        else
          cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    exports2.default = def;
  }
});

// node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/contains.js
var require_contains = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/contains.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1.str)`must contain at least ${min} valid item(s)` : (0, codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
      params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1._)`{minContains: ${min}}` : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`
    };
    var def = {
      keyword: "contains",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        let min;
        let max;
        const { minContains, maxContains } = parentSchema;
        if (it.opts.next) {
          min = minContains === void 0 ? 1 : minContains;
          max = maxContains;
        } else {
          min = 1;
        }
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        cxt.setParams({ min, max });
        if (max === void 0 && min === 0) {
          (0, util_1.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
          return;
        }
        if (max !== void 0 && min > max) {
          (0, util_1.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
          cxt.fail();
          return;
        }
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          let cond = (0, codegen_1._)`${len} >= ${min}`;
          if (max !== void 0)
            cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`;
          cxt.pass(cond);
          return;
        }
        it.items = true;
        const valid = gen.name("valid");
        if (max === void 0 && min === 1) {
          validateItems(valid, () => gen.if(valid, () => gen.break()));
        } else if (min === 0) {
          gen.let(valid, true);
          if (max !== void 0)
            gen.if((0, codegen_1._)`${data}.length > 0`, validateItemsWithCount);
        } else {
          gen.let(valid, false);
          validateItemsWithCount();
        }
        cxt.result(valid, () => cxt.reset());
        function validateItemsWithCount() {
          const schValid = gen.name("_valid");
          const count = gen.let("count", 0);
          validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
        }
        function validateItems(_valid, block) {
          gen.forRange("i", 0, len, (i) => {
            cxt.subschema({
              keyword: "contains",
              dataProp: i,
              dataPropType: util_1.Type.Num,
              compositeRule: true
            }, _valid);
            block();
          });
        }
        function checkLimits(count) {
          gen.code((0, codegen_1._)`${count}++`);
          if (max === void 0) {
            gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true).break());
          } else {
            gen.if((0, codegen_1._)`${count} > ${max}`, () => gen.assign(valid, false).break());
            if (min === 1)
              gen.assign(valid, true);
            else
              gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true));
          }
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/dependencies.js
var require_dependencies = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/dependencies.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateSchemaDeps = exports2.validatePropertyDeps = exports2.error = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    exports2.error = {
      message: ({ params: { property, depsCount, deps } }) => {
        const property_ies = depsCount === 1 ? "property" : "properties";
        return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;
      },
      params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
      // TODO change to reference
    };
    var def = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: exports2.error,
      code(cxt) {
        const [propDeps, schDeps] = splitDependencies(cxt);
        validatePropertyDeps(cxt, propDeps);
        validateSchemaDeps(cxt, schDeps);
      }
    };
    function splitDependencies({ schema }) {
      const propertyDeps = {};
      const schemaDeps = {};
      for (const key in schema) {
        if (key === "__proto__")
          continue;
        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
        deps[key] = schema[key];
      }
      return [propertyDeps, schemaDeps];
    }
    function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
      const { gen, data, it } = cxt;
      if (Object.keys(propertyDeps).length === 0)
        return;
      const missing = gen.let("missing");
      for (const prop in propertyDeps) {
        const deps = propertyDeps[prop];
        if (deps.length === 0)
          continue;
        const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);
        cxt.setParams({
          property: prop,
          depsCount: deps.length,
          deps: deps.join(", ")
        });
        if (it.allErrors) {
          gen.if(hasProperty, () => {
            for (const depProp of deps) {
              (0, code_1.checkReportMissingProp)(cxt, depProp);
            }
          });
        } else {
          gen.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
          (0, code_1.reportMissingProp)(cxt, missing);
          gen.else();
        }
      }
    }
    exports2.validatePropertyDeps = validatePropertyDeps;
    function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
      const { gen, data, keyword, it } = cxt;
      const valid = gen.name("valid");
      for (const prop in schemaDeps) {
        if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))
          continue;
        gen.if(
          (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties),
          () => {
            const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
            cxt.mergeValidEvaluated(schCxt, valid);
          },
          () => gen.var(valid, true)
          // TODO var
        );
        cxt.ok(valid);
      }
    }
    exports2.validateSchemaDeps = validateSchemaDeps;
    exports2.default = def;
  }
});

// node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js
var require_propertyNames = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: "property name must be valid",
      params: ({ params }) => (0, codegen_1._)`{propertyName: ${params.propertyName}}`
    };
    var def = {
      keyword: "propertyNames",
      type: "object",
      schemaType: ["object", "boolean"],
      error,
      code(cxt) {
        const { gen, schema, data, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        const valid = gen.name("valid");
        gen.forIn("key", data, (key) => {
          cxt.setParams({ propertyName: key });
          cxt.subschema({
            keyword: "propertyNames",
            data: key,
            dataTypes: ["string"],
            propertyName: key,
            compositeRule: true
          }, valid);
          gen.if((0, codegen_1.not)(valid), () => {
            cxt.error(true);
            if (!it.allErrors)
              gen.break();
          });
        });
        cxt.ok(valid);
      }
    };
    exports2.default = def;
  }
});

// node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js
var require_additionalProperties = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var util_1 = require_util();
    var error = {
      message: "must NOT have additional properties",
      params: ({ params }) => (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`
    };
    var def = {
      keyword: "additionalProperties",
      type: ["object"],
      schemaType: ["boolean", "object"],
      allowUndefined: true,
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, data, errsCount, it } = cxt;
        if (!errsCount)
          throw new Error("ajv implementation error");
        const { allErrors, opts } = it;
        it.props = true;
        if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it, schema))
          return;
        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
        const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
        checkAdditionalProperties();
        cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
        function checkAdditionalProperties() {
          gen.forIn("key", data, (key) => {
            if (!props.length && !patProps.length)
              additionalPropertyCode(key);
            else
              gen.if(isAdditional(key), () => additionalPropertyCode(key));
          });
        }
        function isAdditional(key) {
          let definedProp;
          if (props.length > 8) {
            const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");
            definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
          } else if (props.length) {
            definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._)`${key} === ${p}`));
          } else {
            definedProp = codegen_1.nil;
          }
          if (patProps.length) {
            definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p)}.test(${key})`));
          }
          return (0, codegen_1.not)(definedProp);
        }
        function deleteAdditional(key) {
          gen.code((0, codegen_1._)`delete ${data}[${key}]`);
        }
        function additionalPropertyCode(key) {
          if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
            deleteAdditional(key);
            return;
          }
          if (schema === false) {
            cxt.setParams({ additionalProperty: key });
            cxt.error();
            if (!allErrors)
              gen.break();
            return;
          }
          if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
            const valid = gen.name("valid");
            if (opts.removeAdditional === "failing") {
              applyAdditionalSchema(key, valid, false);
              gen.if((0, codegen_1.not)(valid), () => {
                cxt.reset();
                deleteAdditional(key);
              });
            } else {
              applyAdditionalSchema(key, valid);
              if (!allErrors)
                gen.if((0, codegen_1.not)(valid), () => gen.break());
            }
          }
        }
        function applyAdditionalSchema(key, valid, errors) {
          const subschema = {
            keyword: "additionalProperties",
            dataProp: key,
            dataPropType: util_1.Type.Str
          };
          if (errors === false) {
            Object.assign(subschema, {
              compositeRule: true,
              createErrors: false,
              allErrors: false
            });
          }
          cxt.subschema(subschema, valid);
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/properties.js
var require_properties = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/properties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var validate_1 = require_validate();
    var code_1 = require_code2();
    var util_1 = require_util();
    var additionalProperties_1 = require_additionalProperties();
    var def = {
      keyword: "properties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
          additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, "additionalProperties"));
        }
        const allProps = (0, code_1.allSchemaProperties)(schema);
        for (const prop of allProps) {
          it.definedProperties.add(prop);
        }
        if (it.opts.unevaluated && allProps.length && it.props !== true) {
          it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);
        }
        const properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));
        if (properties.length === 0)
          return;
        const valid = gen.name("valid");
        for (const prop of properties) {
          if (hasDefault(prop)) {
            applyPropertySchema(prop);
          } else {
            gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));
            applyPropertySchema(prop);
            if (!it.allErrors)
              gen.else().var(valid, true);
            gen.endIf();
          }
          cxt.it.definedProperties.add(prop);
          cxt.ok(valid);
        }
        function hasDefault(prop) {
          return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== void 0;
        }
        function applyPropertySchema(prop) {
          cxt.subschema({
            keyword: "properties",
            schemaProp: prop,
            dataProp: prop
          }, valid);
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js
var require_patternProperties = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var util_2 = require_util();
    var def = {
      keyword: "patternProperties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, data, parentSchema, it } = cxt;
        const { opts } = it;
        const patterns = (0, code_1.allSchemaProperties)(schema);
        const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));
        if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {
          return;
        }
        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
        const valid = gen.name("valid");
        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {
          it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
        }
        const { props } = it;
        validatePatternProperties();
        function validatePatternProperties() {
          for (const pat of patterns) {
            if (checkProperties)
              checkMatchingProperties(pat);
            if (it.allErrors) {
              validateProperties(pat);
            } else {
              gen.var(valid, true);
              validateProperties(pat);
              gen.if(valid);
            }
          }
        }
        function checkMatchingProperties(pat) {
          for (const prop in checkProperties) {
            if (new RegExp(pat).test(prop)) {
              (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
            }
          }
        }
        function validateProperties(pat) {
          gen.forIn("key", data, (key) => {
            gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
              const alwaysValid = alwaysValidPatterns.includes(pat);
              if (!alwaysValid) {
                cxt.subschema({
                  keyword: "patternProperties",
                  schemaProp: pat,
                  dataProp: key,
                  dataPropType: util_2.Type.Str
                }, valid);
              }
              if (it.opts.unevaluated && props !== true) {
                gen.assign((0, codegen_1._)`${props}[${key}]`, true);
              } else if (!alwaysValid && !it.allErrors) {
                gen.if((0, codegen_1.not)(valid), () => gen.break());
              }
            });
          });
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/not.js
var require_not = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/not.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: "not",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      code(cxt) {
        const { gen, schema, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          cxt.fail();
          return;
        }
        const valid = gen.name("valid");
        cxt.subschema({
          keyword: "not",
          compositeRule: true,
          createErrors: false,
          allErrors: false
        }, valid);
        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
      },
      error: { message: "must NOT be valid" }
    };
    exports2.default = def;
  }
});

// node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/anyOf.js
var require_anyOf = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/anyOf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code2();
    var def = {
      keyword: "anyOf",
      schemaType: "array",
      trackErrors: true,
      code: code_1.validateUnion,
      error: { message: "must match a schema in anyOf" }
    };
    exports2.default = def;
  }
});

// node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/oneOf.js
var require_oneOf = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/oneOf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: "must match exactly one schema in oneOf",
      params: ({ params }) => (0, codegen_1._)`{passingSchemas: ${params.passing}}`
    };
    var def = {
      keyword: "oneOf",
      schemaType: "array",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        if (it.opts.discriminator && parentSchema.discriminator)
          return;
        const schArr = schema;
        const valid = gen.let("valid", false);
        const passing = gen.let("passing", null);
        const schValid = gen.name("_valid");
        cxt.setParams({ passing });
        gen.block(validateOneOf);
        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
        function validateOneOf() {
          schArr.forEach((sch, i) => {
            let schCxt;
            if ((0, util_1.alwaysValidSchema)(it, sch)) {
              gen.var(schValid, true);
            } else {
              schCxt = cxt.subschema({
                keyword: "oneOf",
                schemaProp: i,
                compositeRule: true
              }, schValid);
            }
            if (i > 0) {
              gen.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1._)`[${passing}, ${i}]`).else();
            }
            gen.if(schValid, () => {
              gen.assign(valid, true);
              gen.assign(passing, i);
              if (schCxt)
                cxt.mergeEvaluated(schCxt, codegen_1.Name);
            });
          });
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/allOf.js
var require_allOf = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/allOf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: "allOf",
      schemaType: "array",
      code(cxt) {
        const { gen, schema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        const valid = gen.name("valid");
        schema.forEach((sch, i) => {
          if ((0, util_1.alwaysValidSchema)(it, sch))
            return;
          const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
          cxt.ok(valid);
          cxt.mergeEvaluated(schCxt);
        });
      }
    };
    exports2.default = def;
  }
});

// node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/if.js
var require_if = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/if.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params }) => (0, codegen_1.str)`must match "${params.ifClause}" schema`,
      params: ({ params }) => (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`
    };
    var def = {
      keyword: "if",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, parentSchema, it } = cxt;
        if (parentSchema.then === void 0 && parentSchema.else === void 0) {
          (0, util_1.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
        }
        const hasThen = hasSchema(it, "then");
        const hasElse = hasSchema(it, "else");
        if (!hasThen && !hasElse)
          return;
        const valid = gen.let("valid", true);
        const schValid = gen.name("_valid");
        validateIf();
        cxt.reset();
        if (hasThen && hasElse) {
          const ifClause = gen.let("ifClause");
          cxt.setParams({ ifClause });
          gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
        } else if (hasThen) {
          gen.if(schValid, validateClause("then"));
        } else {
          gen.if((0, codegen_1.not)(schValid), validateClause("else"));
        }
        cxt.pass(valid, () => cxt.error(true));
        function validateIf() {
          const schCxt = cxt.subschema({
            keyword: "if",
            compositeRule: true,
            createErrors: false,
            allErrors: false
          }, schValid);
          cxt.mergeEvaluated(schCxt);
        }
        function validateClause(keyword, ifClause) {
          return () => {
            const schCxt = cxt.subschema({ keyword }, schValid);
            gen.assign(valid, schValid);
            cxt.mergeValidEvaluated(schCxt, valid);
            if (ifClause)
              gen.assign(ifClause, (0, codegen_1._)`${keyword}`);
            else
              cxt.setParams({ ifClause: keyword });
          };
        }
      }
    };
    function hasSchema(it, keyword) {
      const schema = it.schema[keyword];
      return schema !== void 0 && !(0, util_1.alwaysValidSchema)(it, schema);
    }
    exports2.default = def;
  }
});

// node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/thenElse.js
var require_thenElse = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/thenElse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: ["then", "else"],
      schemaType: ["object", "boolean"],
      code({ keyword, parentSchema, it }) {
        if (parentSchema.if === void 0)
          (0, util_1.checkStrictMode)(it, `"${keyword}" without "if" is ignored`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/index.js
var require_applicator = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/vocabularies/applicator/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var additionalItems_1 = require_additionalItems();
    var prefixItems_1 = require_prefixItems();
    var items_1 = require_items();
    var items2020_1 = require_items2020();
    var contains_1 = require_contains();
    var dependencies_1 = require_dependencies();
    var propertyNames_1 = require_propertyNames();
    var additionalProperties_1 = require_additionalProperties();
    var properties_1 = require_properties();
    var patternProperties_1 = require_patternProperties();
    var not_1 = require_not();
    var anyOf_1 = require_anyOf();
    var oneOf_1 = require_oneOf();
    var allOf_1 = require_allOf();
    var if_1 = require_if();
    var thenElse_1 = require_thenElse();
    function getApplicator(draft2020 = false) {
      const applicator = [
        // any
        not_1.default,
        anyOf_1.default,
        oneOf_1.default,
        allOf_1.default,
        if_1.default,
        thenElse_1.default,
        // object
        propertyNames_1.default,
        additionalProperties_1.default,
        dependencies_1.default,
        properties_1.default,
        patternProperties_1.default
      ];
      if (draft2020)
        applicator.push(prefixItems_1.default, items2020_1.default);
      else
        applicator.push(additionalItems_1.default, items_1.default);
      applicator.push(contains_1.default);
      return applicator;
    }
    exports2.default = getApplicator;
  }
});

// node_modules/conf/node_modules/ajv/dist/vocabularies/format/format.js
var require_format2 = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/vocabularies/format/format.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match format "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`
    };
    var def = {
      keyword: "format",
      type: ["number", "string"],
      schemaType: "string",
      $data: true,
      error,
      code(cxt, ruleType) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        const { opts, errSchemaPath, schemaEnv, self: self2 } = it;
        if (!opts.validateFormats)
          return;
        if ($data)
          validate$DataFormat();
        else
          validateFormat();
        function validate$DataFormat() {
          const fmts = gen.scopeValue("formats", {
            ref: self2.formats,
            code: opts.code.formats
          });
          const fDef = gen.const("fDef", (0, codegen_1._)`${fmts}[${schemaCode}]`);
          const fType = gen.let("fType");
          const format = gen.let("format");
          gen.if((0, codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._)`${fDef}.type || "string"`).assign(format, (0, codegen_1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._)`"string"`).assign(format, fDef));
          cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
          function unknownFmt() {
            if (opts.strictSchema === false)
              return codegen_1.nil;
            return (0, codegen_1._)`${schemaCode} && !${format}`;
          }
          function invalidFmt() {
            const callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))` : (0, codegen_1._)`${format}(${data})`;
            const validData = (0, codegen_1._)`(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`;
            return (0, codegen_1._)`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;
          }
        }
        function validateFormat() {
          const formatDef = self2.formats[schema];
          if (!formatDef) {
            unknownFormat();
            return;
          }
          if (formatDef === true)
            return;
          const [fmtType, format, fmtRef] = getFormat(formatDef);
          if (fmtType === ruleType)
            cxt.pass(validCondition());
          function unknownFormat() {
            if (opts.strictSchema === false) {
              self2.logger.warn(unknownMsg());
              return;
            }
            throw new Error(unknownMsg());
            function unknownMsg() {
              return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
            }
          }
          function getFormat(fmtDef) {
            const code = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}` : void 0;
            const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code });
            if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
              return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`];
            }
            return ["string", fmtDef, fmt];
          }
          function validCondition() {
            if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
              if (!schemaEnv.$async)
                throw new Error("async format in sync schema");
              return (0, codegen_1._)`await ${fmtRef}(${data})`;
            }
            return typeof format == "function" ? (0, codegen_1._)`${fmtRef}(${data})` : (0, codegen_1._)`${fmtRef}.test(${data})`;
          }
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/conf/node_modules/ajv/dist/vocabularies/format/index.js
var require_format3 = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/vocabularies/format/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var format_1 = require_format2();
    var format = [format_1.default];
    exports2.default = format;
  }
});

// node_modules/conf/node_modules/ajv/dist/vocabularies/metadata.js
var require_metadata = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/vocabularies/metadata.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.contentVocabulary = exports2.metadataVocabulary = void 0;
    exports2.metadataVocabulary = [
      "title",
      "description",
      "default",
      "deprecated",
      "readOnly",
      "writeOnly",
      "examples"
    ];
    exports2.contentVocabulary = [
      "contentMediaType",
      "contentEncoding",
      "contentSchema"
    ];
  }
});

// node_modules/conf/node_modules/ajv/dist/vocabularies/draft7.js
var require_draft7 = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/vocabularies/draft7.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var core_1 = require_core2();
    var validation_1 = require_validation();
    var applicator_1 = require_applicator();
    var format_1 = require_format3();
    var metadata_1 = require_metadata();
    var draft7Vocabularies = [
      core_1.default,
      validation_1.default,
      (0, applicator_1.default)(),
      format_1.default,
      metadata_1.metadataVocabulary,
      metadata_1.contentVocabulary
    ];
    exports2.default = draft7Vocabularies;
  }
});

// node_modules/conf/node_modules/ajv/dist/vocabularies/discriminator/types.js
var require_types = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/vocabularies/discriminator/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DiscrError = void 0;
    var DiscrError;
    (function(DiscrError2) {
      DiscrError2["Tag"] = "tag";
      DiscrError2["Mapping"] = "mapping";
    })(DiscrError || (exports2.DiscrError = DiscrError = {}));
  }
});

// node_modules/conf/node_modules/ajv/dist/vocabularies/discriminator/index.js
var require_discriminator = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/vocabularies/discriminator/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var types_1 = require_types();
    var compile_1 = require_compile();
    var ref_error_1 = require_ref_error();
    var util_1 = require_util();
    var error = {
      message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
      params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
    };
    var def = {
      keyword: "discriminator",
      type: "object",
      schemaType: "object",
      error,
      code(cxt) {
        const { gen, data, schema, parentSchema, it } = cxt;
        const { oneOf } = parentSchema;
        if (!it.opts.discriminator) {
          throw new Error("discriminator: requires discriminator option");
        }
        const tagName = schema.propertyName;
        if (typeof tagName != "string")
          throw new Error("discriminator: requires propertyName");
        if (schema.mapping)
          throw new Error("discriminator: mapping is not supported");
        if (!oneOf)
          throw new Error("discriminator: requires oneOf keyword");
        const valid = gen.let("valid", false);
        const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
        gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
        cxt.ok(valid);
        function validateMapping() {
          const mapping = getMapping();
          gen.if(false);
          for (const tagValue in mapping) {
            gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
            gen.assign(valid, applyTagSchema(mapping[tagValue]));
          }
          gen.else();
          cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
          gen.endIf();
        }
        function applyTagSchema(schemaProp) {
          const _valid = gen.name("valid");
          const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
          cxt.mergeEvaluated(schCxt, codegen_1.Name);
          return _valid;
        }
        function getMapping() {
          var _a;
          const oneOfMapping = {};
          const topRequired = hasRequired(parentSchema);
          let tagRequired = true;
          for (let i = 0; i < oneOf.length; i++) {
            let sch = oneOf[i];
            if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
              const ref = sch.$ref;
              sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref);
              if (sch instanceof compile_1.SchemaEnv)
                sch = sch.schema;
              if (sch === void 0)
                throw new ref_error_1.default(it.opts.uriResolver, it.baseId, ref);
            }
            const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
            if (typeof propSch != "object") {
              throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
            }
            tagRequired = tagRequired && (topRequired || hasRequired(sch));
            addMappings(propSch, i);
          }
          if (!tagRequired)
            throw new Error(`discriminator: "${tagName}" must be required`);
          return oneOfMapping;
          function hasRequired({ required }) {
            return Array.isArray(required) && required.includes(tagName);
          }
          function addMappings(sch, i) {
            if (sch.const) {
              addMapping(sch.const, i);
            } else if (sch.enum) {
              for (const tagValue of sch.enum) {
                addMapping(tagValue, i);
              }
            } else {
              throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
            }
          }
          function addMapping(tagValue, i) {
            if (typeof tagValue != "string" || tagValue in oneOfMapping) {
              throw new Error(`discriminator: "${tagName}" values must be unique strings`);
            }
            oneOfMapping[tagValue] = i;
          }
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/conf/node_modules/ajv/dist/refs/json-schema-draft-07.json
var require_json_schema_draft_07 = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/refs/json-schema-draft-07.json"(exports2, module2) {
    module2.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "http://json-schema.org/draft-07/schema#",
      title: "Core schema meta-schema",
      definitions: {
        schemaArray: {
          type: "array",
          minItems: 1,
          items: { $ref: "#" }
        },
        nonNegativeInteger: {
          type: "integer",
          minimum: 0
        },
        nonNegativeIntegerDefault0: {
          allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }]
        },
        simpleTypes: {
          enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
        },
        stringArray: {
          type: "array",
          items: { type: "string" },
          uniqueItems: true,
          default: []
        }
      },
      type: ["object", "boolean"],
      properties: {
        $id: {
          type: "string",
          format: "uri-reference"
        },
        $schema: {
          type: "string",
          format: "uri"
        },
        $ref: {
          type: "string",
          format: "uri-reference"
        },
        $comment: {
          type: "string"
        },
        title: {
          type: "string"
        },
        description: {
          type: "string"
        },
        default: true,
        readOnly: {
          type: "boolean",
          default: false
        },
        examples: {
          type: "array",
          items: true
        },
        multipleOf: {
          type: "number",
          exclusiveMinimum: 0
        },
        maximum: {
          type: "number"
        },
        exclusiveMaximum: {
          type: "number"
        },
        minimum: {
          type: "number"
        },
        exclusiveMinimum: {
          type: "number"
        },
        maxLength: { $ref: "#/definitions/nonNegativeInteger" },
        minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        pattern: {
          type: "string",
          format: "regex"
        },
        additionalItems: { $ref: "#" },
        items: {
          anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
          default: true
        },
        maxItems: { $ref: "#/definitions/nonNegativeInteger" },
        minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        uniqueItems: {
          type: "boolean",
          default: false
        },
        contains: { $ref: "#" },
        maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
        minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        required: { $ref: "#/definitions/stringArray" },
        additionalProperties: { $ref: "#" },
        definitions: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        properties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        patternProperties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          propertyNames: { format: "regex" },
          default: {}
        },
        dependencies: {
          type: "object",
          additionalProperties: {
            anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }]
          }
        },
        propertyNames: { $ref: "#" },
        const: true,
        enum: {
          type: "array",
          items: true,
          minItems: 1,
          uniqueItems: true
        },
        type: {
          anyOf: [
            { $ref: "#/definitions/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/definitions/simpleTypes" },
              minItems: 1,
              uniqueItems: true
            }
          ]
        },
        format: { type: "string" },
        contentMediaType: { type: "string" },
        contentEncoding: { type: "string" },
        if: { $ref: "#" },
        then: { $ref: "#" },
        else: { $ref: "#" },
        allOf: { $ref: "#/definitions/schemaArray" },
        anyOf: { $ref: "#/definitions/schemaArray" },
        oneOf: { $ref: "#/definitions/schemaArray" },
        not: { $ref: "#" }
      },
      default: true
    };
  }
});

// node_modules/conf/node_modules/ajv/dist/ajv.js
var require_ajv = __commonJS({
  "node_modules/conf/node_modules/ajv/dist/ajv.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MissingRefError = exports2.ValidationError = exports2.CodeGen = exports2.Name = exports2.nil = exports2.stringify = exports2.str = exports2._ = exports2.KeywordCxt = exports2.Ajv = void 0;
    var core_1 = require_core();
    var draft7_1 = require_draft7();
    var discriminator_1 = require_discriminator();
    var draft7MetaSchema = require_json_schema_draft_07();
    var META_SUPPORT_DATA = ["/properties"];
    var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
    var Ajv = class extends core_1.default {
      _addVocabularies() {
        super._addVocabularies();
        draft7_1.default.forEach((v) => this.addVocabulary(v));
        if (this.opts.discriminator)
          this.addKeyword(discriminator_1.default);
      }
      _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        if (!this.opts.meta)
          return;
        const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
      }
    };
    exports2.Ajv = Ajv;
    module2.exports = exports2 = Ajv;
    module2.exports.Ajv = Ajv;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = Ajv;
    var validate_1 = require_validate();
    Object.defineProperty(exports2, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports2, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    Object.defineProperty(exports2, "ValidationError", { enumerable: true, get: function() {
      return validation_error_1.default;
    } });
    var ref_error_1 = require_ref_error();
    Object.defineProperty(exports2, "MissingRefError", { enumerable: true, get: function() {
      return ref_error_1.default;
    } });
  }
});

// node_modules/ajv-formats/dist/formats.js
var require_formats = __commonJS({
  "node_modules/ajv-formats/dist/formats.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.formatNames = exports2.fastFormats = exports2.fullFormats = void 0;
    function fmtDef(validate, compare) {
      return { validate, compare };
    }
    exports2.fullFormats = {
      // date: http://tools.ietf.org/html/rfc3339#section-5.6
      date: fmtDef(date, compareDate),
      // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
      time: fmtDef(time, compareTime),
      "date-time": fmtDef(date_time, compareDateTime),
      // duration: https://tools.ietf.org/html/rfc3339#appendix-A
      duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
      uri,
      "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
      // uri-template: https://tools.ietf.org/html/rfc6570
      "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
      // For the source: https://gist.github.com/dperini/729294
      // For test cases: https://mathiasbynens.be/demo/url-regex
      url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
      email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
      hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
      // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
      ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
      regex,
      // uuid: http://tools.ietf.org/html/rfc4122
      uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
      // JSON-pointer: https://tools.ietf.org/html/rfc6901
      // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
      "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
      "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
      // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
      "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
      // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
      // byte: https://github.com/miguelmota/is-base64
      byte,
      // signed 32 bit integer
      int32: { type: "number", validate: validateInt32 },
      // signed 64 bit integer
      int64: { type: "number", validate: validateInt64 },
      // C-type float
      float: { type: "number", validate: validateNumber },
      // C-type double
      double: { type: "number", validate: validateNumber },
      // hint to the UI to hide input strings
      password: true,
      // unchecked string payload
      binary: true
    };
    exports2.fastFormats = {
      ...exports2.fullFormats,
      date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
      time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareTime),
      "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
      // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
      uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
      "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
      // email (sources from jsen validator):
      // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
      // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
      email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
    };
    exports2.formatNames = Object.keys(exports2.fullFormats);
    function isLeapYear(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }
    var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
    var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    function date(str) {
      const matches = DATE.exec(str);
      if (!matches)
        return false;
      const year = +matches[1];
      const month = +matches[2];
      const day = +matches[3];
      return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
    }
    function compareDate(d1, d2) {
      if (!(d1 && d2))
        return void 0;
      if (d1 > d2)
        return 1;
      if (d1 < d2)
        return -1;
      return 0;
    }
    var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
    function time(str, withTimeZone) {
      const matches = TIME.exec(str);
      if (!matches)
        return false;
      const hour = +matches[1];
      const minute = +matches[2];
      const second = +matches[3];
      const timeZone = matches[5];
      return (hour <= 23 && minute <= 59 && second <= 59 || hour === 23 && minute === 59 && second === 60) && (!withTimeZone || timeZone !== "");
    }
    function compareTime(t1, t2) {
      if (!(t1 && t2))
        return void 0;
      const a1 = TIME.exec(t1);
      const a2 = TIME.exec(t2);
      if (!(a1 && a2))
        return void 0;
      t1 = a1[1] + a1[2] + a1[3] + (a1[4] || "");
      t2 = a2[1] + a2[2] + a2[3] + (a2[4] || "");
      if (t1 > t2)
        return 1;
      if (t1 < t2)
        return -1;
      return 0;
    }
    var DATE_TIME_SEPARATOR = /t|\s/i;
    function date_time(str) {
      const dateTime = str.split(DATE_TIME_SEPARATOR);
      return dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1], true);
    }
    function compareDateTime(dt1, dt2) {
      if (!(dt1 && dt2))
        return void 0;
      const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);
      const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR);
      const res = compareDate(d1, d2);
      if (res === void 0)
        return void 0;
      return res || compareTime(t1, t2);
    }
    var NOT_URI_FRAGMENT = /\/|:/;
    var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    function uri(str) {
      return NOT_URI_FRAGMENT.test(str) && URI.test(str);
    }
    var BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
    function byte(str) {
      BYTE.lastIndex = 0;
      return BYTE.test(str);
    }
    var MIN_INT32 = -(2 ** 31);
    var MAX_INT32 = 2 ** 31 - 1;
    function validateInt32(value) {
      return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
    }
    function validateInt64(value) {
      return Number.isInteger(value);
    }
    function validateNumber() {
      return true;
    }
    var Z_ANCHOR = /[^\\]\\Z/;
    function regex(str) {
      if (Z_ANCHOR.test(str))
        return false;
      try {
        new RegExp(str);
        return true;
      } catch (e) {
        return false;
      }
    }
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/codegen/code.js
var require_code3 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/compile/codegen/code.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.regexpCode = exports2.getEsmExportName = exports2.getProperty = exports2.safeStringify = exports2.stringify = exports2.strConcat = exports2.addCodeArg = exports2.str = exports2._ = exports2.nil = exports2._Code = exports2.Name = exports2.IDENTIFIER = exports2._CodeOrName = void 0;
    var _CodeOrName = class {
    };
    exports2._CodeOrName = _CodeOrName;
    exports2.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    var Name = class extends _CodeOrName {
      constructor(s) {
        super();
        if (!exports2.IDENTIFIER.test(s))
          throw new Error("CodeGen: name must be a valid identifier");
        this.str = s;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return false;
      }
      get names() {
        return { [this.str]: 1 };
      }
    };
    exports2.Name = Name;
    var _Code = class extends _CodeOrName {
      constructor(code) {
        super();
        this._items = typeof code === "string" ? [code] : code;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1)
          return false;
        const item = this._items[0];
        return item === "" || item === '""';
      }
      get str() {
        var _a;
        return (_a = this._str) !== null && _a !== void 0 ? _a : this._str = this._items.reduce((s, c) => `${s}${c}`, "");
      }
      get names() {
        var _a;
        return (_a = this._names) !== null && _a !== void 0 ? _a : this._names = this._items.reduce((names, c) => {
          if (c instanceof Name)
            names[c.str] = (names[c.str] || 0) + 1;
          return names;
        }, {});
      }
    };
    exports2._Code = _Code;
    exports2.nil = new _Code("");
    function _(strs, ...args) {
      const code = [strs[0]];
      let i = 0;
      while (i < args.length) {
        addCodeArg(code, args[i]);
        code.push(strs[++i]);
      }
      return new _Code(code);
    }
    exports2._ = _;
    var plus = new _Code("+");
    function str(strs, ...args) {
      const expr = [safeStringify(strs[0])];
      let i = 0;
      while (i < args.length) {
        expr.push(plus);
        addCodeArg(expr, args[i]);
        expr.push(plus, safeStringify(strs[++i]));
      }
      optimize(expr);
      return new _Code(expr);
    }
    exports2.str = str;
    function addCodeArg(code, arg) {
      if (arg instanceof _Code)
        code.push(...arg._items);
      else if (arg instanceof Name)
        code.push(arg);
      else
        code.push(interpolate(arg));
    }
    exports2.addCodeArg = addCodeArg;
    function optimize(expr) {
      let i = 1;
      while (i < expr.length - 1) {
        if (expr[i] === plus) {
          const res = mergeExprItems(expr[i - 1], expr[i + 1]);
          if (res !== void 0) {
            expr.splice(i - 1, 3, res);
            continue;
          }
          expr[i++] = "+";
        }
        i++;
      }
    }
    function mergeExprItems(a, b) {
      if (b === '""')
        return a;
      if (a === '""')
        return b;
      if (typeof a == "string") {
        if (b instanceof Name || a[a.length - 1] !== '"')
          return;
        if (typeof b != "string")
          return `${a.slice(0, -1)}${b}"`;
        if (b[0] === '"')
          return a.slice(0, -1) + b.slice(1);
        return;
      }
      if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
        return `"${a}${b.slice(1)}`;
      return;
    }
    function strConcat(c1, c2) {
      return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
    }
    exports2.strConcat = strConcat;
    function interpolate(x) {
      return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
    }
    function stringify(x) {
      return new _Code(safeStringify(x));
    }
    exports2.stringify = stringify;
    function safeStringify(x) {
      return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    exports2.safeStringify = safeStringify;
    function getProperty(key) {
      return typeof key == "string" && exports2.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
    }
    exports2.getProperty = getProperty;
    function getEsmExportName(key) {
      if (typeof key == "string" && exports2.IDENTIFIER.test(key)) {
        return new _Code(`${key}`);
      }
      throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
    }
    exports2.getEsmExportName = getEsmExportName;
    function regexpCode(rx) {
      return new _Code(rx.toString());
    }
    exports2.regexpCode = regexpCode;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/codegen/scope.js
var require_scope3 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/compile/codegen/scope.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ValueScope = exports2.ValueScopeName = exports2.Scope = exports2.varKinds = exports2.UsedValueState = void 0;
    var code_1 = require_code3();
    var ValueError = class extends Error {
      constructor(name) {
        super(`CodeGen: "code" for ${name} not defined`);
        this.value = name.value;
      }
    };
    var UsedValueState;
    (function(UsedValueState2) {
      UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
      UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
    })(UsedValueState || (exports2.UsedValueState = UsedValueState = {}));
    exports2.varKinds = {
      const: new code_1.Name("const"),
      let: new code_1.Name("let"),
      var: new code_1.Name("var")
    };
    var Scope = class {
      constructor({ prefixes, parent } = {}) {
        this._names = {};
        this._prefixes = prefixes;
        this._parent = parent;
      }
      toName(nameOrPrefix) {
        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
      }
      name(prefix) {
        return new code_1.Name(this._newName(prefix));
      }
      _newName(prefix) {
        const ng = this._names[prefix] || this._nameGroup(prefix);
        return `${prefix}${ng.index++}`;
      }
      _nameGroup(prefix) {
        var _a, _b;
        if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
          throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
        }
        return this._names[prefix] = { prefix, index: 0 };
      }
    };
    exports2.Scope = Scope;
    var ValueScopeName = class extends code_1.Name {
      constructor(prefix, nameStr) {
        super(nameStr);
        this.prefix = prefix;
      }
      setValue(value, { property, itemIndex }) {
        this.value = value;
        this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;
      }
    };
    exports2.ValueScopeName = ValueScopeName;
    var line = (0, code_1._)`\n`;
    var ValueScope = class extends Scope {
      constructor(opts) {
        super(opts);
        this._values = {};
        this._scope = opts.scope;
        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
      }
      get() {
        return this._scope;
      }
      name(prefix) {
        return new ValueScopeName(prefix, this._newName(prefix));
      }
      value(nameOrPrefix, value) {
        var _a;
        if (value.ref === void 0)
          throw new Error("CodeGen: ref must be passed in value");
        const name = this.toName(nameOrPrefix);
        const { prefix } = name;
        const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
        let vs = this._values[prefix];
        if (vs) {
          const _name = vs.get(valueKey);
          if (_name)
            return _name;
        } else {
          vs = this._values[prefix] = /* @__PURE__ */ new Map();
        }
        vs.set(valueKey, name);
        const s = this._scope[prefix] || (this._scope[prefix] = []);
        const itemIndex = s.length;
        s[itemIndex] = value.ref;
        name.setValue(value, { property: prefix, itemIndex });
        return name;
      }
      getValue(prefix, keyOrRef) {
        const vs = this._values[prefix];
        if (!vs)
          return;
        return vs.get(keyOrRef);
      }
      scopeRefs(scopeName, values = this._values) {
        return this._reduceValues(values, (name) => {
          if (name.scopePath === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return (0, code_1._)`${scopeName}${name.scopePath}`;
        });
      }
      scopeCode(values = this._values, usedValues, getCode) {
        return this._reduceValues(values, (name) => {
          if (name.value === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return name.value.code;
        }, usedValues, getCode);
      }
      _reduceValues(values, valueCode, usedValues = {}, getCode) {
        let code = code_1.nil;
        for (const prefix in values) {
          const vs = values[prefix];
          if (!vs)
            continue;
          const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
          vs.forEach((name) => {
            if (nameSet.has(name))
              return;
            nameSet.set(name, UsedValueState.Started);
            let c = valueCode(name);
            if (c) {
              const def = this.opts.es5 ? exports2.varKinds.var : exports2.varKinds.const;
              code = (0, code_1._)`${code}${def} ${name} = ${c};${this.opts._n}`;
            } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {
              code = (0, code_1._)`${code}${c}${this.opts._n}`;
            } else {
              throw new ValueError(name);
            }
            nameSet.set(name, UsedValueState.Completed);
          });
        }
        return code;
      }
    };
    exports2.ValueScope = ValueScope;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/codegen/index.js
var require_codegen2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/compile/codegen/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.or = exports2.and = exports2.not = exports2.CodeGen = exports2.operators = exports2.varKinds = exports2.ValueScopeName = exports2.ValueScope = exports2.Scope = exports2.Name = exports2.regexpCode = exports2.stringify = exports2.getProperty = exports2.nil = exports2.strConcat = exports2.str = exports2._ = void 0;
    var code_1 = require_code3();
    var scope_1 = require_scope3();
    var code_2 = require_code3();
    Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
      return code_2._;
    } });
    Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
      return code_2.str;
    } });
    Object.defineProperty(exports2, "strConcat", { enumerable: true, get: function() {
      return code_2.strConcat;
    } });
    Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
      return code_2.nil;
    } });
    Object.defineProperty(exports2, "getProperty", { enumerable: true, get: function() {
      return code_2.getProperty;
    } });
    Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
      return code_2.stringify;
    } });
    Object.defineProperty(exports2, "regexpCode", { enumerable: true, get: function() {
      return code_2.regexpCode;
    } });
    Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
      return code_2.Name;
    } });
    var scope_2 = require_scope3();
    Object.defineProperty(exports2, "Scope", { enumerable: true, get: function() {
      return scope_2.Scope;
    } });
    Object.defineProperty(exports2, "ValueScope", { enumerable: true, get: function() {
      return scope_2.ValueScope;
    } });
    Object.defineProperty(exports2, "ValueScopeName", { enumerable: true, get: function() {
      return scope_2.ValueScopeName;
    } });
    Object.defineProperty(exports2, "varKinds", { enumerable: true, get: function() {
      return scope_2.varKinds;
    } });
    exports2.operators = {
      GT: new code_1._Code(">"),
      GTE: new code_1._Code(">="),
      LT: new code_1._Code("<"),
      LTE: new code_1._Code("<="),
      EQ: new code_1._Code("==="),
      NEQ: new code_1._Code("!=="),
      NOT: new code_1._Code("!"),
      OR: new code_1._Code("||"),
      AND: new code_1._Code("&&"),
      ADD: new code_1._Code("+")
    };
    var Node = class {
      optimizeNodes() {
        return this;
      }
      optimizeNames(_names, _constants) {
        return this;
      }
    };
    var Def = class extends Node {
      constructor(varKind, name, rhs) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.rhs = rhs;
      }
      render({ es5, _n }) {
        const varKind = es5 ? scope_1.varKinds.var : this.varKind;
        const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${varKind} ${this.name}${rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (!names[this.name.str])
          return;
        if (this.rhs)
          this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
      }
    };
    var Assign = class extends Node {
      constructor(lhs, rhs, sideEffects) {
        super();
        this.lhs = lhs;
        this.rhs = rhs;
        this.sideEffects = sideEffects;
      }
      render({ _n }) {
        return `${this.lhs} = ${this.rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)
          return;
        this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
        return addExprNames(names, this.rhs);
      }
    };
    var AssignOp = class extends Assign {
      constructor(lhs, op, rhs, sideEffects) {
        super(lhs, rhs, sideEffects);
        this.op = op;
      }
      render({ _n }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
      }
    };
    var Label = class extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        return `${this.label}:` + _n;
      }
    };
    var Break = class extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        const label = this.label ? ` ${this.label}` : "";
        return `break${label};` + _n;
      }
    };
    var Throw = class extends Node {
      constructor(error) {
        super();
        this.error = error;
      }
      render({ _n }) {
        return `throw ${this.error};` + _n;
      }
      get names() {
        return this.error.names;
      }
    };
    var AnyCode = class extends Node {
      constructor(code) {
        super();
        this.code = code;
      }
      render({ _n }) {
        return `${this.code};` + _n;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(names, constants) {
        this.code = optimizeExpr(this.code, names, constants);
        return this;
      }
      get names() {
        return this.code instanceof code_1._CodeOrName ? this.code.names : {};
      }
    };
    var ParentNode = class extends Node {
      constructor(nodes = []) {
        super();
        this.nodes = nodes;
      }
      render(opts) {
        return this.nodes.reduce((code, n) => code + n.render(opts), "");
      }
      optimizeNodes() {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i].optimizeNodes();
          if (Array.isArray(n))
            nodes.splice(i, 1, ...n);
          else if (n)
            nodes[i] = n;
          else
            nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      optimizeNames(names, constants) {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i];
          if (n.optimizeNames(names, constants))
            continue;
          subtractNames(names, n.names);
          nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((names, n) => addNames(names, n.names), {});
      }
    };
    var BlockNode = class extends ParentNode {
      render(opts) {
        return "{" + opts._n + super.render(opts) + "}" + opts._n;
      }
    };
    var Root = class extends ParentNode {
    };
    var Else = class extends BlockNode {
    };
    Else.kind = "else";
    var If = class _If extends BlockNode {
      constructor(condition, nodes) {
        super(nodes);
        this.condition = condition;
      }
      render(opts) {
        let code = `if(${this.condition})` + super.render(opts);
        if (this.else)
          code += "else " + this.else.render(opts);
        return code;
      }
      optimizeNodes() {
        super.optimizeNodes();
        const cond = this.condition;
        if (cond === true)
          return this.nodes;
        let e = this.else;
        if (e) {
          const ns = e.optimizeNodes();
          e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
        }
        if (e) {
          if (cond === false)
            return e instanceof _If ? e : e.nodes;
          if (this.nodes.length)
            return this;
          return new _If(not(cond), e instanceof _If ? [e] : e.nodes);
        }
        if (cond === false || !this.nodes.length)
          return void 0;
        return this;
      }
      optimizeNames(names, constants) {
        var _a;
        this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
        if (!(super.optimizeNames(names, constants) || this.else))
          return;
        this.condition = optimizeExpr(this.condition, names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        addExprNames(names, this.condition);
        if (this.else)
          addNames(names, this.else.names);
        return names;
      }
    };
    If.kind = "if";
    var For = class extends BlockNode {
    };
    For.kind = "for";
    var ForLoop = class extends For {
      constructor(iteration) {
        super();
        this.iteration = iteration;
      }
      render(opts) {
        return `for(${this.iteration})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
          return;
        this.iteration = optimizeExpr(this.iteration, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iteration.names);
      }
    };
    var ForRange = class extends For {
      constructor(varKind, name, from, to) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.from = from;
        this.to = to;
      }
      render(opts) {
        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
        const { name, from, to } = this;
        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
      }
      get names() {
        const names = addExprNames(super.names, this.from);
        return addExprNames(names, this.to);
      }
    };
    var ForIter = class extends For {
      constructor(loop, varKind, name, iterable) {
        super();
        this.loop = loop;
        this.varKind = varKind;
        this.name = name;
        this.iterable = iterable;
      }
      render(opts) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
          return;
        this.iterable = optimizeExpr(this.iterable, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iterable.names);
      }
    };
    var Func = class extends BlockNode {
      constructor(name, args, async) {
        super();
        this.name = name;
        this.args = args;
        this.async = async;
      }
      render(opts) {
        const _async = this.async ? "async " : "";
        return `${_async}function ${this.name}(${this.args})` + super.render(opts);
      }
    };
    Func.kind = "func";
    var Return = class extends ParentNode {
      render(opts) {
        return "return " + super.render(opts);
      }
    };
    Return.kind = "return";
    var Try = class extends BlockNode {
      render(opts) {
        let code = "try" + super.render(opts);
        if (this.catch)
          code += this.catch.render(opts);
        if (this.finally)
          code += this.finally.render(opts);
        return code;
      }
      optimizeNodes() {
        var _a, _b;
        super.optimizeNodes();
        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
        return this;
      }
      optimizeNames(names, constants) {
        var _a, _b;
        super.optimizeNames(names, constants);
        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        if (this.catch)
          addNames(names, this.catch.names);
        if (this.finally)
          addNames(names, this.finally.names);
        return names;
      }
    };
    var Catch = class extends BlockNode {
      constructor(error) {
        super();
        this.error = error;
      }
      render(opts) {
        return `catch(${this.error})` + super.render(opts);
      }
    };
    Catch.kind = "catch";
    var Finally = class extends BlockNode {
      render(opts) {
        return "finally" + super.render(opts);
      }
    };
    Finally.kind = "finally";
    var CodeGen = class {
      constructor(extScope, opts = {}) {
        this._values = {};
        this._blockStarts = [];
        this._constants = {};
        this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
        this._extScope = extScope;
        this._scope = new scope_1.Scope({ parent: extScope });
        this._nodes = [new Root()];
      }
      toString() {
        return this._root.render(this.opts);
      }
      // returns unique name in the internal scope
      name(prefix) {
        return this._scope.name(prefix);
      }
      // reserves unique name in the external scope
      scopeName(prefix) {
        return this._extScope.name(prefix);
      }
      // reserves unique name in the external scope and assigns value to it
      scopeValue(prefixOrName, value) {
        const name = this._extScope.value(prefixOrName, value);
        const vs = this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set());
        vs.add(name);
        return name;
      }
      getScopeValue(prefix, keyOrRef) {
        return this._extScope.getValue(prefix, keyOrRef);
      }
      // return code that assigns values in the external scope to the names that are used internally
      // (same names that were returned by gen.scopeName or gen.scopeValue)
      scopeRefs(scopeName) {
        return this._extScope.scopeRefs(scopeName, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(varKind, nameOrPrefix, rhs, constant) {
        const name = this._scope.toName(nameOrPrefix);
        if (rhs !== void 0 && constant)
          this._constants[name.str] = rhs;
        this._leafNode(new Def(varKind, name, rhs));
        return name;
      }
      // `const` declaration (`var` in es5 mode)
      const(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
      }
      // `let` declaration with optional assignment (`var` in es5 mode)
      let(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
      }
      // `var` declaration with optional assignment
      var(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
      }
      // assignment code
      assign(lhs, rhs, sideEffects) {
        return this._leafNode(new Assign(lhs, rhs, sideEffects));
      }
      // `+=` code
      add(lhs, rhs) {
        return this._leafNode(new AssignOp(lhs, exports2.operators.ADD, rhs));
      }
      // appends passed SafeExpr to code or executes Block
      code(c) {
        if (typeof c == "function")
          c();
        else if (c !== code_1.nil)
          this._leafNode(new AnyCode(c));
        return this;
      }
      // returns code for object literal for the passed argument list of key-value pairs
      object(...keyValues) {
        const code = ["{"];
        for (const [key, value] of keyValues) {
          if (code.length > 1)
            code.push(",");
          code.push(key);
          if (key !== value || this.opts.es5) {
            code.push(":");
            (0, code_1.addCodeArg)(code, value);
          }
        }
        code.push("}");
        return new code_1._Code(code);
      }
      // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
      if(condition, thenBody, elseBody) {
        this._blockNode(new If(condition));
        if (thenBody && elseBody) {
          this.code(thenBody).else().code(elseBody).endIf();
        } else if (thenBody) {
          this.code(thenBody).endIf();
        } else if (elseBody) {
          throw new Error('CodeGen: "else" body without "then" body');
        }
        return this;
      }
      // `else if` clause - invalid without `if` or after `else` clauses
      elseIf(condition) {
        return this._elseNode(new If(condition));
      }
      // `else` clause - only valid after `if` or `else if` clauses
      else() {
        return this._elseNode(new Else());
      }
      // end `if` statement (needed if gen.if was used only with condition)
      endIf() {
        return this._endBlockNode(If, Else);
      }
      _for(node, forBody) {
        this._blockNode(node);
        if (forBody)
          this.code(forBody).endFor();
        return this;
      }
      // a generic `for` clause (or statement if `forBody` is passed)
      for(iteration, forBody) {
        return this._for(new ForLoop(iteration), forBody);
      }
      // `for` statement for a range of values
      forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
      }
      // `for-of` statement (in es5 mode replace with a normal for loop)
      forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
        const name = this._scope.toName(nameOrPrefix);
        if (this.opts.es5) {
          const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
          return this.forRange("_i", 0, (0, code_1._)`${arr}.length`, (i) => {
            this.var(name, (0, code_1._)`${arr}[${i}]`);
            forBody(name);
          });
        }
        return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
      }
      // `for-in` statement.
      // With option `ownProperties` replaced with a `for-of` loop for object keys
      forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
        if (this.opts.ownProperties) {
          return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);
        }
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
      }
      // end `for` loop
      endFor() {
        return this._endBlockNode(For);
      }
      // `label` statement
      label(label) {
        return this._leafNode(new Label(label));
      }
      // `break` statement
      break(label) {
        return this._leafNode(new Break(label));
      }
      // `return` statement
      return(value) {
        const node = new Return();
        this._blockNode(node);
        this.code(value);
        if (node.nodes.length !== 1)
          throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(Return);
      }
      // `try` statement
      try(tryBody, catchCode, finallyCode) {
        if (!catchCode && !finallyCode)
          throw new Error('CodeGen: "try" without "catch" and "finally"');
        const node = new Try();
        this._blockNode(node);
        this.code(tryBody);
        if (catchCode) {
          const error = this.name("e");
          this._currNode = node.catch = new Catch(error);
          catchCode(error);
        }
        if (finallyCode) {
          this._currNode = node.finally = new Finally();
          this.code(finallyCode);
        }
        return this._endBlockNode(Catch, Finally);
      }
      // `throw` statement
      throw(error) {
        return this._leafNode(new Throw(error));
      }
      // start self-balancing block
      block(body, nodeCount) {
        this._blockStarts.push(this._nodes.length);
        if (body)
          this.code(body).endBlock(nodeCount);
        return this;
      }
      // end the current self-balancing block
      endBlock(nodeCount) {
        const len = this._blockStarts.pop();
        if (len === void 0)
          throw new Error("CodeGen: not in self-balancing block");
        const toClose = this._nodes.length - len;
        if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
          throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
        }
        this._nodes.length = len;
        return this;
      }
      // `function` heading (or definition if funcBody is passed)
      func(name, args = code_1.nil, async, funcBody) {
        this._blockNode(new Func(name, args, async));
        if (funcBody)
          this.code(funcBody).endFunc();
        return this;
      }
      // end function definition
      endFunc() {
        return this._endBlockNode(Func);
      }
      optimize(n = 1) {
        while (n-- > 0) {
          this._root.optimizeNodes();
          this._root.optimizeNames(this._root.names, this._constants);
        }
      }
      _leafNode(node) {
        this._currNode.nodes.push(node);
        return this;
      }
      _blockNode(node) {
        this._currNode.nodes.push(node);
        this._nodes.push(node);
      }
      _endBlockNode(N1, N2) {
        const n = this._currNode;
        if (n instanceof N1 || N2 && n instanceof N2) {
          this._nodes.pop();
          return this;
        }
        throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
      }
      _elseNode(node) {
        const n = this._currNode;
        if (!(n instanceof If)) {
          throw new Error('CodeGen: "else" without "if"');
        }
        this._currNode = n.else = node;
        return this;
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        const ns = this._nodes;
        return ns[ns.length - 1];
      }
      set _currNode(node) {
        const ns = this._nodes;
        ns[ns.length - 1] = node;
      }
    };
    exports2.CodeGen = CodeGen;
    function addNames(names, from) {
      for (const n in from)
        names[n] = (names[n] || 0) + (from[n] || 0);
      return names;
    }
    function addExprNames(names, from) {
      return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
    }
    function optimizeExpr(expr, names, constants) {
      if (expr instanceof code_1.Name)
        return replaceName(expr);
      if (!canOptimize(expr))
        return expr;
      return new code_1._Code(expr._items.reduce((items, c) => {
        if (c instanceof code_1.Name)
          c = replaceName(c);
        if (c instanceof code_1._Code)
          items.push(...c._items);
        else
          items.push(c);
        return items;
      }, []));
      function replaceName(n) {
        const c = constants[n.str];
        if (c === void 0 || names[n.str] !== 1)
          return n;
        delete names[n.str];
        return c;
      }
      function canOptimize(e) {
        return e instanceof code_1._Code && e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== void 0);
      }
    }
    function subtractNames(names, from) {
      for (const n in from)
        names[n] = (names[n] || 0) - (from[n] || 0);
    }
    function not(x) {
      return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._)`!${par(x)}`;
    }
    exports2.not = not;
    var andCode = mappend(exports2.operators.AND);
    function and(...args) {
      return args.reduce(andCode);
    }
    exports2.and = and;
    var orCode = mappend(exports2.operators.OR);
    function or(...args) {
      return args.reduce(orCode);
    }
    exports2.or = or;
    function mappend(op) {
      return (x, y) => x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._)`${par(x)} ${op} ${par(y)}`;
    }
    function par(x) {
      return x instanceof code_1.Name ? x : (0, code_1._)`(${x})`;
    }
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/util.js
var require_util2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/compile/util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.checkStrictMode = exports2.getErrorPath = exports2.Type = exports2.useFunc = exports2.setEvaluated = exports2.evaluatedPropsToName = exports2.mergeEvaluated = exports2.eachItem = exports2.unescapeJsonPointer = exports2.escapeJsonPointer = exports2.escapeFragment = exports2.unescapeFragment = exports2.schemaRefOrVal = exports2.schemaHasRulesButRef = exports2.schemaHasRules = exports2.checkUnknownRules = exports2.alwaysValidSchema = exports2.toHash = void 0;
    var codegen_1 = require_codegen2();
    var code_1 = require_code3();
    function toHash(arr) {
      const hash = {};
      for (const item of arr)
        hash[item] = true;
      return hash;
    }
    exports2.toHash = toHash;
    function alwaysValidSchema(it, schema) {
      if (typeof schema == "boolean")
        return schema;
      if (Object.keys(schema).length === 0)
        return true;
      checkUnknownRules(it, schema);
      return !schemaHasRules(schema, it.self.RULES.all);
    }
    exports2.alwaysValidSchema = alwaysValidSchema;
    function checkUnknownRules(it, schema = it.schema) {
      const { opts, self: self2 } = it;
      if (!opts.strictSchema)
        return;
      if (typeof schema === "boolean")
        return;
      const rules = self2.RULES.keywords;
      for (const key in schema) {
        if (!rules[key])
          checkStrictMode(it, `unknown keyword: "${key}"`);
      }
    }
    exports2.checkUnknownRules = checkUnknownRules;
    function schemaHasRules(schema, rules) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (rules[key])
          return true;
      return false;
    }
    exports2.schemaHasRules = schemaHasRules;
    function schemaHasRulesButRef(schema, RULES) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (key !== "$ref" && RULES.all[key])
          return true;
      return false;
    }
    exports2.schemaHasRulesButRef = schemaHasRulesButRef;
    function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
      if (!$data) {
        if (typeof schema == "number" || typeof schema == "boolean")
          return schema;
        if (typeof schema == "string")
          return (0, codegen_1._)`${schema}`;
      }
      return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;
    }
    exports2.schemaRefOrVal = schemaRefOrVal;
    function unescapeFragment(str) {
      return unescapeJsonPointer(decodeURIComponent(str));
    }
    exports2.unescapeFragment = unescapeFragment;
    function escapeFragment(str) {
      return encodeURIComponent(escapeJsonPointer(str));
    }
    exports2.escapeFragment = escapeFragment;
    function escapeJsonPointer(str) {
      if (typeof str == "number")
        return `${str}`;
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    exports2.escapeJsonPointer = escapeJsonPointer;
    function unescapeJsonPointer(str) {
      return str.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    exports2.unescapeJsonPointer = unescapeJsonPointer;
    function eachItem(xs, f) {
      if (Array.isArray(xs)) {
        for (const x of xs)
          f(x);
      } else {
        f(xs);
      }
    }
    exports2.eachItem = eachItem;
    function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {
      return (gen, from, to, toName) => {
        const res = to === void 0 ? from : to instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);
        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
      };
    }
    exports2.mergeEvaluated = {
      props: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => {
          gen.if((0, codegen_1._)`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._)`${to} || {}`).code((0, codegen_1._)`Object.assign(${to}, ${from})`));
        }),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => {
          if (from === true) {
            gen.assign(to, true);
          } else {
            gen.assign(to, (0, codegen_1._)`${to} || {}`);
            setEvaluated(gen, to, from);
          }
        }),
        mergeValues: (from, to) => from === true ? true : { ...from, ...to },
        resultToName: evaluatedPropsToName
      }),
      items: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._)`${to} > ${from} ? ${to} : ${from}`)),
        mergeValues: (from, to) => from === true ? true : Math.max(from, to),
        resultToName: (gen, items) => gen.var("items", items)
      })
    };
    function evaluatedPropsToName(gen, ps) {
      if (ps === true)
        return gen.var("props", true);
      const props = gen.var("props", (0, codegen_1._)`{}`);
      if (ps !== void 0)
        setEvaluated(gen, props, ps);
      return props;
    }
    exports2.evaluatedPropsToName = evaluatedPropsToName;
    function setEvaluated(gen, props, ps) {
      Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p)}`, true));
    }
    exports2.setEvaluated = setEvaluated;
    var snippets = {};
    function useFunc(gen, f) {
      return gen.scopeValue("func", {
        ref: f,
        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))
      });
    }
    exports2.useFunc = useFunc;
    var Type;
    (function(Type2) {
      Type2[Type2["Num"] = 0] = "Num";
      Type2[Type2["Str"] = 1] = "Str";
    })(Type || (exports2.Type = Type = {}));
    function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
      if (dataProp instanceof codegen_1.Name) {
        const isNumber = dataPropType === Type.Num;
        return jsPropertySyntax ? isNumber ? (0, codegen_1._)`"[" + ${dataProp} + "]"` : (0, codegen_1._)`"['" + ${dataProp} + "']"` : isNumber ? (0, codegen_1._)`"/" + ${dataProp}` : (0, codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
      }
      return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
    }
    exports2.getErrorPath = getErrorPath;
    function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
      if (!mode)
        return;
      msg = `strict mode: ${msg}`;
      if (mode === true)
        throw new Error(msg);
      it.self.logger.warn(msg);
    }
    exports2.checkStrictMode = checkStrictMode;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/names.js
var require_names2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/compile/names.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen2();
    var names = {
      // validation function arguments
      data: new codegen_1.Name("data"),
      // data passed to validation function
      // args passed from referencing schema
      valCxt: new codegen_1.Name("valCxt"),
      // validation/data context - should not be used directly, it is destructured to the names below
      instancePath: new codegen_1.Name("instancePath"),
      parentData: new codegen_1.Name("parentData"),
      parentDataProperty: new codegen_1.Name("parentDataProperty"),
      rootData: new codegen_1.Name("rootData"),
      // root data - same as the data passed to the first/top validation function
      dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
      // used to support recursiveRef and dynamicRef
      // function scoped variables
      vErrors: new codegen_1.Name("vErrors"),
      // null or array of validation errors
      errors: new codegen_1.Name("errors"),
      // counter of validation errors
      this: new codegen_1.Name("this"),
      // "globals"
      self: new codegen_1.Name("self"),
      scope: new codegen_1.Name("scope"),
      // JTD serialize/parse name for JSON string and position
      json: new codegen_1.Name("json"),
      jsonPos: new codegen_1.Name("jsonPos"),
      jsonLen: new codegen_1.Name("jsonLen"),
      jsonPart: new codegen_1.Name("jsonPart")
    };
    exports2.default = names;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/errors.js
var require_errors2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/compile/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.extendErrors = exports2.resetErrorsCount = exports2.reportExtraError = exports2.reportError = exports2.keyword$DataError = exports2.keywordError = void 0;
    var codegen_1 = require_codegen2();
    var util_1 = require_util2();
    var names_1 = require_names2();
    exports2.keywordError = {
      message: ({ keyword }) => (0, codegen_1.str)`must pass "${keyword}" keyword validation`
    };
    exports2.keyword$DataError = {
      message: ({ keyword, schemaType }) => schemaType ? (0, codegen_1.str)`"${keyword}" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`"${keyword}" keyword is invalid ($data)`
    };
    function reportError(cxt, error = exports2.keywordError, errorPaths, overrideAllErrors) {
      const { it } = cxt;
      const { gen, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
        addError(gen, errObj);
      } else {
        returnErrors(it, (0, codegen_1._)`[${errObj}]`);
      }
    }
    exports2.reportError = reportError;
    function reportExtraError(cxt, error = exports2.keywordError, errorPaths) {
      const { it } = cxt;
      const { gen, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      addError(gen, errObj);
      if (!(compositeRule || allErrors)) {
        returnErrors(it, names_1.default.vErrors);
      }
    }
    exports2.reportExtraError = reportExtraError;
    function resetErrorsCount(gen, errsCount) {
      gen.assign(names_1.default.errors, errsCount);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
    }
    exports2.resetErrorsCount = resetErrorsCount;
    function extendErrors({ gen, keyword, schemaValue, data, errsCount, it }) {
      if (errsCount === void 0)
        throw new Error("ajv implementation error");
      const err = gen.name("err");
      gen.forRange("i", errsCount, names_1.default.errors, (i) => {
        gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`);
        gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._)`${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));
        gen.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it.errSchemaPath}/${keyword}`);
        if (it.opts.verbose) {
          gen.assign((0, codegen_1._)`${err}.schema`, schemaValue);
          gen.assign((0, codegen_1._)`${err}.data`, data);
        }
      });
    }
    exports2.extendErrors = extendErrors;
    function addError(gen, errObj) {
      const err = gen.const("err", errObj);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`);
      gen.code((0, codegen_1._)`${names_1.default.errors}++`);
    }
    function returnErrors(it, errs) {
      const { gen, validateName, schemaEnv } = it;
      if (schemaEnv.$async) {
        gen.throw((0, codegen_1._)`new ${it.ValidationError}(${errs})`);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, errs);
        gen.return(false);
      }
    }
    var E = {
      keyword: new codegen_1.Name("keyword"),
      schemaPath: new codegen_1.Name("schemaPath"),
      // also used in JTD errors
      params: new codegen_1.Name("params"),
      propertyName: new codegen_1.Name("propertyName"),
      message: new codegen_1.Name("message"),
      schema: new codegen_1.Name("schema"),
      parentSchema: new codegen_1.Name("parentSchema")
    };
    function errorObjectCode(cxt, error, errorPaths) {
      const { createErrors } = cxt.it;
      if (createErrors === false)
        return (0, codegen_1._)`{}`;
      return errorObject(cxt, error, errorPaths);
    }
    function errorObject(cxt, error, errorPaths = {}) {
      const { gen, it } = cxt;
      const keyValues = [
        errorInstancePath(it, errorPaths),
        errorSchemaPath(cxt, errorPaths)
      ];
      extraErrorProps(cxt, error, keyValues);
      return gen.object(...keyValues);
    }
    function errorInstancePath({ errorPath }, { instancePath }) {
      const instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;
      return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
    }
    function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
      let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword}`;
      if (schemaPath) {
        schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
      }
      return [E.schemaPath, schPath];
    }
    function extraErrorProps(cxt, { params, message }, keyValues) {
      const { keyword, data, schemaValue, it } = cxt;
      const { opts, propertyName, topSchemaRef, schemaPath } = it;
      keyValues.push([E.keyword, keyword], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._)`{}`]);
      if (opts.messages) {
        keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
      }
      if (opts.verbose) {
        keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
      }
      if (propertyName)
        keyValues.push([E.propertyName, propertyName]);
    }
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/boolSchema.js
var require_boolSchema2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/boolSchema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.boolOrEmptySchema = exports2.topBoolOrEmptySchema = void 0;
    var errors_1 = require_errors2();
    var codegen_1 = require_codegen2();
    var names_1 = require_names2();
    var boolError = {
      message: "boolean schema is false"
    };
    function topBoolOrEmptySchema(it) {
      const { gen, schema, validateName } = it;
      if (schema === false) {
        falseSchemaError(it, false);
      } else if (typeof schema == "object" && schema.$async === true) {
        gen.return(names_1.default.data);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, null);
        gen.return(true);
      }
    }
    exports2.topBoolOrEmptySchema = topBoolOrEmptySchema;
    function boolOrEmptySchema(it, valid) {
      const { gen, schema } = it;
      if (schema === false) {
        gen.var(valid, false);
        falseSchemaError(it);
      } else {
        gen.var(valid, true);
      }
    }
    exports2.boolOrEmptySchema = boolOrEmptySchema;
    function falseSchemaError(it, overrideAllErrors) {
      const { gen, data } = it;
      const cxt = {
        gen,
        keyword: "false schema",
        data,
        schema: false,
        schemaCode: false,
        schemaValue: false,
        params: {},
        it
      };
      (0, errors_1.reportError)(cxt, boolError, void 0, overrideAllErrors);
    }
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/rules.js
var require_rules2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/compile/rules.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getRules = exports2.isJSONType = void 0;
    var _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
    var jsonTypes = new Set(_jsonTypes);
    function isJSONType(x) {
      return typeof x == "string" && jsonTypes.has(x);
    }
    exports2.isJSONType = isJSONType;
    function getRules() {
      const groups = {
        number: { type: "number", rules: [] },
        string: { type: "string", rules: [] },
        array: { type: "array", rules: [] },
        object: { type: "object", rules: [] }
      };
      return {
        types: { ...groups, integer: true, boolean: true, null: true },
        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
        post: { rules: [] },
        all: {},
        keywords: {}
      };
    }
    exports2.getRules = getRules;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/applicability.js
var require_applicability2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/applicability.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.shouldUseRule = exports2.shouldUseGroup = exports2.schemaHasRulesForType = void 0;
    function schemaHasRulesForType({ schema, self: self2 }, type) {
      const group = self2.RULES.types[type];
      return group && group !== true && shouldUseGroup(schema, group);
    }
    exports2.schemaHasRulesForType = schemaHasRulesForType;
    function shouldUseGroup(schema, group) {
      return group.rules.some((rule) => shouldUseRule(schema, rule));
    }
    exports2.shouldUseGroup = shouldUseGroup;
    function shouldUseRule(schema, rule) {
      var _a;
      return schema[rule.keyword] !== void 0 || ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== void 0));
    }
    exports2.shouldUseRule = shouldUseRule;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/dataType.js
var require_dataType2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/dataType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.reportTypeError = exports2.checkDataTypes = exports2.checkDataType = exports2.coerceAndCheckDataType = exports2.getJSONTypes = exports2.getSchemaTypes = exports2.DataType = void 0;
    var rules_1 = require_rules2();
    var applicability_1 = require_applicability2();
    var errors_1 = require_errors2();
    var codegen_1 = require_codegen2();
    var util_1 = require_util2();
    var DataType;
    (function(DataType2) {
      DataType2[DataType2["Correct"] = 0] = "Correct";
      DataType2[DataType2["Wrong"] = 1] = "Wrong";
    })(DataType || (exports2.DataType = DataType = {}));
    function getSchemaTypes(schema) {
      const types = getJSONTypes(schema.type);
      const hasNull = types.includes("null");
      if (hasNull) {
        if (schema.nullable === false)
          throw new Error("type: null contradicts nullable: false");
      } else {
        if (!types.length && schema.nullable !== void 0) {
          throw new Error('"nullable" cannot be used without "type"');
        }
        if (schema.nullable === true)
          types.push("null");
      }
      return types;
    }
    exports2.getSchemaTypes = getSchemaTypes;
    function getJSONTypes(ts) {
      const types = Array.isArray(ts) ? ts : ts ? [ts] : [];
      if (types.every(rules_1.isJSONType))
        return types;
      throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
    }
    exports2.getJSONTypes = getJSONTypes;
    function coerceAndCheckDataType(it, types) {
      const { gen, data, opts } = it;
      const coerceTo = coerceToTypes(types, opts.coerceTypes);
      const checkTypes = types.length > 0 && !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));
      if (checkTypes) {
        const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
        gen.if(wrongType, () => {
          if (coerceTo.length)
            coerceData(it, types, coerceTo);
          else
            reportTypeError(it);
        });
      }
      return checkTypes;
    }
    exports2.coerceAndCheckDataType = coerceAndCheckDataType;
    var COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
    function coerceToTypes(types, coerceTypes) {
      return coerceTypes ? types.filter((t) => COERCIBLE.has(t) || coerceTypes === "array" && t === "array") : [];
    }
    function coerceData(it, types, coerceTo) {
      const { gen, data, opts } = it;
      const dataType = gen.let("dataType", (0, codegen_1._)`typeof ${data}`);
      const coerced = gen.let("coerced", (0, codegen_1._)`undefined`);
      if (opts.coerceTypes === "array") {
        gen.if((0, codegen_1._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1._)`${data}[0]`).assign(dataType, (0, codegen_1._)`typeof ${data}`).if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));
      }
      gen.if((0, codegen_1._)`${coerced} !== undefined`);
      for (const t of coerceTo) {
        if (COERCIBLE.has(t) || t === "array" && opts.coerceTypes === "array") {
          coerceSpecificType(t);
        }
      }
      gen.else();
      reportTypeError(it);
      gen.endIf();
      gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {
        gen.assign(data, coerced);
        assignParentData(it, coerced);
      });
      function coerceSpecificType(t) {
        switch (t) {
          case "string":
            gen.elseIf((0, codegen_1._)`${dataType} == "number" || ${dataType} == "boolean"`).assign(coerced, (0, codegen_1._)`"" + ${data}`).elseIf((0, codegen_1._)`${data} === null`).assign(coerced, (0, codegen_1._)`""`);
            return;
          case "number":
            gen.elseIf((0, codegen_1._)`${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "integer":
            gen.elseIf((0, codegen_1._)`${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "boolean":
            gen.elseIf((0, codegen_1._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
            return;
          case "null":
            gen.elseIf((0, codegen_1._)`${data} === "" || ${data} === 0 || ${data} === false`);
            gen.assign(coerced, null);
            return;
          case "array":
            gen.elseIf((0, codegen_1._)`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1._)`[${data}]`);
        }
      }
    }
    function assignParentData({ gen, parentData, parentDataProperty }, expr) {
      gen.if((0, codegen_1._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));
    }
    function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
      const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
      let cond;
      switch (dataType) {
        case "null":
          return (0, codegen_1._)`${data} ${EQ} null`;
        case "array":
          cond = (0, codegen_1._)`Array.isArray(${data})`;
          break;
        case "object":
          cond = (0, codegen_1._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
          break;
        case "integer":
          cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);
          break;
        case "number":
          cond = numCond();
          break;
        default:
          return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType}`;
      }
      return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
      function numCond(_cond = codegen_1.nil) {
        return (0, codegen_1.and)((0, codegen_1._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil);
      }
    }
    exports2.checkDataType = checkDataType;
    function checkDataTypes(dataTypes, data, strictNums, correct) {
      if (dataTypes.length === 1) {
        return checkDataType(dataTypes[0], data, strictNums, correct);
      }
      let cond;
      const types = (0, util_1.toHash)(dataTypes);
      if (types.array && types.object) {
        const notObj = (0, codegen_1._)`typeof ${data} != "object"`;
        cond = types.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`;
        delete types.null;
        delete types.array;
        delete types.object;
      } else {
        cond = codegen_1.nil;
      }
      if (types.number)
        delete types.integer;
      for (const t in types)
        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));
      return cond;
    }
    exports2.checkDataTypes = checkDataTypes;
    var typeError = {
      message: ({ schema }) => `must be ${schema}`,
      params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`
    };
    function reportTypeError(it) {
      const cxt = getTypeErrorContext(it);
      (0, errors_1.reportError)(cxt, typeError);
    }
    exports2.reportTypeError = reportTypeError;
    function getTypeErrorContext(it) {
      const { gen, data, schema } = it;
      const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
      return {
        gen,
        keyword: "type",
        data,
        schema: schema.type,
        schemaCode,
        schemaValue: schemaCode,
        parentSchema: schema,
        params: {},
        it
      };
    }
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/defaults.js
var require_defaults2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/defaults.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.assignDefaults = void 0;
    var codegen_1 = require_codegen2();
    var util_1 = require_util2();
    function assignDefaults(it, ty) {
      const { properties, items } = it.schema;
      if (ty === "object" && properties) {
        for (const key in properties) {
          assignDefault(it, key, properties[key].default);
        }
      } else if (ty === "array" && Array.isArray(items)) {
        items.forEach((sch, i) => assignDefault(it, i, sch.default));
      }
    }
    exports2.assignDefaults = assignDefaults;
    function assignDefault(it, prop, defaultValue) {
      const { gen, compositeRule, data, opts } = it;
      if (defaultValue === void 0)
        return;
      const childData = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(prop)}`;
      if (compositeRule) {
        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
        return;
      }
      let condition = (0, codegen_1._)`${childData} === undefined`;
      if (opts.useDefaults === "empty") {
        condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`;
      }
      gen.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
    }
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/code.js
var require_code4 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/code.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateUnion = exports2.validateArray = exports2.usePattern = exports2.callValidateCode = exports2.schemaProperties = exports2.allSchemaProperties = exports2.noPropertyInData = exports2.propertyInData = exports2.isOwnProperty = exports2.hasPropFunc = exports2.reportMissingProp = exports2.checkMissingProp = exports2.checkReportMissingProp = void 0;
    var codegen_1 = require_codegen2();
    var util_1 = require_util2();
    var names_1 = require_names2();
    var util_2 = require_util2();
    function checkReportMissingProp(cxt, prop) {
      const { gen, data, it } = cxt;
      gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
        cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, true);
        cxt.error();
      });
    }
    exports2.checkReportMissingProp = checkReportMissingProp;
    function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
      return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));
    }
    exports2.checkMissingProp = checkMissingProp;
    function reportMissingProp(cxt, missing) {
      cxt.setParams({ missingProperty: missing }, true);
      cxt.error();
    }
    exports2.reportMissingProp = reportMissingProp;
    function hasPropFunc(gen) {
      return gen.scopeValue("func", {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        ref: Object.prototype.hasOwnProperty,
        code: (0, codegen_1._)`Object.prototype.hasOwnProperty`
      });
    }
    exports2.hasPropFunc = hasPropFunc;
    function isOwnProperty(gen, data, property) {
      return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
    }
    exports2.isOwnProperty = isOwnProperty;
    function propertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
      return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
    }
    exports2.propertyInData = propertyInData;
    function noPropertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} === undefined`;
      return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
    }
    exports2.noPropertyInData = noPropertyInData;
    function allSchemaProperties(schemaMap) {
      return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
    }
    exports2.allSchemaProperties = allSchemaProperties;
    function schemaProperties(it, schemaMap) {
      return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));
    }
    exports2.schemaProperties = schemaProperties;
    function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
      const dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
      const valCxt = [
        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
        [names_1.default.parentData, it.parentData],
        [names_1.default.parentDataProperty, it.parentDataProperty],
        [names_1.default.rootData, names_1.default.rootData]
      ];
      if (it.opts.dynamicRef)
        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
      const args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
      return context !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context}, ${args})` : (0, codegen_1._)`${func}(${args})`;
    }
    exports2.callValidateCode = callValidateCode;
    var newRegExp = (0, codegen_1._)`new RegExp`;
    function usePattern({ gen, it: { opts } }, pattern) {
      const u = opts.unicodeRegExp ? "u" : "";
      const { regExp } = opts.code;
      const rx = regExp(pattern, u);
      return gen.scopeValue("pattern", {
        key: rx.toString(),
        ref: rx,
        code: (0, codegen_1._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`
      });
    }
    exports2.usePattern = usePattern;
    function validateArray(cxt) {
      const { gen, data, keyword, it } = cxt;
      const valid = gen.name("valid");
      if (it.allErrors) {
        const validArr = gen.let("valid", true);
        validateItems(() => gen.assign(validArr, false));
        return validArr;
      }
      gen.var(valid, true);
      validateItems(() => gen.break());
      return valid;
      function validateItems(notValid) {
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        gen.forRange("i", 0, len, (i) => {
          cxt.subschema({
            keyword,
            dataProp: i,
            dataPropType: util_1.Type.Num
          }, valid);
          gen.if((0, codegen_1.not)(valid), notValid);
        });
      }
    }
    exports2.validateArray = validateArray;
    function validateUnion(cxt) {
      const { gen, schema, keyword, it } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));
      if (alwaysValid && !it.opts.unevaluated)
        return;
      const valid = gen.let("valid", false);
      const schValid = gen.name("_valid");
      gen.block(() => schema.forEach((_sch, i) => {
        const schCxt = cxt.subschema({
          keyword,
          schemaProp: i,
          compositeRule: true
        }, schValid);
        gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`);
        const merged = cxt.mergeValidEvaluated(schCxt, schValid);
        if (!merged)
          gen.if((0, codegen_1.not)(valid));
      }));
      cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
    }
    exports2.validateUnion = validateUnion;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/keyword.js
var require_keyword2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/keyword.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateKeywordUsage = exports2.validSchemaType = exports2.funcKeywordCode = exports2.macroKeywordCode = void 0;
    var codegen_1 = require_codegen2();
    var names_1 = require_names2();
    var code_1 = require_code4();
    var errors_1 = require_errors2();
    function macroKeywordCode(cxt, def) {
      const { gen, keyword, schema, parentSchema, it } = cxt;
      const macroSchema = def.macro.call(it.self, schema, parentSchema, it);
      const schemaRef = useKeyword(gen, keyword, macroSchema);
      if (it.opts.validateSchema !== false)
        it.self.validateSchema(macroSchema, true);
      const valid = gen.name("valid");
      cxt.subschema({
        schema: macroSchema,
        schemaPath: codegen_1.nil,
        errSchemaPath: `${it.errSchemaPath}/${keyword}`,
        topSchemaRef: schemaRef,
        compositeRule: true
      }, valid);
      cxt.pass(valid, () => cxt.error(true));
    }
    exports2.macroKeywordCode = macroKeywordCode;
    function funcKeywordCode(cxt, def) {
      var _a;
      const { gen, keyword, schema, parentSchema, $data, it } = cxt;
      checkAsyncKeyword(it, def);
      const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;
      const validateRef = useKeyword(gen, keyword, validate);
      const valid = gen.let("valid");
      cxt.block$data(valid, validateKeyword);
      cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);
      function validateKeyword() {
        if (def.errors === false) {
          assignValid();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => cxt.error());
        } else {
          const ruleErrs = def.async ? validateAsync() : validateSync();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => addErrs(cxt, ruleErrs));
        }
      }
      function validateAsync() {
        const ruleErrs = gen.let("ruleErrs", null);
        gen.try(() => assignValid((0, codegen_1._)`await `), (e) => gen.assign(valid, false).if((0, codegen_1._)`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e}.errors`), () => gen.throw(e)));
        return ruleErrs;
      }
      function validateSync() {
        const validateErrs = (0, codegen_1._)`${validateRef}.errors`;
        gen.assign(validateErrs, null);
        assignValid(codegen_1.nil);
        return validateErrs;
      }
      function assignValid(_await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil) {
        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
        const passSchema = !("compile" in def && !$data || def.schema === false);
        gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
      }
      function reportErrs(errors) {
        var _a2;
        gen.if((0, codegen_1.not)((_a2 = def.valid) !== null && _a2 !== void 0 ? _a2 : valid), errors);
      }
    }
    exports2.funcKeywordCode = funcKeywordCode;
    function modifyData(cxt) {
      const { gen, data, it } = cxt;
      gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._)`${it.parentData}[${it.parentDataProperty}]`));
    }
    function addErrs(cxt, errs) {
      const { gen } = cxt;
      gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
        (0, errors_1.extendErrors)(cxt);
      }, () => cxt.error());
    }
    function checkAsyncKeyword({ schemaEnv }, def) {
      if (def.async && !schemaEnv.$async)
        throw new Error("async keyword in sync schema");
    }
    function useKeyword(gen, keyword, result) {
      if (result === void 0)
        throw new Error(`keyword "${keyword}" failed to compile`);
      return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
    }
    function validSchemaType(schema, schemaType, allowUndefined = false) {
      return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema) : st === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == "undefined");
    }
    exports2.validSchemaType = validSchemaType;
    function validateKeywordUsage({ schema, opts, self: self2, errSchemaPath }, def, keyword) {
      if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
        throw new Error("ajv implementation error");
      }
      const deps = def.dependencies;
      if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
      }
      if (def.validateSchema) {
        const valid = def.validateSchema(schema[keyword]);
        if (!valid) {
          const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` + self2.errorsText(def.validateSchema.errors);
          if (opts.validateSchema === "log")
            self2.logger.error(msg);
          else
            throw new Error(msg);
        }
      }
    }
    exports2.validateKeywordUsage = validateKeywordUsage;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/subschema.js
var require_subschema2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/subschema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.extendSubschemaMode = exports2.extendSubschemaData = exports2.getSubschema = void 0;
    var codegen_1 = require_codegen2();
    var util_1 = require_util2();
    function getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
      if (keyword !== void 0 && schema !== void 0) {
        throw new Error('both "keyword" and "schema" passed, only one allowed');
      }
      if (keyword !== void 0) {
        const sch = it.schema[keyword];
        return schemaProp === void 0 ? {
          schema: sch,
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword}`
        } : {
          schema: sch[schemaProp],
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`
        };
      }
      if (schema !== void 0) {
        if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
          throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
        }
        return {
          schema,
          schemaPath,
          topSchemaRef,
          errSchemaPath
        };
      }
      throw new Error('either "keyword" or "schema" must be passed');
    }
    exports2.getSubschema = getSubschema;
    function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
      if (data !== void 0 && dataProp !== void 0) {
        throw new Error('both "data" and "dataProp" passed, only one allowed');
      }
      const { gen } = it;
      if (dataProp !== void 0) {
        const { errorPath, dataPathArr, opts } = it;
        const nextData = gen.let("data", (0, codegen_1._)`${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
        dataContextProps(nextData);
        subschema.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
        subschema.parentDataProperty = (0, codegen_1._)`${dataProp}`;
        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
      }
      if (data !== void 0) {
        const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true);
        dataContextProps(nextData);
        if (propertyName !== void 0)
          subschema.propertyName = propertyName;
      }
      if (dataTypes)
        subschema.dataTypes = dataTypes;
      function dataContextProps(_nextData) {
        subschema.data = _nextData;
        subschema.dataLevel = it.dataLevel + 1;
        subschema.dataTypes = [];
        it.definedProperties = /* @__PURE__ */ new Set();
        subschema.parentData = it.data;
        subschema.dataNames = [...it.dataNames, _nextData];
      }
    }
    exports2.extendSubschemaData = extendSubschemaData;
    function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
      if (compositeRule !== void 0)
        subschema.compositeRule = compositeRule;
      if (createErrors !== void 0)
        subschema.createErrors = createErrors;
      if (allErrors !== void 0)
        subschema.allErrors = allErrors;
      subschema.jtdDiscriminator = jtdDiscriminator;
      subschema.jtdMetadata = jtdMetadata;
    }
    exports2.extendSubschemaMode = extendSubschemaMode;
  }
});

// node_modules/ajv-formats/node_modules/json-schema-traverse/index.js
var require_json_schema_traverse2 = __commonJS({
  "node_modules/ajv-formats/node_modules/json-schema-traverse/index.js"(exports2, module2) {
    "use strict";
    var traverse = module2.exports = function(schema, opts, cb) {
      if (typeof opts == "function") {
        cb = opts;
        opts = {};
      }
      cb = opts.cb || cb;
      var pre = typeof cb == "function" ? cb : cb.pre || function() {
      };
      var post = cb.post || function() {
      };
      _traverse(opts, pre, post, schema, "", schema);
    };
    traverse.keywords = {
      additionalItems: true,
      items: true,
      contains: true,
      additionalProperties: true,
      propertyNames: true,
      not: true,
      if: true,
      then: true,
      else: true
    };
    traverse.arrayKeywords = {
      items: true,
      allOf: true,
      anyOf: true,
      oneOf: true
    };
    traverse.propsKeywords = {
      $defs: true,
      definitions: true,
      properties: true,
      patternProperties: true,
      dependencies: true
    };
    traverse.skipKeywords = {
      default: true,
      enum: true,
      const: true,
      required: true,
      maximum: true,
      minimum: true,
      exclusiveMaximum: true,
      exclusiveMinimum: true,
      multipleOf: true,
      maxLength: true,
      minLength: true,
      pattern: true,
      format: true,
      maxItems: true,
      minItems: true,
      uniqueItems: true,
      maxProperties: true,
      minProperties: true
    };
    function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (schema && typeof schema == "object" && !Array.isArray(schema)) {
        pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for (var key in schema) {
          var sch = schema[key];
          if (Array.isArray(sch)) {
            if (key in traverse.arrayKeywords) {
              for (var i = 0; i < sch.length; i++)
                _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
            }
          } else if (key in traverse.propsKeywords) {
            if (sch && typeof sch == "object") {
              for (var prop in sch)
                _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
            }
          } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
            _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
          }
        }
        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      }
    }
    function escapeJsonPtr(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/resolve.js
var require_resolve2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/compile/resolve.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getSchemaRefs = exports2.resolveUrl = exports2.normalizeId = exports2._getFullPath = exports2.getFullPath = exports2.inlineRef = void 0;
    var util_1 = require_util2();
    var equal = require_fast_deep_equal();
    var traverse = require_json_schema_traverse2();
    var SIMPLE_INLINED = /* @__PURE__ */ new Set([
      "type",
      "format",
      "pattern",
      "maxLength",
      "minLength",
      "maxProperties",
      "minProperties",
      "maxItems",
      "minItems",
      "maximum",
      "minimum",
      "uniqueItems",
      "multipleOf",
      "required",
      "enum",
      "const"
    ]);
    function inlineRef(schema, limit = true) {
      if (typeof schema == "boolean")
        return true;
      if (limit === true)
        return !hasRef(schema);
      if (!limit)
        return false;
      return countKeys(schema) <= limit;
    }
    exports2.inlineRef = inlineRef;
    var REF_KEYWORDS = /* @__PURE__ */ new Set([
      "$ref",
      "$recursiveRef",
      "$recursiveAnchor",
      "$dynamicRef",
      "$dynamicAnchor"
    ]);
    function hasRef(schema) {
      for (const key in schema) {
        if (REF_KEYWORDS.has(key))
          return true;
        const sch = schema[key];
        if (Array.isArray(sch) && sch.some(hasRef))
          return true;
        if (typeof sch == "object" && hasRef(sch))
          return true;
      }
      return false;
    }
    function countKeys(schema) {
      let count = 0;
      for (const key in schema) {
        if (key === "$ref")
          return Infinity;
        count++;
        if (SIMPLE_INLINED.has(key))
          continue;
        if (typeof schema[key] == "object") {
          (0, util_1.eachItem)(schema[key], (sch) => count += countKeys(sch));
        }
        if (count === Infinity)
          return Infinity;
      }
      return count;
    }
    function getFullPath(resolver, id = "", normalize) {
      if (normalize !== false)
        id = normalizeId(id);
      const p = resolver.parse(id);
      return _getFullPath(resolver, p);
    }
    exports2.getFullPath = getFullPath;
    function _getFullPath(resolver, p) {
      const serialized = resolver.serialize(p);
      return serialized.split("#")[0] + "#";
    }
    exports2._getFullPath = _getFullPath;
    var TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id) {
      return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
    }
    exports2.normalizeId = normalizeId;
    function resolveUrl(resolver, baseId, id) {
      id = normalizeId(id);
      return resolver.resolve(baseId, id);
    }
    exports2.resolveUrl = resolveUrl;
    var ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
    function getSchemaRefs(schema, baseId) {
      if (typeof schema == "boolean")
        return {};
      const { schemaId, uriResolver } = this.opts;
      const schId = normalizeId(schema[schemaId] || baseId);
      const baseIds = { "": schId };
      const pathPrefix = getFullPath(uriResolver, schId, false);
      const localRefs = {};
      const schemaRefs = /* @__PURE__ */ new Set();
      traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
        if (parentJsonPtr === void 0)
          return;
        const fullPath = pathPrefix + jsonPtr;
        let innerBaseId = baseIds[parentJsonPtr];
        if (typeof sch[schemaId] == "string")
          innerBaseId = addRef.call(this, sch[schemaId]);
        addAnchor.call(this, sch.$anchor);
        addAnchor.call(this, sch.$dynamicAnchor);
        baseIds[jsonPtr] = innerBaseId;
        function addRef(ref) {
          const _resolve = this.opts.uriResolver.resolve;
          ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref);
          if (schemaRefs.has(ref))
            throw ambiguos(ref);
          schemaRefs.add(ref);
          let schOrRef = this.refs[ref];
          if (typeof schOrRef == "string")
            schOrRef = this.refs[schOrRef];
          if (typeof schOrRef == "object") {
            checkAmbiguosRef(sch, schOrRef.schema, ref);
          } else if (ref !== normalizeId(fullPath)) {
            if (ref[0] === "#") {
              checkAmbiguosRef(sch, localRefs[ref], ref);
              localRefs[ref] = sch;
            } else {
              this.refs[ref] = fullPath;
            }
          }
          return ref;
        }
        function addAnchor(anchor) {
          if (typeof anchor == "string") {
            if (!ANCHOR.test(anchor))
              throw new Error(`invalid anchor "${anchor}"`);
            addRef.call(this, `#${anchor}`);
          }
        }
      });
      return localRefs;
      function checkAmbiguosRef(sch1, sch2, ref) {
        if (sch2 !== void 0 && !equal(sch1, sch2))
          throw ambiguos(ref);
      }
      function ambiguos(ref) {
        return new Error(`reference "${ref}" resolves to more than one schema`);
      }
    }
    exports2.getSchemaRefs = getSchemaRefs;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/index.js
var require_validate2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getData = exports2.KeywordCxt = exports2.validateFunctionCode = void 0;
    var boolSchema_1 = require_boolSchema2();
    var dataType_1 = require_dataType2();
    var applicability_1 = require_applicability2();
    var dataType_2 = require_dataType2();
    var defaults_1 = require_defaults2();
    var keyword_1 = require_keyword2();
    var subschema_1 = require_subschema2();
    var codegen_1 = require_codegen2();
    var names_1 = require_names2();
    var resolve_1 = require_resolve2();
    var util_1 = require_util2();
    var errors_1 = require_errors2();
    function validateFunctionCode(it) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          topSchemaObjCode(it);
          return;
        }
      }
      validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
    }
    exports2.validateFunctionCode = validateFunctionCode;
    function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
      if (opts.code.es5) {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
          gen.code((0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts)}`);
          destructureValCxtES5(gen, opts);
          gen.code(body);
        });
      } else {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
      }
    }
    function destructureValCxt(opts) {
      return (0, codegen_1._)`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
    }
    function destructureValCxtES5(gen, opts) {
      gen.if(names_1.default.valCxt, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
        gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
      }, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`""`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.rootData, names_1.default.data);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
      });
    }
    function topSchemaObjCode(it) {
      const { schema, opts, gen } = it;
      validateFunction(it, () => {
        if (opts.$comment && schema.$comment)
          commentKeyword(it);
        checkNoDefault(it);
        gen.let(names_1.default.vErrors, null);
        gen.let(names_1.default.errors, 0);
        if (opts.unevaluated)
          resetEvaluated(it);
        typeAndKeywords(it);
        returnResults(it);
      });
      return;
    }
    function resetEvaluated(it) {
      const { gen, validateName } = it;
      it.evaluated = gen.const("evaluated", (0, codegen_1._)`${validateName}.evaluated`);
      gen.if((0, codegen_1._)`${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._)`${it.evaluated}.props`, (0, codegen_1._)`undefined`));
      gen.if((0, codegen_1._)`${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._)`${it.evaluated}.items`, (0, codegen_1._)`undefined`));
    }
    function funcSourceUrl(schema, opts) {
      const schId = typeof schema == "object" && schema[opts.schemaId];
      return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;
    }
    function subschemaCode(it, valid) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          subSchemaObjCode(it, valid);
          return;
        }
      }
      (0, boolSchema_1.boolOrEmptySchema)(it, valid);
    }
    function schemaCxtHasRules({ schema, self: self2 }) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (self2.RULES.all[key])
          return true;
      return false;
    }
    function isSchemaObj(it) {
      return typeof it.schema != "boolean";
    }
    function subSchemaObjCode(it, valid) {
      const { schema, gen, opts } = it;
      if (opts.$comment && schema.$comment)
        commentKeyword(it);
      updateContext(it);
      checkAsyncSchema(it);
      const errsCount = gen.const("_errs", names_1.default.errors);
      typeAndKeywords(it, errsCount);
      gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
    }
    function checkKeywords(it) {
      (0, util_1.checkUnknownRules)(it);
      checkRefsAndKeywords(it);
    }
    function typeAndKeywords(it, errsCount) {
      if (it.opts.jtd)
        return schemaKeywords(it, [], false, errsCount);
      const types = (0, dataType_1.getSchemaTypes)(it.schema);
      const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);
      schemaKeywords(it, types, !checkedTypes, errsCount);
    }
    function checkRefsAndKeywords(it) {
      const { schema, errSchemaPath, opts, self: self2 } = it;
      if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self2.RULES)) {
        self2.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
      }
    }
    function checkNoDefault(it) {
      const { schema, opts } = it;
      if (schema.default !== void 0 && opts.useDefaults && opts.strictSchema) {
        (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
      }
    }
    function updateContext(it) {
      const schId = it.schema[it.opts.schemaId];
      if (schId)
        it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
    }
    function checkAsyncSchema(it) {
      if (it.schema.$async && !it.schemaEnv.$async)
        throw new Error("async schema in sync schema");
    }
    function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
      const msg = schema.$comment;
      if (opts.$comment === true) {
        gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
      } else if (typeof opts.$comment == "function") {
        const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;
        const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
        gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
      }
    }
    function returnResults(it) {
      const { gen, schemaEnv, validateName, ValidationError, opts } = it;
      if (schemaEnv.$async) {
        gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`));
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors);
        if (opts.unevaluated)
          assignEvaluated(it);
        gen.return((0, codegen_1._)`${names_1.default.errors} === 0`);
      }
    }
    function assignEvaluated({ gen, evaluated, props, items }) {
      if (props instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.props`, props);
      if (items instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.items`, items);
    }
    function schemaKeywords(it, types, typeErrors, errsCount) {
      const { gen, schema, data, allErrors, opts, self: self2 } = it;
      const { RULES } = self2;
      if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
        gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
        return;
      }
      if (!opts.jtd)
        checkStrictTypes(it, types);
      gen.block(() => {
        for (const group of RULES.rules)
          groupKeywords(group);
        groupKeywords(RULES.post);
      });
      function groupKeywords(group) {
        if (!(0, applicability_1.shouldUseGroup)(schema, group))
          return;
        if (group.type) {
          gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
          iterateKeywords(it, group);
          if (types.length === 1 && types[0] === group.type && typeErrors) {
            gen.else();
            (0, dataType_2.reportTypeError)(it);
          }
          gen.endIf();
        } else {
          iterateKeywords(it, group);
        }
        if (!allErrors)
          gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`);
      }
    }
    function iterateKeywords(it, group) {
      const { gen, schema, opts: { useDefaults } } = it;
      if (useDefaults)
        (0, defaults_1.assignDefaults)(it, group.type);
      gen.block(() => {
        for (const rule of group.rules) {
          if ((0, applicability_1.shouldUseRule)(schema, rule)) {
            keywordCode(it, rule.keyword, rule.definition, group.type);
          }
        }
      });
    }
    function checkStrictTypes(it, types) {
      if (it.schemaEnv.meta || !it.opts.strictTypes)
        return;
      checkContextTypes(it, types);
      if (!it.opts.allowUnionTypes)
        checkMultipleTypes(it, types);
      checkKeywordTypes(it, it.dataTypes);
    }
    function checkContextTypes(it, types) {
      if (!types.length)
        return;
      if (!it.dataTypes.length) {
        it.dataTypes = types;
        return;
      }
      types.forEach((t) => {
        if (!includesType(it.dataTypes, t)) {
          strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);
        }
      });
      narrowSchemaTypes(it, types);
    }
    function checkMultipleTypes(it, ts) {
      if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
        strictTypesError(it, "use allowUnionTypes to allow union type keyword");
      }
    }
    function checkKeywordTypes(it, ts) {
      const rules = it.self.RULES.all;
      for (const keyword in rules) {
        const rule = rules[keyword];
        if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
          const { type } = rule.definition;
          if (type.length && !type.some((t) => hasApplicableType(ts, t))) {
            strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`);
          }
        }
      }
    }
    function hasApplicableType(schTs, kwdT) {
      return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
    }
    function includesType(ts, t) {
      return ts.includes(t) || t === "integer" && ts.includes("number");
    }
    function narrowSchemaTypes(it, withTypes) {
      const ts = [];
      for (const t of it.dataTypes) {
        if (includesType(withTypes, t))
          ts.push(t);
        else if (withTypes.includes("integer") && t === "number")
          ts.push("integer");
      }
      it.dataTypes = ts;
    }
    function strictTypesError(it, msg) {
      const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
      msg += ` at "${schemaPath}" (strictTypes)`;
      (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
    }
    var KeywordCxt = class {
      constructor(it, def, keyword) {
        (0, keyword_1.validateKeywordUsage)(it, def, keyword);
        this.gen = it.gen;
        this.allErrors = it.allErrors;
        this.keyword = keyword;
        this.data = it.data;
        this.schema = it.schema[keyword];
        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;
        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);
        this.schemaType = def.schemaType;
        this.parentSchema = it.schema;
        this.params = {};
        this.it = it;
        this.def = def;
        if (this.$data) {
          this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
        } else {
          this.schemaCode = this.schemaValue;
          if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
            throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
          }
        }
        if ("code" in def ? def.trackErrors : def.errors !== false) {
          this.errsCount = it.gen.const("_errs", names_1.default.errors);
        }
      }
      result(condition, successAction, failAction) {
        this.failResult((0, codegen_1.not)(condition), successAction, failAction);
      }
      failResult(condition, successAction, failAction) {
        this.gen.if(condition);
        if (failAction)
          failAction();
        else
          this.error();
        if (successAction) {
          this.gen.else();
          successAction();
          if (this.allErrors)
            this.gen.endIf();
        } else {
          if (this.allErrors)
            this.gen.endIf();
          else
            this.gen.else();
        }
      }
      pass(condition, failAction) {
        this.failResult((0, codegen_1.not)(condition), void 0, failAction);
      }
      fail(condition) {
        if (condition === void 0) {
          this.error();
          if (!this.allErrors)
            this.gen.if(false);
          return;
        }
        this.gen.if(condition);
        this.error();
        if (this.allErrors)
          this.gen.endIf();
        else
          this.gen.else();
      }
      fail$data(condition) {
        if (!this.$data)
          return this.fail(condition);
        const { schemaCode } = this;
        this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
      }
      error(append, errorParams, errorPaths) {
        if (errorParams) {
          this.setParams(errorParams);
          this._error(append, errorPaths);
          this.setParams({});
          return;
        }
        this._error(append, errorPaths);
      }
      _error(append, errorPaths) {
        ;
        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
      }
      $dataError() {
        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
      }
      reset() {
        if (this.errsCount === void 0)
          throw new Error('add "trackErrors" to keyword definition');
        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
      }
      ok(cond) {
        if (!this.allErrors)
          this.gen.if(cond);
      }
      setParams(obj, assign) {
        if (assign)
          Object.assign(this.params, obj);
        else
          this.params = obj;
      }
      block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
        this.gen.block(() => {
          this.check$data(valid, $dataValid);
          codeBlock();
        });
      }
      check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
        if (!this.$data)
          return;
        const { gen, schemaCode, schemaType, def } = this;
        gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid));
        if (valid !== codegen_1.nil)
          gen.assign(valid, true);
        if (schemaType.length || def.validateSchema) {
          gen.elseIf(this.invalid$data());
          this.$dataError();
          if (valid !== codegen_1.nil)
            gen.assign(valid, false);
        }
        gen.else();
      }
      invalid$data() {
        const { gen, schemaCode, schemaType, def, it } = this;
        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
        function wrong$DataType() {
          if (schemaType.length) {
            if (!(schemaCode instanceof codegen_1.Name))
              throw new Error("ajv implementation error");
            const st = Array.isArray(schemaType) ? schemaType : [schemaType];
            return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
          }
          return codegen_1.nil;
        }
        function invalid$DataSchema() {
          if (def.validateSchema) {
            const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema });
            return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
          }
          return codegen_1.nil;
        }
      }
      subschema(appl, valid) {
        const subschema = (0, subschema_1.getSubschema)(this.it, appl);
        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
        (0, subschema_1.extendSubschemaMode)(subschema, appl);
        const nextContext = { ...this.it, ...subschema, items: void 0, props: void 0 };
        subschemaCode(nextContext, valid);
        return nextContext;
      }
      mergeEvaluated(schemaCxt, toName) {
        const { it, gen } = this;
        if (!it.opts.unevaluated)
          return;
        if (it.props !== true && schemaCxt.props !== void 0) {
          it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
        }
        if (it.items !== true && schemaCxt.items !== void 0) {
          it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
        }
      }
      mergeValidEvaluated(schemaCxt, valid) {
        const { it, gen } = this;
        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
          gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
          return true;
        }
      }
    };
    exports2.KeywordCxt = KeywordCxt;
    function keywordCode(it, keyword, def, ruleType) {
      const cxt = new KeywordCxt(it, def, keyword);
      if ("code" in def) {
        def.code(cxt, ruleType);
      } else if (cxt.$data && def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      } else if ("macro" in def) {
        (0, keyword_1.macroKeywordCode)(cxt, def);
      } else if (def.compile || def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      }
    }
    var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
    var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData($data, { dataLevel, dataNames, dataPathArr }) {
      let jsonPointer;
      let data;
      if ($data === "")
        return names_1.default.rootData;
      if ($data[0] === "/") {
        if (!JSON_POINTER.test($data))
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        jsonPointer = $data;
        data = names_1.default.rootData;
      } else {
        const matches = RELATIVE_JSON_POINTER.exec($data);
        if (!matches)
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        const up = +matches[1];
        jsonPointer = matches[2];
        if (jsonPointer === "#") {
          if (up >= dataLevel)
            throw new Error(errorMsg("property/index", up));
          return dataPathArr[dataLevel - up];
        }
        if (up > dataLevel)
          throw new Error(errorMsg("data", up));
        data = dataNames[dataLevel - up];
        if (!jsonPointer)
          return data;
      }
      let expr = data;
      const segments = jsonPointer.split("/");
      for (const segment of segments) {
        if (segment) {
          data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
          expr = (0, codegen_1._)`${expr} && ${data}`;
        }
      }
      return expr;
      function errorMsg(pointerType, up) {
        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
      }
    }
    exports2.getData = getData;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/runtime/validation_error.js
var require_validation_error2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/runtime/validation_error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ValidationError = class extends Error {
      constructor(errors) {
        super("validation failed");
        this.errors = errors;
        this.ajv = this.validation = true;
      }
    };
    exports2.default = ValidationError;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/ref_error.js
var require_ref_error2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/compile/ref_error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var resolve_1 = require_resolve2();
    var MissingRefError = class extends Error {
      constructor(resolver, baseId, ref, msg) {
        super(msg || `can't resolve reference ${ref} from id ${baseId}`);
        this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);
        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
      }
    };
    exports2.default = MissingRefError;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/index.js
var require_compile2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/compile/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveSchema = exports2.getCompilingSchema = exports2.resolveRef = exports2.compileSchema = exports2.SchemaEnv = void 0;
    var codegen_1 = require_codegen2();
    var validation_error_1 = require_validation_error2();
    var names_1 = require_names2();
    var resolve_1 = require_resolve2();
    var util_1 = require_util2();
    var validate_1 = require_validate2();
    var SchemaEnv = class {
      constructor(env) {
        var _a;
        this.refs = {};
        this.dynamicAnchors = {};
        let schema;
        if (typeof env.schema == "object")
          schema = env.schema;
        this.schema = env.schema;
        this.schemaId = env.schemaId;
        this.root = env.root || this;
        this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || "$id"]);
        this.schemaPath = env.schemaPath;
        this.localRefs = env.localRefs;
        this.meta = env.meta;
        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
        this.refs = {};
      }
    };
    exports2.SchemaEnv = SchemaEnv;
    function compileSchema(sch) {
      const _sch = getCompilingSchema.call(this, sch);
      if (_sch)
        return _sch;
      const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
      const { es5, lines } = this.opts.code;
      const { ownProperties } = this.opts;
      const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
      let _ValidationError;
      if (sch.$async) {
        _ValidationError = gen.scopeValue("Error", {
          ref: validation_error_1.default,
          code: (0, codegen_1._)`require("ajv/dist/runtime/validation_error").default`
        });
      }
      const validateName = gen.scopeName("validate");
      sch.validateName = validateName;
      const schemaCxt = {
        gen,
        allErrors: this.opts.allErrors,
        data: names_1.default.data,
        parentData: names_1.default.parentData,
        parentDataProperty: names_1.default.parentDataProperty,
        dataNames: [names_1.default.data],
        dataPathArr: [codegen_1.nil],
        // TODO can its length be used as dataLevel if nil is removed?
        dataLevel: 0,
        dataTypes: [],
        definedProperties: /* @__PURE__ */ new Set(),
        topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) } : { ref: sch.schema }),
        validateName,
        ValidationError: _ValidationError,
        schema: sch.schema,
        schemaEnv: sch,
        rootId,
        baseId: sch.baseId || rootId,
        schemaPath: codegen_1.nil,
        errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
        errorPath: (0, codegen_1._)`""`,
        opts: this.opts,
        self: this
      };
      let sourceCode;
      try {
        this._compilations.add(sch);
        (0, validate_1.validateFunctionCode)(schemaCxt);
        gen.optimize(this.opts.code.optimize);
        const validateCode = gen.toString();
        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
        if (this.opts.code.process)
          sourceCode = this.opts.code.process(sourceCode, sch);
        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
        const validate = makeValidate(this, this.scope.get());
        this.scope.value(validateName, { ref: validate });
        validate.errors = null;
        validate.schema = sch.schema;
        validate.schemaEnv = sch;
        if (sch.$async)
          validate.$async = true;
        if (this.opts.code.source === true) {
          validate.source = { validateName, validateCode, scopeValues: gen._values };
        }
        if (this.opts.unevaluated) {
          const { props, items } = schemaCxt;
          validate.evaluated = {
            props: props instanceof codegen_1.Name ? void 0 : props,
            items: items instanceof codegen_1.Name ? void 0 : items,
            dynamicProps: props instanceof codegen_1.Name,
            dynamicItems: items instanceof codegen_1.Name
          };
          if (validate.source)
            validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);
        }
        sch.validate = validate;
        return sch;
      } catch (e) {
        delete sch.validate;
        delete sch.validateName;
        if (sourceCode)
          this.logger.error("Error compiling schema, function code:", sourceCode);
        throw e;
      } finally {
        this._compilations.delete(sch);
      }
    }
    exports2.compileSchema = compileSchema;
    function resolveRef(root, baseId, ref) {
      var _a;
      ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
      const schOrFunc = root.refs[ref];
      if (schOrFunc)
        return schOrFunc;
      let _sch = resolve.call(this, root, ref);
      if (_sch === void 0) {
        const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref];
        const { schemaId } = this.opts;
        if (schema)
          _sch = new SchemaEnv({ schema, schemaId, root, baseId });
      }
      if (_sch === void 0)
        return;
      return root.refs[ref] = inlineOrCompile.call(this, _sch);
    }
    exports2.resolveRef = resolveRef;
    function inlineOrCompile(sch) {
      if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
        return sch.schema;
      return sch.validate ? sch : compileSchema.call(this, sch);
    }
    function getCompilingSchema(schEnv) {
      for (const sch of this._compilations) {
        if (sameSchemaEnv(sch, schEnv))
          return sch;
      }
    }
    exports2.getCompilingSchema = getCompilingSchema;
    function sameSchemaEnv(s1, s2) {
      return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
    }
    function resolve(root, ref) {
      let sch;
      while (typeof (sch = this.refs[ref]) == "string")
        ref = sch;
      return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
    }
    function resolveSchema(root, ref) {
      const p = this.opts.uriResolver.parse(ref);
      const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);
      let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
      if (Object.keys(root.schema).length > 0 && refPath === baseId) {
        return getJsonPointer.call(this, p, root);
      }
      const id = (0, resolve_1.normalizeId)(refPath);
      const schOrRef = this.refs[id] || this.schemas[id];
      if (typeof schOrRef == "string") {
        const sch = resolveSchema.call(this, root, schOrRef);
        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
          return;
        return getJsonPointer.call(this, p, sch);
      }
      if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
        return;
      if (!schOrRef.validate)
        compileSchema.call(this, schOrRef);
      if (id === (0, resolve_1.normalizeId)(ref)) {
        const { schema } = schOrRef;
        const { schemaId } = this.opts;
        const schId = schema[schemaId];
        if (schId)
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        return new SchemaEnv({ schema, schemaId, root, baseId });
      }
      return getJsonPointer.call(this, p, schOrRef);
    }
    exports2.resolveSchema = resolveSchema;
    var PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
      "properties",
      "patternProperties",
      "enum",
      "dependencies",
      "definitions"
    ]);
    function getJsonPointer(parsedRef, { baseId, schema, root }) {
      var _a;
      if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
        return;
      for (const part of parsedRef.fragment.slice(1).split("/")) {
        if (typeof schema === "boolean")
          return;
        const partSchema = schema[(0, util_1.unescapeFragment)(part)];
        if (partSchema === void 0)
          return;
        schema = partSchema;
        const schId = typeof schema === "object" && schema[this.opts.schemaId];
        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        }
      }
      let env;
      if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
        env = resolveSchema.call(this, root, $ref);
      }
      const { schemaId } = this.opts;
      env = env || new SchemaEnv({ schema, schemaId, root, baseId });
      if (env.schema !== env.root.schema)
        return env;
      return void 0;
    }
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/refs/data.json
var require_data2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/refs/data.json"(exports2, module2) {
    module2.exports = {
      $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
      description: "Meta-schema for $data reference (JSON AnySchema extension proposal)",
      type: "object",
      required: ["$data"],
      properties: {
        $data: {
          type: "string",
          anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }]
        }
      },
      additionalProperties: false
    };
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/runtime/uri.js
var require_uri2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/runtime/uri.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var uri = require_fast_uri();
    uri.code = 'require("ajv/dist/runtime/uri").default';
    exports2.default = uri;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/core.js
var require_core3 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/core.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CodeGen = exports2.Name = exports2.nil = exports2.stringify = exports2.str = exports2._ = exports2.KeywordCxt = void 0;
    var validate_1 = require_validate2();
    Object.defineProperty(exports2, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen2();
    Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports2, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error2();
    var ref_error_1 = require_ref_error2();
    var rules_1 = require_rules2();
    var compile_1 = require_compile2();
    var codegen_2 = require_codegen2();
    var resolve_1 = require_resolve2();
    var dataType_1 = require_dataType2();
    var util_1 = require_util2();
    var $dataRefSchema = require_data2();
    var uri_1 = require_uri2();
    var defaultRegExp = (str, flags) => new RegExp(str, flags);
    defaultRegExp.code = "new RegExp";
    var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
    var EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error"
    ]);
    var removedOptions = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now."
    };
    var deprecatedOptions = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode: '"minLength"/"maxLength" account for unicode characters by default.'
    };
    var MAX_EXPRESSION = 200;
    function requiredOptions(o) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
      const s = o.strict;
      const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;
      const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
      const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
      const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
      return {
        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
        uriResolver
      };
    }
    var Ajv = class {
      constructor(opts = {}) {
        this.schemas = {};
        this.refs = {};
        this.formats = {};
        this._compilations = /* @__PURE__ */ new Set();
        this._loading = {};
        this._cache = /* @__PURE__ */ new Map();
        opts = this.opts = { ...opts, ...requiredOptions(opts) };
        const { es5, lines } = this.opts.code;
        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
        this.logger = getLogger(opts.logger);
        const formatOpt = opts.validateFormats;
        opts.validateFormats = false;
        this.RULES = (0, rules_1.getRules)();
        checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
        checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
        this._metaOpts = getMetaSchemaOptions.call(this);
        if (opts.formats)
          addInitialFormats.call(this);
        this._addVocabularies();
        this._addDefaultMetaSchema();
        if (opts.keywords)
          addInitialKeywords.call(this, opts.keywords);
        if (typeof opts.meta == "object")
          this.addMetaSchema(opts.meta);
        addInitialSchemas.call(this);
        opts.validateFormats = formatOpt;
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        const { $data, meta, schemaId } = this.opts;
        let _dataRefSchema = $dataRefSchema;
        if (schemaId === "id") {
          _dataRefSchema = { ...$dataRefSchema };
          _dataRefSchema.id = _dataRefSchema.$id;
          delete _dataRefSchema.$id;
        }
        if (meta && $data)
          this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
      }
      defaultMeta() {
        const { meta, schemaId } = this.opts;
        return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
      }
      validate(schemaKeyRef, data) {
        let v;
        if (typeof schemaKeyRef == "string") {
          v = this.getSchema(schemaKeyRef);
          if (!v)
            throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
        } else {
          v = this.compile(schemaKeyRef);
        }
        const valid = v(data);
        if (!("$async" in v))
          this.errors = v.errors;
        return valid;
      }
      compile(schema, _meta) {
        const sch = this._addSchema(schema, _meta);
        return sch.validate || this._compileSchemaEnv(sch);
      }
      compileAsync(schema, meta) {
        if (typeof this.opts.loadSchema != "function") {
          throw new Error("options.loadSchema should be a function");
        }
        const { loadSchema } = this.opts;
        return runCompileAsync.call(this, schema, meta);
        async function runCompileAsync(_schema, _meta) {
          await loadMetaSchema.call(this, _schema.$schema);
          const sch = this._addSchema(_schema, _meta);
          return sch.validate || _compileAsync.call(this, sch);
        }
        async function loadMetaSchema($ref) {
          if ($ref && !this.getSchema($ref)) {
            await runCompileAsync.call(this, { $ref }, true);
          }
        }
        async function _compileAsync(sch) {
          try {
            return this._compileSchemaEnv(sch);
          } catch (e) {
            if (!(e instanceof ref_error_1.default))
              throw e;
            checkLoaded.call(this, e);
            await loadMissingSchema.call(this, e.missingSchema);
            return _compileAsync.call(this, sch);
          }
        }
        function checkLoaded({ missingSchema: ref, missingRef }) {
          if (this.refs[ref]) {
            throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
          }
        }
        async function loadMissingSchema(ref) {
          const _schema = await _loadSchema.call(this, ref);
          if (!this.refs[ref])
            await loadMetaSchema.call(this, _schema.$schema);
          if (!this.refs[ref])
            this.addSchema(_schema, ref, meta);
        }
        async function _loadSchema(ref) {
          const p = this._loading[ref];
          if (p)
            return p;
          try {
            return await (this._loading[ref] = loadSchema(ref));
          } finally {
            delete this._loading[ref];
          }
        }
      }
      // Adds schema to the instance
      addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
        if (Array.isArray(schema)) {
          for (const sch of schema)
            this.addSchema(sch, void 0, _meta, _validateSchema);
          return this;
        }
        let id;
        if (typeof schema === "object") {
          const { schemaId } = this.opts;
          id = schema[schemaId];
          if (id !== void 0 && typeof id != "string") {
            throw new Error(`schema ${schemaId} must be string`);
          }
        }
        key = (0, resolve_1.normalizeId)(key || id);
        this._checkUnique(key);
        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
        return this;
      }
      // Add schema that will be used to validate other schemas
      // options in META_IGNORE_OPTIONS are alway set to false
      addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
        this.addSchema(schema, key, true, _validateSchema);
        return this;
      }
      //  Validate schema against its meta-schema
      validateSchema(schema, throwOrLogError) {
        if (typeof schema == "boolean")
          return true;
        let $schema;
        $schema = schema.$schema;
        if ($schema !== void 0 && typeof $schema != "string") {
          throw new Error("$schema must be a string");
        }
        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
        if (!$schema) {
          this.logger.warn("meta-schema not available");
          this.errors = null;
          return true;
        }
        const valid = this.validate($schema, schema);
        if (!valid && throwOrLogError) {
          const message = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log")
            this.logger.error(message);
          else
            throw new Error(message);
        }
        return valid;
      }
      // Get compiled schema by `key` or `ref`.
      // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
      getSchema(keyRef) {
        let sch;
        while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
          keyRef = sch;
        if (sch === void 0) {
          const { schemaId } = this.opts;
          const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
          sch = compile_1.resolveSchema.call(this, root, keyRef);
          if (!sch)
            return;
          this.refs[keyRef] = sch;
        }
        return sch.validate || this._compileSchemaEnv(sch);
      }
      // Remove cached schema(s).
      // If no parameter is passed all schemas but meta-schemas are removed.
      // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
      // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
      removeSchema(schemaKeyRef) {
        if (schemaKeyRef instanceof RegExp) {
          this._removeAllSchemas(this.schemas, schemaKeyRef);
          this._removeAllSchemas(this.refs, schemaKeyRef);
          return this;
        }
        switch (typeof schemaKeyRef) {
          case "undefined":
            this._removeAllSchemas(this.schemas);
            this._removeAllSchemas(this.refs);
            this._cache.clear();
            return this;
          case "string": {
            const sch = getSchEnv.call(this, schemaKeyRef);
            if (typeof sch == "object")
              this._cache.delete(sch.schema);
            delete this.schemas[schemaKeyRef];
            delete this.refs[schemaKeyRef];
            return this;
          }
          case "object": {
            const cacheKey = schemaKeyRef;
            this._cache.delete(cacheKey);
            let id = schemaKeyRef[this.opts.schemaId];
            if (id) {
              id = (0, resolve_1.normalizeId)(id);
              delete this.schemas[id];
              delete this.refs[id];
            }
            return this;
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      // add "vocabulary" - a collection of keywords
      addVocabulary(definitions) {
        for (const def of definitions)
          this.addKeyword(def);
        return this;
      }
      addKeyword(kwdOrDef, def) {
        let keyword;
        if (typeof kwdOrDef == "string") {
          keyword = kwdOrDef;
          if (typeof def == "object") {
            this.logger.warn("these parameters are deprecated, see docs for addKeyword");
            def.keyword = keyword;
          }
        } else if (typeof kwdOrDef == "object" && def === void 0) {
          def = kwdOrDef;
          keyword = def.keyword;
          if (Array.isArray(keyword) && !keyword.length) {
            throw new Error("addKeywords: keyword must be string or non-empty array");
          }
        } else {
          throw new Error("invalid addKeywords parameters");
        }
        checkKeyword.call(this, keyword, def);
        if (!def) {
          (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));
          return this;
        }
        keywordMetaschema.call(this, def);
        const definition = {
          ...def,
          type: (0, dataType_1.getJSONTypes)(def.type),
          schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)
        };
        (0, util_1.eachItem)(keyword, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));
        return this;
      }
      getKeyword(keyword) {
        const rule = this.RULES.all[keyword];
        return typeof rule == "object" ? rule.definition : !!rule;
      }
      // Remove keyword
      removeKeyword(keyword) {
        const { RULES } = this;
        delete RULES.keywords[keyword];
        delete RULES.all[keyword];
        for (const group of RULES.rules) {
          const i = group.rules.findIndex((rule) => rule.keyword === keyword);
          if (i >= 0)
            group.rules.splice(i, 1);
        }
        return this;
      }
      // Add format
      addFormat(name, format) {
        if (typeof format == "string")
          format = new RegExp(format);
        this.formats[name] = format;
        return this;
      }
      errorsText(errors = this.errors, { separator = ", ", dataVar = "data" } = {}) {
        if (!errors || errors.length === 0)
          return "No errors";
        return errors.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
      }
      $dataMetaSchema(metaSchema, keywordsJsonPointers) {
        const rules = this.RULES.all;
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        for (const jsonPointer of keywordsJsonPointers) {
          const segments = jsonPointer.split("/").slice(1);
          let keywords = metaSchema;
          for (const seg of segments)
            keywords = keywords[seg];
          for (const key in rules) {
            const rule = rules[key];
            if (typeof rule != "object")
              continue;
            const { $data } = rule.definition;
            const schema = keywords[key];
            if ($data && schema)
              keywords[key] = schemaOrData(schema);
          }
        }
        return metaSchema;
      }
      _removeAllSchemas(schemas, regex) {
        for (const keyRef in schemas) {
          const sch = schemas[keyRef];
          if (!regex || regex.test(keyRef)) {
            if (typeof sch == "string") {
              delete schemas[keyRef];
            } else if (sch && !sch.meta) {
              this._cache.delete(sch.schema);
              delete schemas[keyRef];
            }
          }
        }
      }
      _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
        let id;
        const { schemaId } = this.opts;
        if (typeof schema == "object") {
          id = schema[schemaId];
        } else {
          if (this.opts.jtd)
            throw new Error("schema must be object");
          else if (typeof schema != "boolean")
            throw new Error("schema must be object or boolean");
        }
        let sch = this._cache.get(schema);
        if (sch !== void 0)
          return sch;
        baseId = (0, resolve_1.normalizeId)(id || baseId);
        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
        sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
        this._cache.set(sch.schema, sch);
        if (addSchema && !baseId.startsWith("#")) {
          if (baseId)
            this._checkUnique(baseId);
          this.refs[baseId] = sch;
        }
        if (validateSchema)
          this.validateSchema(schema, true);
        return sch;
      }
      _checkUnique(id) {
        if (this.schemas[id] || this.refs[id]) {
          throw new Error(`schema with key or id "${id}" already exists`);
        }
      }
      _compileSchemaEnv(sch) {
        if (sch.meta)
          this._compileMetaSchema(sch);
        else
          compile_1.compileSchema.call(this, sch);
        if (!sch.validate)
          throw new Error("ajv implementation error");
        return sch.validate;
      }
      _compileMetaSchema(sch) {
        const currentOpts = this.opts;
        this.opts = this._metaOpts;
        try {
          compile_1.compileSchema.call(this, sch);
        } finally {
          this.opts = currentOpts;
        }
      }
    };
    Ajv.ValidationError = validation_error_1.default;
    Ajv.MissingRefError = ref_error_1.default;
    exports2.default = Ajv;
    function checkOptions(checkOpts, options, msg, log2 = "error") {
      for (const key in checkOpts) {
        const opt = key;
        if (opt in options)
          this.logger[log2](`${msg}: option ${key}. ${checkOpts[opt]}`);
      }
    }
    function getSchEnv(keyRef) {
      keyRef = (0, resolve_1.normalizeId)(keyRef);
      return this.schemas[keyRef] || this.refs[keyRef];
    }
    function addInitialSchemas() {
      const optsSchemas = this.opts.schemas;
      if (!optsSchemas)
        return;
      if (Array.isArray(optsSchemas))
        this.addSchema(optsSchemas);
      else
        for (const key in optsSchemas)
          this.addSchema(optsSchemas[key], key);
    }
    function addInitialFormats() {
      for (const name in this.opts.formats) {
        const format = this.opts.formats[name];
        if (format)
          this.addFormat(name, format);
      }
    }
    function addInitialKeywords(defs) {
      if (Array.isArray(defs)) {
        this.addVocabulary(defs);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (const keyword in defs) {
        const def = defs[keyword];
        if (!def.keyword)
          def.keyword = keyword;
        this.addKeyword(def);
      }
    }
    function getMetaSchemaOptions() {
      const metaOpts = { ...this.opts };
      for (const opt of META_IGNORE_OPTIONS)
        delete metaOpts[opt];
      return metaOpts;
    }
    var noLogs = { log() {
    }, warn() {
    }, error() {
    } };
    function getLogger(logger2) {
      if (logger2 === false)
        return noLogs;
      if (logger2 === void 0)
        return console;
      if (logger2.log && logger2.warn && logger2.error)
        return logger2;
      throw new Error("logger must implement log, warn and error methods");
    }
    var KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
    function checkKeyword(keyword, def) {
      const { RULES } = this;
      (0, util_1.eachItem)(keyword, (kwd) => {
        if (RULES.keywords[kwd])
          throw new Error(`Keyword ${kwd} is already defined`);
        if (!KEYWORD_NAME.test(kwd))
          throw new Error(`Keyword ${kwd} has invalid name`);
      });
      if (!def)
        return;
      if (def.$data && !("code" in def || "validate" in def)) {
        throw new Error('$data keyword must have "code" or "validate" function');
      }
    }
    function addRule(keyword, definition, dataType) {
      var _a;
      const post = definition === null || definition === void 0 ? void 0 : definition.post;
      if (dataType && post)
        throw new Error('keyword with "post" flag cannot have "type"');
      const { RULES } = this;
      let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);
      if (!ruleGroup) {
        ruleGroup = { type: dataType, rules: [] };
        RULES.rules.push(ruleGroup);
      }
      RULES.keywords[keyword] = true;
      if (!definition)
        return;
      const rule = {
        keyword,
        definition: {
          ...definition,
          type: (0, dataType_1.getJSONTypes)(definition.type),
          schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
        }
      };
      if (definition.before)
        addBeforeRule.call(this, ruleGroup, rule, definition.before);
      else
        ruleGroup.rules.push(rule);
      RULES.all[keyword] = rule;
      (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));
    }
    function addBeforeRule(ruleGroup, rule, before) {
      const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
      if (i >= 0) {
        ruleGroup.rules.splice(i, 0, rule);
      } else {
        ruleGroup.rules.push(rule);
        this.logger.warn(`rule ${before} is not defined`);
      }
    }
    function keywordMetaschema(def) {
      let { metaSchema } = def;
      if (metaSchema === void 0)
        return;
      if (def.$data && this.opts.$data)
        metaSchema = schemaOrData(metaSchema);
      def.validateSchema = this.compile(metaSchema, true);
    }
    var $dataRef = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
    };
    function schemaOrData(schema) {
      return { anyOf: [schema, $dataRef] };
    }
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/core/id.js
var require_id2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/core/id.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var def = {
      keyword: "id",
      code() {
        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/core/ref.js
var require_ref2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/core/ref.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.callRef = exports2.getValidate = void 0;
    var ref_error_1 = require_ref_error2();
    var code_1 = require_code4();
    var codegen_1 = require_codegen2();
    var names_1 = require_names2();
    var compile_1 = require_compile2();
    var util_1 = require_util2();
    var def = {
      keyword: "$ref",
      schemaType: "string",
      code(cxt) {
        const { gen, schema: $ref, it } = cxt;
        const { baseId, schemaEnv: env, validateName, opts, self: self2 } = it;
        const { root } = env;
        if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
          return callRootRef();
        const schOrEnv = compile_1.resolveRef.call(self2, root, baseId, $ref);
        if (schOrEnv === void 0)
          throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
        if (schOrEnv instanceof compile_1.SchemaEnv)
          return callValidate(schOrEnv);
        return inlineRefSchema(schOrEnv);
        function callRootRef() {
          if (env === root)
            return callRef(cxt, validateName, env, env.$async);
          const rootName = gen.scopeValue("root", { ref: root });
          return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);
        }
        function callValidate(sch) {
          const v = getValidate(cxt, sch);
          callRef(cxt, v, sch, sch.$async);
        }
        function inlineRefSchema(sch) {
          const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });
          const valid = gen.name("valid");
          const schCxt = cxt.subschema({
            schema: sch,
            dataTypes: [],
            schemaPath: codegen_1.nil,
            topSchemaRef: schName,
            errSchemaPath: $ref
          }, valid);
          cxt.mergeEvaluated(schCxt);
          cxt.ok(valid);
        }
      }
    };
    function getValidate(cxt, sch) {
      const { gen } = cxt;
      return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
    }
    exports2.getValidate = getValidate;
    function callRef(cxt, v, sch, $async) {
      const { gen, it } = cxt;
      const { allErrors, schemaEnv: env, opts } = it;
      const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
      if ($async)
        callAsyncRef();
      else
        callSyncRef();
      function callAsyncRef() {
        if (!env.$async)
          throw new Error("async schema referenced by sync schema");
        const valid = gen.let("valid");
        gen.try(() => {
          gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);
          addEvaluatedFrom(v);
          if (!allErrors)
            gen.assign(valid, true);
        }, (e) => {
          gen.if((0, codegen_1._)`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
          addErrorsFrom(e);
          if (!allErrors)
            gen.assign(valid, false);
        });
        cxt.ok(valid);
      }
      function callSyncRef() {
        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
      }
      function addErrorsFrom(source) {
        const errs = (0, codegen_1._)`${source}.errors`;
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`);
        gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
      }
      function addEvaluatedFrom(source) {
        var _a;
        if (!it.opts.unevaluated)
          return;
        const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
        if (it.props !== true) {
          if (schEvaluated && !schEvaluated.dynamicProps) {
            if (schEvaluated.props !== void 0) {
              it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);
            }
          } else {
            const props = gen.var("props", (0, codegen_1._)`${source}.evaluated.props`);
            it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
          }
        }
        if (it.items !== true) {
          if (schEvaluated && !schEvaluated.dynamicItems) {
            if (schEvaluated.items !== void 0) {
              it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);
            }
          } else {
            const items = gen.var("items", (0, codegen_1._)`${source}.evaluated.items`);
            it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);
          }
        }
      }
    }
    exports2.callRef = callRef;
    exports2.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/core/index.js
var require_core4 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/core/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var id_1 = require_id2();
    var ref_1 = require_ref2();
    var core = [
      "$schema",
      "$id",
      "$defs",
      "$vocabulary",
      { keyword: "$comment" },
      "definitions",
      id_1.default,
      ref_1.default
    ];
    exports2.default = core;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/limitNumber.js
var require_limitNumber2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/limitNumber.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen2();
    var ops = codegen_1.operators;
    var KWDs = {
      maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    };
    var error = {
      message: ({ keyword, schemaCode }) => (0, codegen_1.str)`must be ${KWDs[keyword].okStr} ${schemaCode}`,
      params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
    };
    var def = {
      keyword: Object.keys(KWDs),
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        cxt.fail$data((0, codegen_1._)`${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/multipleOf.js
var require_multipleOf2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/multipleOf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen2();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must be multiple of ${schemaCode}`,
      params: ({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`
    };
    var def = {
      keyword: "multipleOf",
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, schemaCode, it } = cxt;
        const prec = it.opts.multipleOfPrecision;
        const res = gen.let("res");
        const invalid = prec ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1._)`${res} !== parseInt(${res})`;
        cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/runtime/ucs2length.js
var require_ucs2length2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/runtime/ucs2length.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function ucs2length(str) {
      const len = str.length;
      let length = 0;
      let pos = 0;
      let value;
      while (pos < len) {
        length++;
        value = str.charCodeAt(pos++);
        if (value >= 55296 && value <= 56319 && pos < len) {
          value = str.charCodeAt(pos);
          if ((value & 64512) === 56320)
            pos++;
        }
      }
      return length;
    }
    exports2.default = ucs2length;
    ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/limitLength.js
var require_limitLength2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/limitLength.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen2();
    var util_1 = require_util2();
    var ucs2length_1 = require_ucs2length2();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxLength" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxLength", "minLength"],
      type: "string",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode, it } = cxt;
        const op = keyword === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
        const len = it.opts.unicode === false ? (0, codegen_1._)`${data}.length` : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
        cxt.fail$data((0, codegen_1._)`${len} ${op} ${schemaCode}`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/pattern.js
var require_pattern2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/pattern.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code4();
    var codegen_1 = require_codegen2();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match pattern "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`
    };
    var def = {
      keyword: "pattern",
      type: "string",
      schemaType: "string",
      $data: true,
      error,
      code(cxt) {
        const { data, $data, schema, schemaCode, it } = cxt;
        const u = it.opts.unicodeRegExp ? "u" : "";
        const regExp = $data ? (0, codegen_1._)`(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);
        cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data})`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/limitProperties.js
var require_limitProperties2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/limitProperties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen2();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxProperties" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxProperties", "minProperties"],
      type: "object",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`Object.keys(${data}).length ${op} ${schemaCode}`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/required.js
var require_required2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/required.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code4();
    var codegen_1 = require_codegen2();
    var util_1 = require_util2();
    var error = {
      message: ({ params: { missingProperty } }) => (0, codegen_1.str)`must have required property '${missingProperty}'`,
      params: ({ params: { missingProperty } }) => (0, codegen_1._)`{missingProperty: ${missingProperty}}`
    };
    var def = {
      keyword: "required",
      type: "object",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, schema, schemaCode, data, $data, it } = cxt;
        const { opts } = it;
        if (!$data && schema.length === 0)
          return;
        const useLoop = schema.length >= opts.loopRequired;
        if (it.allErrors)
          allErrorsMode();
        else
          exitOnErrorMode();
        if (opts.strictRequired) {
          const props = cxt.parentSchema.properties;
          const { definedProperties } = cxt.it;
          for (const requiredKey of schema) {
            if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
              const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
              const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
              (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
            }
          }
        }
        function allErrorsMode() {
          if (useLoop || $data) {
            cxt.block$data(codegen_1.nil, loopAllRequired);
          } else {
            for (const prop of schema) {
              (0, code_1.checkReportMissingProp)(cxt, prop);
            }
          }
        }
        function exitOnErrorMode() {
          const missing = gen.let("missing");
          if (useLoop || $data) {
            const valid = gen.let("valid", true);
            cxt.block$data(valid, () => loopUntilMissing(missing, valid));
            cxt.ok(valid);
          } else {
            gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));
            (0, code_1.reportMissingProp)(cxt, missing);
            gen.else();
          }
        }
        function loopAllRequired() {
          gen.forOf("prop", schemaCode, (prop) => {
            cxt.setParams({ missingProperty: prop });
            gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
          });
        }
        function loopUntilMissing(missing, valid) {
          cxt.setParams({ missingProperty: missing });
          gen.forOf(missing, schemaCode, () => {
            gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));
            gen.if((0, codegen_1.not)(valid), () => {
              cxt.error();
              gen.break();
            });
          }, codegen_1.nil);
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/limitItems.js
var require_limitItems2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/limitItems.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen2();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxItems" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxItems", "minItems"],
      type: "array",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`${data}.length ${op} ${schemaCode}`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/runtime/equal.js
var require_equal2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/runtime/equal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var equal = require_fast_deep_equal();
    equal.code = 'require("ajv/dist/runtime/equal").default';
    exports2.default = equal;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js
var require_uniqueItems2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var dataType_1 = require_dataType2();
    var codegen_1 = require_codegen2();
    var util_1 = require_util2();
    var equal_1 = require_equal2();
    var error = {
      message: ({ params: { i, j } }) => (0, codegen_1.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
      params: ({ params: { i, j } }) => (0, codegen_1._)`{i: ${i}, j: ${j}}`
    };
    var def = {
      keyword: "uniqueItems",
      type: "array",
      schemaType: "boolean",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
        if (!$data && !schema)
          return;
        const valid = gen.let("valid");
        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`);
        cxt.ok(valid);
        function validateUniqueItems() {
          const i = gen.let("i", (0, codegen_1._)`${data}.length`);
          const j = gen.let("j");
          cxt.setParams({ i, j });
          gen.assign(valid, true);
          gen.if((0, codegen_1._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
        }
        function canOptimize() {
          return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
        }
        function loopN(i, j) {
          const item = gen.name("item");
          const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
          const indices = gen.const("indices", (0, codegen_1._)`{}`);
          gen.for((0, codegen_1._)`;${i}--;`, () => {
            gen.let(item, (0, codegen_1._)`${data}[${i}]`);
            gen.if(wrongType, (0, codegen_1._)`continue`);
            if (itemTypes.length > 1)
              gen.if((0, codegen_1._)`typeof ${item} == "string"`, (0, codegen_1._)`${item} += "_"`);
            gen.if((0, codegen_1._)`typeof ${indices}[${item}] == "number"`, () => {
              gen.assign(j, (0, codegen_1._)`${indices}[${item}]`);
              cxt.error();
              gen.assign(valid, false).break();
            }).code((0, codegen_1._)`${indices}[${item}] = ${i}`);
          });
        }
        function loopN2(i, j) {
          const eql = (0, util_1.useFunc)(gen, equal_1.default);
          const outer = gen.name("outer");
          gen.label(outer).for((0, codegen_1._)`;${i}--;`, () => gen.for((0, codegen_1._)`${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._)`${eql}(${data}[${i}], ${data}[${j}])`, () => {
            cxt.error();
            gen.assign(valid, false).break(outer);
          })));
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/const.js
var require_const2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/const.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen2();
    var util_1 = require_util2();
    var equal_1 = require_equal2();
    var error = {
      message: "must be equal to constant",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValue: ${schemaCode}}`
    };
    var def = {
      keyword: "const",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schemaCode, schema } = cxt;
        if ($data || schema && typeof schema == "object") {
          cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);
        } else {
          cxt.fail((0, codegen_1._)`${schema} !== ${data}`);
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/enum.js
var require_enum2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/enum.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen2();
    var util_1 = require_util2();
    var equal_1 = require_equal2();
    var error = {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
    };
    var def = {
      keyword: "enum",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        if (!$data && schema.length === 0)
          throw new Error("enum must have non-empty array");
        const useLoop = schema.length >= it.opts.loopEnum;
        let eql;
        const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1.useFunc)(gen, equal_1.default);
        let valid;
        if (useLoop || $data) {
          valid = gen.let("valid");
          cxt.block$data(valid, loopEnum);
        } else {
          if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
          const vSchema = gen.const("vSchema", schemaCode);
          valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
        }
        cxt.pass(valid);
        function loopEnum() {
          gen.assign(valid, false);
          gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));
        }
        function equalCode(vSchema, i) {
          const sch = schema[i];
          return typeof sch === "object" && sch !== null ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1._)`${data} === ${sch}`;
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/index.js
var require_validation2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var limitNumber_1 = require_limitNumber2();
    var multipleOf_1 = require_multipleOf2();
    var limitLength_1 = require_limitLength2();
    var pattern_1 = require_pattern2();
    var limitProperties_1 = require_limitProperties2();
    var required_1 = require_required2();
    var limitItems_1 = require_limitItems2();
    var uniqueItems_1 = require_uniqueItems2();
    var const_1 = require_const2();
    var enum_1 = require_enum2();
    var validation = [
      // number
      limitNumber_1.default,
      multipleOf_1.default,
      // string
      limitLength_1.default,
      pattern_1.default,
      // object
      limitProperties_1.default,
      required_1.default,
      // array
      limitItems_1.default,
      uniqueItems_1.default,
      // any
      { keyword: "type", schemaType: ["string", "array"] },
      { keyword: "nullable", schemaType: "boolean" },
      const_1.default,
      enum_1.default
    ];
    exports2.default = validation;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js
var require_additionalItems2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateAdditionalItems = void 0;
    var codegen_1 = require_codegen2();
    var util_1 = require_util2();
    var error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "additionalItems",
      type: "array",
      schemaType: ["boolean", "object"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { parentSchema, it } = cxt;
        const { items } = parentSchema;
        if (!Array.isArray(items)) {
          (0, util_1.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
          return;
        }
        validateAdditionalItems(cxt, items);
      }
    };
    function validateAdditionalItems(cxt, items) {
      const { gen, schema, data, keyword, it } = cxt;
      it.items = true;
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      if (schema === false) {
        cxt.setParams({ len: items.length });
        cxt.pass((0, codegen_1._)`${len} <= ${items.length}`);
      } else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
        const valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items.length}`);
        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));
        cxt.ok(valid);
      }
      function validateItems(valid) {
        gen.forRange("i", items.length, len, (i) => {
          cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);
          if (!it.allErrors)
            gen.if((0, codegen_1.not)(valid), () => gen.break());
        });
      }
    }
    exports2.validateAdditionalItems = validateAdditionalItems;
    exports2.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/items.js
var require_items2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/items.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateTuple = void 0;
    var codegen_1 = require_codegen2();
    var util_1 = require_util2();
    var code_1 = require_code4();
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "array", "boolean"],
      before: "uniqueItems",
      code(cxt) {
        const { schema, it } = cxt;
        if (Array.isArray(schema))
          return validateTuple(cxt, "additionalItems", schema);
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    function validateTuple(cxt, extraItems, schArr = cxt.schema) {
      const { gen, parentSchema, data, keyword, it } = cxt;
      checkStrictTuple(parentSchema);
      if (it.opts.unevaluated && schArr.length && it.items !== true) {
        it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);
      }
      const valid = gen.name("valid");
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      schArr.forEach((sch, i) => {
        if ((0, util_1.alwaysValidSchema)(it, sch))
          return;
        gen.if((0, codegen_1._)`${len} > ${i}`, () => cxt.subschema({
          keyword,
          schemaProp: i,
          dataProp: i
        }, valid));
        cxt.ok(valid);
      });
      function checkStrictTuple(sch) {
        const { opts, errSchemaPath } = it;
        const l = schArr.length;
        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
        if (opts.strictTuples && !fullTuple) {
          const msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
          (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);
        }
      }
    }
    exports2.validateTuple = validateTuple;
    exports2.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js
var require_prefixItems2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var items_1 = require_items2();
    var def = {
      keyword: "prefixItems",
      type: "array",
      schemaType: ["array"],
      before: "uniqueItems",
      code: (cxt) => (0, items_1.validateTuple)(cxt, "items")
    };
    exports2.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/items2020.js
var require_items20202 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/items2020.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen2();
    var util_1 = require_util2();
    var code_1 = require_code4();
    var additionalItems_1 = require_additionalItems2();
    var error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { schema, parentSchema, it } = cxt;
        const { prefixItems } = parentSchema;
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        if (prefixItems)
          (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);
        else
          cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/contains.js
var require_contains2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/contains.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen2();
    var util_1 = require_util2();
    var error = {
      message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1.str)`must contain at least ${min} valid item(s)` : (0, codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
      params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1._)`{minContains: ${min}}` : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`
    };
    var def = {
      keyword: "contains",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        let min;
        let max;
        const { minContains, maxContains } = parentSchema;
        if (it.opts.next) {
          min = minContains === void 0 ? 1 : minContains;
          max = maxContains;
        } else {
          min = 1;
        }
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        cxt.setParams({ min, max });
        if (max === void 0 && min === 0) {
          (0, util_1.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
          return;
        }
        if (max !== void 0 && min > max) {
          (0, util_1.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
          cxt.fail();
          return;
        }
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          let cond = (0, codegen_1._)`${len} >= ${min}`;
          if (max !== void 0)
            cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`;
          cxt.pass(cond);
          return;
        }
        it.items = true;
        const valid = gen.name("valid");
        if (max === void 0 && min === 1) {
          validateItems(valid, () => gen.if(valid, () => gen.break()));
        } else if (min === 0) {
          gen.let(valid, true);
          if (max !== void 0)
            gen.if((0, codegen_1._)`${data}.length > 0`, validateItemsWithCount);
        } else {
          gen.let(valid, false);
          validateItemsWithCount();
        }
        cxt.result(valid, () => cxt.reset());
        function validateItemsWithCount() {
          const schValid = gen.name("_valid");
          const count = gen.let("count", 0);
          validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
        }
        function validateItems(_valid, block) {
          gen.forRange("i", 0, len, (i) => {
            cxt.subschema({
              keyword: "contains",
              dataProp: i,
              dataPropType: util_1.Type.Num,
              compositeRule: true
            }, _valid);
            block();
          });
        }
        function checkLimits(count) {
          gen.code((0, codegen_1._)`${count}++`);
          if (max === void 0) {
            gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true).break());
          } else {
            gen.if((0, codegen_1._)`${count} > ${max}`, () => gen.assign(valid, false).break());
            if (min === 1)
              gen.assign(valid, true);
            else
              gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true));
          }
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/dependencies.js
var require_dependencies2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/dependencies.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateSchemaDeps = exports2.validatePropertyDeps = exports2.error = void 0;
    var codegen_1 = require_codegen2();
    var util_1 = require_util2();
    var code_1 = require_code4();
    exports2.error = {
      message: ({ params: { property, depsCount, deps } }) => {
        const property_ies = depsCount === 1 ? "property" : "properties";
        return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;
      },
      params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
      // TODO change to reference
    };
    var def = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: exports2.error,
      code(cxt) {
        const [propDeps, schDeps] = splitDependencies(cxt);
        validatePropertyDeps(cxt, propDeps);
        validateSchemaDeps(cxt, schDeps);
      }
    };
    function splitDependencies({ schema }) {
      const propertyDeps = {};
      const schemaDeps = {};
      for (const key in schema) {
        if (key === "__proto__")
          continue;
        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
        deps[key] = schema[key];
      }
      return [propertyDeps, schemaDeps];
    }
    function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
      const { gen, data, it } = cxt;
      if (Object.keys(propertyDeps).length === 0)
        return;
      const missing = gen.let("missing");
      for (const prop in propertyDeps) {
        const deps = propertyDeps[prop];
        if (deps.length === 0)
          continue;
        const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);
        cxt.setParams({
          property: prop,
          depsCount: deps.length,
          deps: deps.join(", ")
        });
        if (it.allErrors) {
          gen.if(hasProperty, () => {
            for (const depProp of deps) {
              (0, code_1.checkReportMissingProp)(cxt, depProp);
            }
          });
        } else {
          gen.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
          (0, code_1.reportMissingProp)(cxt, missing);
          gen.else();
        }
      }
    }
    exports2.validatePropertyDeps = validatePropertyDeps;
    function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
      const { gen, data, keyword, it } = cxt;
      const valid = gen.name("valid");
      for (const prop in schemaDeps) {
        if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))
          continue;
        gen.if(
          (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties),
          () => {
            const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
            cxt.mergeValidEvaluated(schCxt, valid);
          },
          () => gen.var(valid, true)
          // TODO var
        );
        cxt.ok(valid);
      }
    }
    exports2.validateSchemaDeps = validateSchemaDeps;
    exports2.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js
var require_propertyNames2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen2();
    var util_1 = require_util2();
    var error = {
      message: "property name must be valid",
      params: ({ params }) => (0, codegen_1._)`{propertyName: ${params.propertyName}}`
    };
    var def = {
      keyword: "propertyNames",
      type: "object",
      schemaType: ["object", "boolean"],
      error,
      code(cxt) {
        const { gen, schema, data, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        const valid = gen.name("valid");
        gen.forIn("key", data, (key) => {
          cxt.setParams({ propertyName: key });
          cxt.subschema({
            keyword: "propertyNames",
            data: key,
            dataTypes: ["string"],
            propertyName: key,
            compositeRule: true
          }, valid);
          gen.if((0, codegen_1.not)(valid), () => {
            cxt.error(true);
            if (!it.allErrors)
              gen.break();
          });
        });
        cxt.ok(valid);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js
var require_additionalProperties2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code4();
    var codegen_1 = require_codegen2();
    var names_1 = require_names2();
    var util_1 = require_util2();
    var error = {
      message: "must NOT have additional properties",
      params: ({ params }) => (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`
    };
    var def = {
      keyword: "additionalProperties",
      type: ["object"],
      schemaType: ["boolean", "object"],
      allowUndefined: true,
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, data, errsCount, it } = cxt;
        if (!errsCount)
          throw new Error("ajv implementation error");
        const { allErrors, opts } = it;
        it.props = true;
        if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it, schema))
          return;
        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
        const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
        checkAdditionalProperties();
        cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
        function checkAdditionalProperties() {
          gen.forIn("key", data, (key) => {
            if (!props.length && !patProps.length)
              additionalPropertyCode(key);
            else
              gen.if(isAdditional(key), () => additionalPropertyCode(key));
          });
        }
        function isAdditional(key) {
          let definedProp;
          if (props.length > 8) {
            const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");
            definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
          } else if (props.length) {
            definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._)`${key} === ${p}`));
          } else {
            definedProp = codegen_1.nil;
          }
          if (patProps.length) {
            definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p)}.test(${key})`));
          }
          return (0, codegen_1.not)(definedProp);
        }
        function deleteAdditional(key) {
          gen.code((0, codegen_1._)`delete ${data}[${key}]`);
        }
        function additionalPropertyCode(key) {
          if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
            deleteAdditional(key);
            return;
          }
          if (schema === false) {
            cxt.setParams({ additionalProperty: key });
            cxt.error();
            if (!allErrors)
              gen.break();
            return;
          }
          if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
            const valid = gen.name("valid");
            if (opts.removeAdditional === "failing") {
              applyAdditionalSchema(key, valid, false);
              gen.if((0, codegen_1.not)(valid), () => {
                cxt.reset();
                deleteAdditional(key);
              });
            } else {
              applyAdditionalSchema(key, valid);
              if (!allErrors)
                gen.if((0, codegen_1.not)(valid), () => gen.break());
            }
          }
        }
        function applyAdditionalSchema(key, valid, errors) {
          const subschema = {
            keyword: "additionalProperties",
            dataProp: key,
            dataPropType: util_1.Type.Str
          };
          if (errors === false) {
            Object.assign(subschema, {
              compositeRule: true,
              createErrors: false,
              allErrors: false
            });
          }
          cxt.subschema(subschema, valid);
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/properties.js
var require_properties2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/properties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var validate_1 = require_validate2();
    var code_1 = require_code4();
    var util_1 = require_util2();
    var additionalProperties_1 = require_additionalProperties2();
    var def = {
      keyword: "properties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
          additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, "additionalProperties"));
        }
        const allProps = (0, code_1.allSchemaProperties)(schema);
        for (const prop of allProps) {
          it.definedProperties.add(prop);
        }
        if (it.opts.unevaluated && allProps.length && it.props !== true) {
          it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);
        }
        const properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));
        if (properties.length === 0)
          return;
        const valid = gen.name("valid");
        for (const prop of properties) {
          if (hasDefault(prop)) {
            applyPropertySchema(prop);
          } else {
            gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));
            applyPropertySchema(prop);
            if (!it.allErrors)
              gen.else().var(valid, true);
            gen.endIf();
          }
          cxt.it.definedProperties.add(prop);
          cxt.ok(valid);
        }
        function hasDefault(prop) {
          return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== void 0;
        }
        function applyPropertySchema(prop) {
          cxt.subschema({
            keyword: "properties",
            schemaProp: prop,
            dataProp: prop
          }, valid);
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js
var require_patternProperties2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code4();
    var codegen_1 = require_codegen2();
    var util_1 = require_util2();
    var util_2 = require_util2();
    var def = {
      keyword: "patternProperties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, data, parentSchema, it } = cxt;
        const { opts } = it;
        const patterns = (0, code_1.allSchemaProperties)(schema);
        const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));
        if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {
          return;
        }
        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
        const valid = gen.name("valid");
        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {
          it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
        }
        const { props } = it;
        validatePatternProperties();
        function validatePatternProperties() {
          for (const pat of patterns) {
            if (checkProperties)
              checkMatchingProperties(pat);
            if (it.allErrors) {
              validateProperties(pat);
            } else {
              gen.var(valid, true);
              validateProperties(pat);
              gen.if(valid);
            }
          }
        }
        function checkMatchingProperties(pat) {
          for (const prop in checkProperties) {
            if (new RegExp(pat).test(prop)) {
              (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
            }
          }
        }
        function validateProperties(pat) {
          gen.forIn("key", data, (key) => {
            gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
              const alwaysValid = alwaysValidPatterns.includes(pat);
              if (!alwaysValid) {
                cxt.subschema({
                  keyword: "patternProperties",
                  schemaProp: pat,
                  dataProp: key,
                  dataPropType: util_2.Type.Str
                }, valid);
              }
              if (it.opts.unevaluated && props !== true) {
                gen.assign((0, codegen_1._)`${props}[${key}]`, true);
              } else if (!alwaysValid && !it.allErrors) {
                gen.if((0, codegen_1.not)(valid), () => gen.break());
              }
            });
          });
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/not.js
var require_not2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/not.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require_util2();
    var def = {
      keyword: "not",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      code(cxt) {
        const { gen, schema, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          cxt.fail();
          return;
        }
        const valid = gen.name("valid");
        cxt.subschema({
          keyword: "not",
          compositeRule: true,
          createErrors: false,
          allErrors: false
        }, valid);
        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
      },
      error: { message: "must NOT be valid" }
    };
    exports2.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/anyOf.js
var require_anyOf2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/anyOf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code4();
    var def = {
      keyword: "anyOf",
      schemaType: "array",
      trackErrors: true,
      code: code_1.validateUnion,
      error: { message: "must match a schema in anyOf" }
    };
    exports2.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/oneOf.js
var require_oneOf2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/oneOf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen2();
    var util_1 = require_util2();
    var error = {
      message: "must match exactly one schema in oneOf",
      params: ({ params }) => (0, codegen_1._)`{passingSchemas: ${params.passing}}`
    };
    var def = {
      keyword: "oneOf",
      schemaType: "array",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        if (it.opts.discriminator && parentSchema.discriminator)
          return;
        const schArr = schema;
        const valid = gen.let("valid", false);
        const passing = gen.let("passing", null);
        const schValid = gen.name("_valid");
        cxt.setParams({ passing });
        gen.block(validateOneOf);
        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
        function validateOneOf() {
          schArr.forEach((sch, i) => {
            let schCxt;
            if ((0, util_1.alwaysValidSchema)(it, sch)) {
              gen.var(schValid, true);
            } else {
              schCxt = cxt.subschema({
                keyword: "oneOf",
                schemaProp: i,
                compositeRule: true
              }, schValid);
            }
            if (i > 0) {
              gen.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1._)`[${passing}, ${i}]`).else();
            }
            gen.if(schValid, () => {
              gen.assign(valid, true);
              gen.assign(passing, i);
              if (schCxt)
                cxt.mergeEvaluated(schCxt, codegen_1.Name);
            });
          });
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/allOf.js
var require_allOf2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/allOf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require_util2();
    var def = {
      keyword: "allOf",
      schemaType: "array",
      code(cxt) {
        const { gen, schema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        const valid = gen.name("valid");
        schema.forEach((sch, i) => {
          if ((0, util_1.alwaysValidSchema)(it, sch))
            return;
          const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
          cxt.ok(valid);
          cxt.mergeEvaluated(schCxt);
        });
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/if.js
var require_if2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/if.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen2();
    var util_1 = require_util2();
    var error = {
      message: ({ params }) => (0, codegen_1.str)`must match "${params.ifClause}" schema`,
      params: ({ params }) => (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`
    };
    var def = {
      keyword: "if",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, parentSchema, it } = cxt;
        if (parentSchema.then === void 0 && parentSchema.else === void 0) {
          (0, util_1.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
        }
        const hasThen = hasSchema(it, "then");
        const hasElse = hasSchema(it, "else");
        if (!hasThen && !hasElse)
          return;
        const valid = gen.let("valid", true);
        const schValid = gen.name("_valid");
        validateIf();
        cxt.reset();
        if (hasThen && hasElse) {
          const ifClause = gen.let("ifClause");
          cxt.setParams({ ifClause });
          gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
        } else if (hasThen) {
          gen.if(schValid, validateClause("then"));
        } else {
          gen.if((0, codegen_1.not)(schValid), validateClause("else"));
        }
        cxt.pass(valid, () => cxt.error(true));
        function validateIf() {
          const schCxt = cxt.subschema({
            keyword: "if",
            compositeRule: true,
            createErrors: false,
            allErrors: false
          }, schValid);
          cxt.mergeEvaluated(schCxt);
        }
        function validateClause(keyword, ifClause) {
          return () => {
            const schCxt = cxt.subschema({ keyword }, schValid);
            gen.assign(valid, schValid);
            cxt.mergeValidEvaluated(schCxt, valid);
            if (ifClause)
              gen.assign(ifClause, (0, codegen_1._)`${keyword}`);
            else
              cxt.setParams({ ifClause: keyword });
          };
        }
      }
    };
    function hasSchema(it, keyword) {
      const schema = it.schema[keyword];
      return schema !== void 0 && !(0, util_1.alwaysValidSchema)(it, schema);
    }
    exports2.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/thenElse.js
var require_thenElse2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/thenElse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require_util2();
    var def = {
      keyword: ["then", "else"],
      schemaType: ["object", "boolean"],
      code({ keyword, parentSchema, it }) {
        if (parentSchema.if === void 0)
          (0, util_1.checkStrictMode)(it, `"${keyword}" without "if" is ignored`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/index.js
var require_applicator2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var additionalItems_1 = require_additionalItems2();
    var prefixItems_1 = require_prefixItems2();
    var items_1 = require_items2();
    var items2020_1 = require_items20202();
    var contains_1 = require_contains2();
    var dependencies_1 = require_dependencies2();
    var propertyNames_1 = require_propertyNames2();
    var additionalProperties_1 = require_additionalProperties2();
    var properties_1 = require_properties2();
    var patternProperties_1 = require_patternProperties2();
    var not_1 = require_not2();
    var anyOf_1 = require_anyOf2();
    var oneOf_1 = require_oneOf2();
    var allOf_1 = require_allOf2();
    var if_1 = require_if2();
    var thenElse_1 = require_thenElse2();
    function getApplicator(draft2020 = false) {
      const applicator = [
        // any
        not_1.default,
        anyOf_1.default,
        oneOf_1.default,
        allOf_1.default,
        if_1.default,
        thenElse_1.default,
        // object
        propertyNames_1.default,
        additionalProperties_1.default,
        dependencies_1.default,
        properties_1.default,
        patternProperties_1.default
      ];
      if (draft2020)
        applicator.push(prefixItems_1.default, items2020_1.default);
      else
        applicator.push(additionalItems_1.default, items_1.default);
      applicator.push(contains_1.default);
      return applicator;
    }
    exports2.default = getApplicator;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/format/format.js
var require_format4 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/format/format.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen2();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match format "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`
    };
    var def = {
      keyword: "format",
      type: ["number", "string"],
      schemaType: "string",
      $data: true,
      error,
      code(cxt, ruleType) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        const { opts, errSchemaPath, schemaEnv, self: self2 } = it;
        if (!opts.validateFormats)
          return;
        if ($data)
          validate$DataFormat();
        else
          validateFormat();
        function validate$DataFormat() {
          const fmts = gen.scopeValue("formats", {
            ref: self2.formats,
            code: opts.code.formats
          });
          const fDef = gen.const("fDef", (0, codegen_1._)`${fmts}[${schemaCode}]`);
          const fType = gen.let("fType");
          const format = gen.let("format");
          gen.if((0, codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._)`${fDef}.type || "string"`).assign(format, (0, codegen_1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._)`"string"`).assign(format, fDef));
          cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
          function unknownFmt() {
            if (opts.strictSchema === false)
              return codegen_1.nil;
            return (0, codegen_1._)`${schemaCode} && !${format}`;
          }
          function invalidFmt() {
            const callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))` : (0, codegen_1._)`${format}(${data})`;
            const validData = (0, codegen_1._)`(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`;
            return (0, codegen_1._)`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;
          }
        }
        function validateFormat() {
          const formatDef = self2.formats[schema];
          if (!formatDef) {
            unknownFormat();
            return;
          }
          if (formatDef === true)
            return;
          const [fmtType, format, fmtRef] = getFormat(formatDef);
          if (fmtType === ruleType)
            cxt.pass(validCondition());
          function unknownFormat() {
            if (opts.strictSchema === false) {
              self2.logger.warn(unknownMsg());
              return;
            }
            throw new Error(unknownMsg());
            function unknownMsg() {
              return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
            }
          }
          function getFormat(fmtDef) {
            const code = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}` : void 0;
            const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code });
            if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
              return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`];
            }
            return ["string", fmtDef, fmt];
          }
          function validCondition() {
            if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
              if (!schemaEnv.$async)
                throw new Error("async format in sync schema");
              return (0, codegen_1._)`await ${fmtRef}(${data})`;
            }
            return typeof format == "function" ? (0, codegen_1._)`${fmtRef}(${data})` : (0, codegen_1._)`${fmtRef}.test(${data})`;
          }
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/format/index.js
var require_format5 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/format/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var format_1 = require_format4();
    var format = [format_1.default];
    exports2.default = format;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/metadata.js
var require_metadata2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/metadata.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.contentVocabulary = exports2.metadataVocabulary = void 0;
    exports2.metadataVocabulary = [
      "title",
      "description",
      "default",
      "deprecated",
      "readOnly",
      "writeOnly",
      "examples"
    ];
    exports2.contentVocabulary = [
      "contentMediaType",
      "contentEncoding",
      "contentSchema"
    ];
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/draft7.js
var require_draft72 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/draft7.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var core_1 = require_core4();
    var validation_1 = require_validation2();
    var applicator_1 = require_applicator2();
    var format_1 = require_format5();
    var metadata_1 = require_metadata2();
    var draft7Vocabularies = [
      core_1.default,
      validation_1.default,
      (0, applicator_1.default)(),
      format_1.default,
      metadata_1.metadataVocabulary,
      metadata_1.contentVocabulary
    ];
    exports2.default = draft7Vocabularies;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/discriminator/types.js
var require_types2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/discriminator/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DiscrError = void 0;
    var DiscrError;
    (function(DiscrError2) {
      DiscrError2["Tag"] = "tag";
      DiscrError2["Mapping"] = "mapping";
    })(DiscrError || (exports2.DiscrError = DiscrError = {}));
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/discriminator/index.js
var require_discriminator2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/discriminator/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen2();
    var types_1 = require_types2();
    var compile_1 = require_compile2();
    var ref_error_1 = require_ref_error2();
    var util_1 = require_util2();
    var error = {
      message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
      params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
    };
    var def = {
      keyword: "discriminator",
      type: "object",
      schemaType: "object",
      error,
      code(cxt) {
        const { gen, data, schema, parentSchema, it } = cxt;
        const { oneOf } = parentSchema;
        if (!it.opts.discriminator) {
          throw new Error("discriminator: requires discriminator option");
        }
        const tagName = schema.propertyName;
        if (typeof tagName != "string")
          throw new Error("discriminator: requires propertyName");
        if (schema.mapping)
          throw new Error("discriminator: mapping is not supported");
        if (!oneOf)
          throw new Error("discriminator: requires oneOf keyword");
        const valid = gen.let("valid", false);
        const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
        gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
        cxt.ok(valid);
        function validateMapping() {
          const mapping = getMapping();
          gen.if(false);
          for (const tagValue in mapping) {
            gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
            gen.assign(valid, applyTagSchema(mapping[tagValue]));
          }
          gen.else();
          cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
          gen.endIf();
        }
        function applyTagSchema(schemaProp) {
          const _valid = gen.name("valid");
          const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
          cxt.mergeEvaluated(schCxt, codegen_1.Name);
          return _valid;
        }
        function getMapping() {
          var _a;
          const oneOfMapping = {};
          const topRequired = hasRequired(parentSchema);
          let tagRequired = true;
          for (let i = 0; i < oneOf.length; i++) {
            let sch = oneOf[i];
            if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
              const ref = sch.$ref;
              sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref);
              if (sch instanceof compile_1.SchemaEnv)
                sch = sch.schema;
              if (sch === void 0)
                throw new ref_error_1.default(it.opts.uriResolver, it.baseId, ref);
            }
            const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
            if (typeof propSch != "object") {
              throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
            }
            tagRequired = tagRequired && (topRequired || hasRequired(sch));
            addMappings(propSch, i);
          }
          if (!tagRequired)
            throw new Error(`discriminator: "${tagName}" must be required`);
          return oneOfMapping;
          function hasRequired({ required }) {
            return Array.isArray(required) && required.includes(tagName);
          }
          function addMappings(sch, i) {
            if (sch.const) {
              addMapping(sch.const, i);
            } else if (sch.enum) {
              for (const tagValue of sch.enum) {
                addMapping(tagValue, i);
              }
            } else {
              throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
            }
          }
          function addMapping(tagValue, i) {
            if (typeof tagValue != "string" || tagValue in oneOfMapping) {
              throw new Error(`discriminator: "${tagName}" values must be unique strings`);
            }
            oneOfMapping[tagValue] = i;
          }
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/refs/json-schema-draft-07.json
var require_json_schema_draft_072 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/refs/json-schema-draft-07.json"(exports2, module2) {
    module2.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "http://json-schema.org/draft-07/schema#",
      title: "Core schema meta-schema",
      definitions: {
        schemaArray: {
          type: "array",
          minItems: 1,
          items: { $ref: "#" }
        },
        nonNegativeInteger: {
          type: "integer",
          minimum: 0
        },
        nonNegativeIntegerDefault0: {
          allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }]
        },
        simpleTypes: {
          enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
        },
        stringArray: {
          type: "array",
          items: { type: "string" },
          uniqueItems: true,
          default: []
        }
      },
      type: ["object", "boolean"],
      properties: {
        $id: {
          type: "string",
          format: "uri-reference"
        },
        $schema: {
          type: "string",
          format: "uri"
        },
        $ref: {
          type: "string",
          format: "uri-reference"
        },
        $comment: {
          type: "string"
        },
        title: {
          type: "string"
        },
        description: {
          type: "string"
        },
        default: true,
        readOnly: {
          type: "boolean",
          default: false
        },
        examples: {
          type: "array",
          items: true
        },
        multipleOf: {
          type: "number",
          exclusiveMinimum: 0
        },
        maximum: {
          type: "number"
        },
        exclusiveMaximum: {
          type: "number"
        },
        minimum: {
          type: "number"
        },
        exclusiveMinimum: {
          type: "number"
        },
        maxLength: { $ref: "#/definitions/nonNegativeInteger" },
        minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        pattern: {
          type: "string",
          format: "regex"
        },
        additionalItems: { $ref: "#" },
        items: {
          anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
          default: true
        },
        maxItems: { $ref: "#/definitions/nonNegativeInteger" },
        minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        uniqueItems: {
          type: "boolean",
          default: false
        },
        contains: { $ref: "#" },
        maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
        minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        required: { $ref: "#/definitions/stringArray" },
        additionalProperties: { $ref: "#" },
        definitions: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        properties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        patternProperties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          propertyNames: { format: "regex" },
          default: {}
        },
        dependencies: {
          type: "object",
          additionalProperties: {
            anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }]
          }
        },
        propertyNames: { $ref: "#" },
        const: true,
        enum: {
          type: "array",
          items: true,
          minItems: 1,
          uniqueItems: true
        },
        type: {
          anyOf: [
            { $ref: "#/definitions/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/definitions/simpleTypes" },
              minItems: 1,
              uniqueItems: true
            }
          ]
        },
        format: { type: "string" },
        contentMediaType: { type: "string" },
        contentEncoding: { type: "string" },
        if: { $ref: "#" },
        then: { $ref: "#" },
        else: { $ref: "#" },
        allOf: { $ref: "#/definitions/schemaArray" },
        anyOf: { $ref: "#/definitions/schemaArray" },
        oneOf: { $ref: "#/definitions/schemaArray" },
        not: { $ref: "#" }
      },
      default: true
    };
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/ajv.js
var require_ajv2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/ajv.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MissingRefError = exports2.ValidationError = exports2.CodeGen = exports2.Name = exports2.nil = exports2.stringify = exports2.str = exports2._ = exports2.KeywordCxt = exports2.Ajv = void 0;
    var core_1 = require_core3();
    var draft7_1 = require_draft72();
    var discriminator_1 = require_discriminator2();
    var draft7MetaSchema = require_json_schema_draft_072();
    var META_SUPPORT_DATA = ["/properties"];
    var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
    var Ajv = class extends core_1.default {
      _addVocabularies() {
        super._addVocabularies();
        draft7_1.default.forEach((v) => this.addVocabulary(v));
        if (this.opts.discriminator)
          this.addKeyword(discriminator_1.default);
      }
      _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        if (!this.opts.meta)
          return;
        const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
      }
    };
    exports2.Ajv = Ajv;
    module2.exports = exports2 = Ajv;
    module2.exports.Ajv = Ajv;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = Ajv;
    var validate_1 = require_validate2();
    Object.defineProperty(exports2, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen2();
    Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports2, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error2();
    Object.defineProperty(exports2, "ValidationError", { enumerable: true, get: function() {
      return validation_error_1.default;
    } });
    var ref_error_1 = require_ref_error2();
    Object.defineProperty(exports2, "MissingRefError", { enumerable: true, get: function() {
      return ref_error_1.default;
    } });
  }
});

// node_modules/ajv-formats/dist/limit.js
var require_limit = __commonJS({
  "node_modules/ajv-formats/dist/limit.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.formatLimitDefinition = void 0;
    var ajv_1 = require_ajv2();
    var codegen_1 = require_codegen2();
    var ops = codegen_1.operators;
    var KWDs = {
      formatMaximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      formatMinimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      formatExclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      formatExclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    };
    var error = {
      message: ({ keyword, schemaCode }) => codegen_1.str`should be ${KWDs[keyword].okStr} ${schemaCode}`,
      params: ({ keyword, schemaCode }) => codegen_1._`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
    };
    exports2.formatLimitDefinition = {
      keyword: Object.keys(KWDs),
      type: "string",
      schemaType: "string",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, schemaCode, keyword, it } = cxt;
        const { opts, self: self2 } = it;
        if (!opts.validateFormats)
          return;
        const fCxt = new ajv_1.KeywordCxt(it, self2.RULES.all.format.definition, "format");
        if (fCxt.$data)
          validate$DataFormat();
        else
          validateFormat();
        function validate$DataFormat() {
          const fmts = gen.scopeValue("formats", {
            ref: self2.formats,
            code: opts.code.formats
          });
          const fmt = gen.const("fmt", codegen_1._`${fmts}[${fCxt.schemaCode}]`);
          cxt.fail$data(codegen_1.or(codegen_1._`typeof ${fmt} != "object"`, codegen_1._`${fmt} instanceof RegExp`, codegen_1._`typeof ${fmt}.compare != "function"`, compareCode(fmt)));
        }
        function validateFormat() {
          const format = fCxt.schema;
          const fmtDef = self2.formats[format];
          if (!fmtDef || fmtDef === true)
            return;
          if (typeof fmtDef != "object" || fmtDef instanceof RegExp || typeof fmtDef.compare != "function") {
            throw new Error(`"${keyword}": format "${format}" does not define "compare" function`);
          }
          const fmt = gen.scopeValue("formats", {
            key: format,
            ref: fmtDef,
            code: opts.code.formats ? codegen_1._`${opts.code.formats}${codegen_1.getProperty(format)}` : void 0
          });
          cxt.fail$data(compareCode(fmt));
        }
        function compareCode(fmt) {
          return codegen_1._`${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword].fail} 0`;
        }
      },
      dependencies: ["format"]
    };
    var formatLimitPlugin = (ajv) => {
      ajv.addKeyword(exports2.formatLimitDefinition);
      return ajv;
    };
    exports2.default = formatLimitPlugin;
  }
});

// node_modules/ajv-formats/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/ajv-formats/dist/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var formats_1 = require_formats();
    var limit_1 = require_limit();
    var codegen_1 = require_codegen2();
    var fullName = new codegen_1.Name("fullFormats");
    var fastName = new codegen_1.Name("fastFormats");
    var formatsPlugin = (ajv, opts = { keywords: true }) => {
      if (Array.isArray(opts)) {
        addFormats(ajv, opts, formats_1.fullFormats, fullName);
        return ajv;
      }
      const [formats, exportName] = opts.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];
      const list = opts.formats || formats_1.formatNames;
      addFormats(ajv, list, formats, exportName);
      if (opts.keywords)
        limit_1.default(ajv);
      return ajv;
    };
    formatsPlugin.get = (name, mode = "full") => {
      const formats = mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats;
      const f = formats[name];
      if (!f)
        throw new Error(`Unknown format "${name}"`);
      return f;
    };
    function addFormats(ajv, list, fs14, exportName) {
      var _a;
      var _b;
      (_a = (_b = ajv.opts.code).formats) !== null && _a !== void 0 ? _a : _b.formats = codegen_1._`require("ajv-formats/dist/formats").${exportName}`;
      for (const f of list)
        ajv.addFormat(f, fs14[f]);
    }
    module2.exports = exports2 = formatsPlugin;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = formatsPlugin;
  }
});

// node_modules/mimic-fn/index.js
var require_mimic_fn = __commonJS({
  "node_modules/mimic-fn/index.js"(exports2, module2) {
    "use strict";
    var copyProperty = (to, from, property, ignoreNonConfigurable) => {
      if (property === "length" || property === "prototype") {
        return;
      }
      if (property === "arguments" || property === "caller") {
        return;
      }
      const toDescriptor = Object.getOwnPropertyDescriptor(to, property);
      const fromDescriptor = Object.getOwnPropertyDescriptor(from, property);
      if (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {
        return;
      }
      Object.defineProperty(to, property, fromDescriptor);
    };
    var canCopyProperty = function(toDescriptor, fromDescriptor) {
      return toDescriptor === void 0 || toDescriptor.configurable || toDescriptor.writable === fromDescriptor.writable && toDescriptor.enumerable === fromDescriptor.enumerable && toDescriptor.configurable === fromDescriptor.configurable && (toDescriptor.writable || toDescriptor.value === fromDescriptor.value);
    };
    var changePrototype = (to, from) => {
      const fromPrototype = Object.getPrototypeOf(from);
      if (fromPrototype === Object.getPrototypeOf(to)) {
        return;
      }
      Object.setPrototypeOf(to, fromPrototype);
    };
    var wrappedToString = (withName, fromBody) => `/* Wrapped ${withName}*/
${fromBody}`;
    var toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, "toString");
    var toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, "name");
    var changeToString = (to, from, name) => {
      const withName = name === "" ? "" : `with ${name.trim()}() `;
      const newToString = wrappedToString.bind(null, withName, from.toString());
      Object.defineProperty(newToString, "name", toStringName);
      Object.defineProperty(to, "toString", { ...toStringDescriptor, value: newToString });
    };
    var mimicFn = (to, from, { ignoreNonConfigurable = false } = {}) => {
      const { name } = to;
      for (const property of Reflect.ownKeys(from)) {
        copyProperty(to, from, property, ignoreNonConfigurable);
      }
      changePrototype(to, from);
      changeToString(to, from, name);
      return to;
    };
    module2.exports = mimicFn;
  }
});

// node_modules/debounce-fn/index.js
var require_debounce_fn = __commonJS({
  "node_modules/debounce-fn/index.js"(exports2, module2) {
    "use strict";
    var mimicFn = require_mimic_fn();
    module2.exports = (inputFunction, options = {}) => {
      if (typeof inputFunction !== "function") {
        throw new TypeError(`Expected the first argument to be a function, got \`${typeof inputFunction}\``);
      }
      const {
        wait = 0,
        before = false,
        after = true
      } = options;
      if (!before && !after) {
        throw new Error("Both `before` and `after` are false, function wouldn't be called.");
      }
      let timeout;
      let result;
      const debouncedFunction = function(...arguments_) {
        const context = this;
        const later = () => {
          timeout = void 0;
          if (after) {
            result = inputFunction.apply(context, arguments_);
          }
        };
        const shouldCallNow = before && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        if (shouldCallNow) {
          result = inputFunction.apply(context, arguments_);
        }
        return result;
      };
      mimicFn(debouncedFunction, inputFunction);
      debouncedFunction.cancel = () => {
        if (timeout) {
          clearTimeout(timeout);
          timeout = void 0;
        }
      };
      return debouncedFunction;
    };
  }
});

// node_modules/conf/node_modules/semver/internal/constants.js
var require_constants = __commonJS({
  "node_modules/conf/node_modules/semver/internal/constants.js"(exports2, module2) {
    "use strict";
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module2.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// node_modules/conf/node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "node_modules/conf/node_modules/semver/internal/debug.js"(exports2, module2) {
    "use strict";
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module2.exports = debug;
  }
});

// node_modules/conf/node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/conf/node_modules/semver/internal/re.js"(exports2, module2) {
    "use strict";
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants();
    var debug = require_debug();
    exports2 = module2.exports = {};
    var re = exports2.re = [];
    var safeRe = exports2.safeRe = [];
    var src = exports2.src = [];
    var safeSrc = exports2.safeSrc = [];
    var t = exports2.t = {};
    var R = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = (value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    };
    var createToken = (name, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index = R++;
      debug(name, index, value);
      t[name] = index;
      src[index] = value;
      safeSrc[index] = safe;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?(?:${src[t.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("COERCERTLFULL", src[t.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports2.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports2.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports2.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// node_modules/conf/node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/conf/node_modules/semver/internal/parse-options.js"(exports2, module2) {
    "use strict";
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    };
    module2.exports = parseOptions;
  }
});

// node_modules/conf/node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/conf/node_modules/semver/internal/identifiers.js"(exports2, module2) {
    "use strict";
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      if (typeof a === "number" && typeof b === "number") {
        return a === b ? 0 : a < b ? -1 : 1;
      }
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module2.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/conf/node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "node_modules/conf/node_modules/semver/classes/semver.js"(exports2, module2) {
    "use strict";
    var debug = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
    var { safeRe: re, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class _SemVer {
      constructor(version, options) {
        options = parseOptions(options);
        if (version instanceof _SemVer) {
          if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
            return version;
          } else {
            version = version.version;
          }
        } else if (typeof version !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
        }
        if (version.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug("SemVer", version, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version}`);
        }
        this.raw = version;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof _SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new _SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.major < other.major) {
          return -1;
        }
        if (this.major > other.major) {
          return 1;
        }
        if (this.minor < other.minor) {
          return -1;
        }
        if (this.minor > other.minor) {
          return 1;
        }
        if (this.patch < other.patch) {
          return -1;
        }
        if (this.patch > other.patch) {
          return 1;
        }
        return 0;
      }
      comparePre(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug("build compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        if (release.startsWith("pre")) {
          if (!identifier && identifierBase === false) {
            throw new Error("invalid increment argument: identifier is empty");
          }
          if (identifier) {
            const match = `-${identifier}`.match(this.options.loose ? re[t.PRERELEASELOOSE] : re[t.PRERELEASE]);
            if (!match || match[1] !== identifier) {
              throw new Error(`invalid identifier: ${identifier}`);
            }
          }
        }
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          // If the input is a non-prerelease version, this acts the same as
          // prepatch.
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "release":
            if (this.prerelease.length === 0) {
              throw new Error(`version ${this.raw} is not a prerelease`);
            }
            this.prerelease.length = 0;
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          // This probably shouldn't be used publicly.
          // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module2.exports = SemVer;
  }
});

// node_modules/conf/node_modules/semver/functions/parse.js
var require_parse = __commonJS({
  "node_modules/conf/node_modules/semver/functions/parse.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var parse = (version, options, throwErrors = false) => {
      if (version instanceof SemVer) {
        return version;
      }
      try {
        return new SemVer(version, options);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    };
    module2.exports = parse;
  }
});

// node_modules/conf/node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "node_modules/conf/node_modules/semver/functions/valid.js"(exports2, module2) {
    "use strict";
    var parse = require_parse();
    var valid = (version, options) => {
      const v = parse(version, options);
      return v ? v.version : null;
    };
    module2.exports = valid;
  }
});

// node_modules/conf/node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "node_modules/conf/node_modules/semver/functions/clean.js"(exports2, module2) {
    "use strict";
    var parse = require_parse();
    var clean = (version, options) => {
      const s = parse(version.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    };
    module2.exports = clean;
  }
});

// node_modules/conf/node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "node_modules/conf/node_modules/semver/functions/inc.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var inc = (version, release, options, identifier, identifierBase) => {
      if (typeof options === "string") {
        identifierBase = identifier;
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(
          version instanceof SemVer ? version.version : version,
          options
        ).inc(release, identifier, identifierBase).version;
      } catch (er) {
        return null;
      }
    };
    module2.exports = inc;
  }
});

// node_modules/conf/node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "node_modules/conf/node_modules/semver/functions/diff.js"(exports2, module2) {
    "use strict";
    var parse = require_parse();
    var diff = (version1, version2) => {
      const v1 = parse(version1, null, true);
      const v2 = parse(version2, null, true);
      const comparison = v1.compare(v2);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v1 : v2;
      const lowVersion = v1Higher ? v2 : v1;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return "major";
        }
        if (lowVersion.compareMain(highVersion) === 0) {
          if (lowVersion.minor && !lowVersion.patch) {
            return "minor";
          }
          return "patch";
        }
      }
      const prefix = highHasPre ? "pre" : "";
      if (v1.major !== v2.major) {
        return prefix + "major";
      }
      if (v1.minor !== v2.minor) {
        return prefix + "minor";
      }
      if (v1.patch !== v2.patch) {
        return prefix + "patch";
      }
      return "prerelease";
    };
    module2.exports = diff;
  }
});

// node_modules/conf/node_modules/semver/functions/major.js
var require_major = __commonJS({
  "node_modules/conf/node_modules/semver/functions/major.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var major = (a, loose) => new SemVer(a, loose).major;
    module2.exports = major;
  }
});

// node_modules/conf/node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "node_modules/conf/node_modules/semver/functions/minor.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var minor = (a, loose) => new SemVer(a, loose).minor;
    module2.exports = minor;
  }
});

// node_modules/conf/node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "node_modules/conf/node_modules/semver/functions/patch.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var patch = (a, loose) => new SemVer(a, loose).patch;
    module2.exports = patch;
  }
});

// node_modules/conf/node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "node_modules/conf/node_modules/semver/functions/prerelease.js"(exports2, module2) {
    "use strict";
    var parse = require_parse();
    var prerelease = (version, options) => {
      const parsed = parse(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module2.exports = prerelease;
  }
});

// node_modules/conf/node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/conf/node_modules/semver/functions/compare.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module2.exports = compare;
  }
});

// node_modules/conf/node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "node_modules/conf/node_modules/semver/functions/rcompare.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var rcompare = (a, b, loose) => compare(b, a, loose);
    module2.exports = rcompare;
  }
});

// node_modules/conf/node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "node_modules/conf/node_modules/semver/functions/compare-loose.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var compareLoose = (a, b) => compare(a, b, true);
    module2.exports = compareLoose;
  }
});

// node_modules/conf/node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "node_modules/conf/node_modules/semver/functions/compare-build.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var compareBuild = (a, b, loose) => {
      const versionA = new SemVer(a, loose);
      const versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module2.exports = compareBuild;
  }
});

// node_modules/conf/node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "node_modules/conf/node_modules/semver/functions/sort.js"(exports2, module2) {
    "use strict";
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
    module2.exports = sort;
  }
});

// node_modules/conf/node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "node_modules/conf/node_modules/semver/functions/rsort.js"(exports2, module2) {
    "use strict";
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
    module2.exports = rsort;
  }
});

// node_modules/conf/node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/conf/node_modules/semver/functions/gt.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var gt = (a, b, loose) => compare(a, b, loose) > 0;
    module2.exports = gt;
  }
});

// node_modules/conf/node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "node_modules/conf/node_modules/semver/functions/lt.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var lt = (a, b, loose) => compare(a, b, loose) < 0;
    module2.exports = lt;
  }
});

// node_modules/conf/node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/conf/node_modules/semver/functions/eq.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var eq = (a, b, loose) => compare(a, b, loose) === 0;
    module2.exports = eq;
  }
});

// node_modules/conf/node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/conf/node_modules/semver/functions/neq.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var neq = (a, b, loose) => compare(a, b, loose) !== 0;
    module2.exports = neq;
  }
});

// node_modules/conf/node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/conf/node_modules/semver/functions/gte.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var gte = (a, b, loose) => compare(a, b, loose) >= 0;
    module2.exports = gte;
  }
});

// node_modules/conf/node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/conf/node_modules/semver/functions/lte.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var lte = (a, b, loose) => compare(a, b, loose) <= 0;
    module2.exports = lte;
  }
});

// node_modules/conf/node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/conf/node_modules/semver/functions/cmp.js"(exports2, module2) {
    "use strict";
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a === b;
        case "!==":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module2.exports = cmp;
  }
});

// node_modules/conf/node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "node_modules/conf/node_modules/semver/functions/coerce.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var parse = require_parse();
    var { safeRe: re, t } = require_re();
    var coerce = (version, options) => {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version === "number") {
        version = String(version);
      }
      if (typeof version !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
      } else {
        const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
        let next;
        while ((next = coerceRtlRegex.exec(version)) && (!match || match.index + match[0].length !== version.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
        }
        coerceRtlRegex.lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      const major = match[2];
      const minor = match[3] || "0";
      const patch = match[4] || "0";
      const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "";
      const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
      return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options);
    };
    module2.exports = coerce;
  }
});

// node_modules/conf/node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS({
  "node_modules/conf/node_modules/semver/internal/lrucache.js"(exports2, module2) {
    "use strict";
    var LRUCache = class {
      constructor() {
        this.max = 1e3;
        this.map = /* @__PURE__ */ new Map();
      }
      get(key) {
        const value = this.map.get(key);
        if (value === void 0) {
          return void 0;
        } else {
          this.map.delete(key);
          this.map.set(key, value);
          return value;
        }
      }
      delete(key) {
        return this.map.delete(key);
      }
      set(key, value) {
        const deleted = this.delete(key);
        if (!deleted && value !== void 0) {
          if (this.map.size >= this.max) {
            const firstKey = this.map.keys().next().value;
            this.delete(firstKey);
          }
          this.map.set(key, value);
        }
        return this;
      }
    };
    module2.exports = LRUCache;
  }
});

// node_modules/conf/node_modules/semver/classes/range.js
var require_range = __commonJS({
  "node_modules/conf/node_modules/semver/classes/range.js"(exports2, module2) {
    "use strict";
    var SPACE_CHARACTERS = /\s+/g;
    var Range = class _Range {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof _Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new _Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.formatted = void 0;
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range.trim().replace(SPACE_CHARACTERS, " ");
        this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.formatted = void 0;
      }
      get range() {
        if (this.formatted === void 0) {
          this.formatted = "";
          for (let i = 0; i < this.set.length; i++) {
            if (i > 0) {
              this.formatted += "||";
            }
            const comps = this.set[i];
            for (let k = 0; k < comps.length; k++) {
              if (k > 0) {
                this.formatted += " ";
              }
              this.formatted += comps[k].toString().trim();
            }
          }
        }
        return this.formatted;
      }
      format() {
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range;
        const cached = cache.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        debug("tilde trim", range);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        debug("caret trim", range);
        let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re[t.COMPARATORLOOSE]);
          });
        }
        debug("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof _Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version) {
        if (!version) {
          return false;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module2.exports = Range;
    var LRU = require_lrucache();
    var cache = new LRU();
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug();
    var SemVer = require_semver();
    var {
      safeRe: re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      comp = comp.replace(re[t.BUILD], "");
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
    };
    var replaceTilde = (comp, options) => {
      const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
    };
    var replaceCaret = (comp, options) => {
      debug("caret", comp, options);
      const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set, version, options) => {
      for (let i = 0; i < set.length; i++) {
        if (!set[i].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set.length; i++) {
          debug(set[i].semver);
          if (set[i].semver === Comparator.ANY) {
            continue;
          }
          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/conf/node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/conf/node_modules/semver/classes/comparator.js"(exports2, module2) {
    "use strict";
    var ANY = Symbol("SemVer ANY");
    var Comparator = class _Comparator {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof _Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version) {
        debug("Comparator.test", version, this.options.loose);
        if (this.semver === ANY || version === ANY) {
          return true;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof _Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module2.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re, t } = require_re();
    var cmp = require_cmp();
    var debug = require_debug();
    var SemVer = require_semver();
    var Range = require_range();
  }
});

// node_modules/conf/node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/conf/node_modules/semver/functions/satisfies.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var satisfies = (version, range, options) => {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version);
    };
    module2.exports = satisfies;
  }
});

// node_modules/conf/node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "node_modules/conf/node_modules/semver/ranges/to-comparators.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
    module2.exports = toComparators;
  }
});

// node_modules/conf/node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "node_modules/conf/node_modules/semver/ranges/max-satisfying.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var maxSatisfying = (versions, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    };
    module2.exports = maxSatisfying;
  }
});

// node_modules/conf/node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "node_modules/conf/node_modules/semver/ranges/min-satisfying.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var minSatisfying = (versions, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    };
    module2.exports = minSatisfying;
  }
});

// node_modules/conf/node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "node_modules/conf/node_modules/semver/ranges/min-version.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var gt = require_gt();
    var minVersion = (range, loose) => {
      range = new Range(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            /* fallthrough */
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            /* istanbul ignore next */
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module2.exports = minVersion;
  }
});

// node_modules/conf/node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "node_modules/conf/node_modules/semver/ranges/valid.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var validRange = (range, options) => {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module2.exports = validRange;
  }
});

// node_modules/conf/node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "node_modules/conf/node_modules/semver/ranges/outside.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range();
    var satisfies = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version, range, hilo, options) => {
      version = new SemVer(version, options);
      range = new Range(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, options)) {
        return false;
      }
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module2.exports = outside;
  }
});

// node_modules/conf/node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "node_modules/conf/node_modules/semver/ranges/gtr.js"(exports2, module2) {
    "use strict";
    var outside = require_outside();
    var gtr = (version, range, options) => outside(version, range, ">", options);
    module2.exports = gtr;
  }
});

// node_modules/conf/node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "node_modules/conf/node_modules/semver/ranges/ltr.js"(exports2, module2) {
    "use strict";
    var outside = require_outside();
    var ltr = (version, range, options) => outside(version, range, "<", options);
    module2.exports = ltr;
  }
});

// node_modules/conf/node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "node_modules/conf/node_modules/semver/ranges/intersects.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var intersects = (r1, r2, options) => {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2, options);
    };
    module2.exports = intersects;
  }
});

// node_modules/conf/node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "node_modules/conf/node_modules/semver/ranges/simplify.js"(exports2, module2) {
    "use strict";
    var satisfies = require_satisfies();
    var compare = require_compare();
    module2.exports = (versions, range, options) => {
      const set = [];
      let first = null;
      let prev = null;
      const v = versions.sort((a, b) => compare(a, b, options));
      for (const version of v) {
        const included = satisfies(version, range, options);
        if (included) {
          prev = version;
          if (!first) {
            first = version;
          }
        } else {
          if (prev) {
            set.push([first, prev]);
          }
          prev = null;
          first = null;
        }
      }
      if (first) {
        set.push([first, null]);
      }
      const ranges = [];
      for (const [min, max] of set) {
        if (min === max) {
          ranges.push(min);
        } else if (!max && min === v[0]) {
          ranges.push("*");
        } else if (!max) {
          ranges.push(`>=${min}`);
        } else if (min === v[0]) {
          ranges.push(`<=${max}`);
        } else {
          ranges.push(`${min} - ${max}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});

// node_modules/conf/node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "node_modules/conf/node_modules/semver/ranges/subset.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare = require_compare();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER: for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub) {
            continue OUTER;
          }
        }
        if (sawNonNull) {
          return false;
        }
      }
      return true;
    };
    var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
    var minimumVersion = [new Comparator(">=0.0.0")];
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c of sub) {
        if (c.operator === ">" || c.operator === ">=") {
          gt = higherGT(gt, c, options);
        } else if (c.operator === "<" || c.operator === "<=") {
          lt = lowerLT(lt, c, options);
        } else {
          eqSet.add(c.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
          return null;
        }
      }
      for (const eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options)) {
          return null;
        }
        if (lt && !satisfies(eq, String(lt), options)) {
          return null;
        }
        for (const c of dom) {
          if (!satisfies(eq, String(c), options)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c.operator === ">" || c.operator === ">=") {
            higher = higherGT(gt, c, options);
            if (higher === c && higher !== gt) {
              return false;
            }
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options)) {
            return false;
          }
        }
        if (lt) {
          if (needDomLTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c.operator === "<" || c.operator === "<=") {
            lower = lowerLT(lt, c, options);
            if (lower === c && lower !== lt) {
              return false;
            }
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options)) {
            return false;
          }
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
      }
      if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
    };
    var lowerLT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
    };
    module2.exports = subset;
  }
});

// node_modules/conf/node_modules/semver/index.js
var require_semver2 = __commonJS({
  "node_modules/conf/node_modules/semver/index.js"(exports2, module2) {
    "use strict";
    var internalRe = require_re();
    var constants = require_constants();
    var SemVer = require_semver();
    var identifiers = require_identifiers();
    var parse = require_parse();
    var valid = require_valid();
    var clean = require_clean();
    var inc = require_inc();
    var diff = require_diff();
    var major = require_major();
    var minor = require_minor();
    var patch = require_patch();
    var prerelease = require_prerelease();
    var compare = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort = require_sort();
    var rsort = require_rsort();
    var gt = require_gt();
    var lt = require_lt();
    var eq = require_eq();
    var neq = require_neq();
    var gte = require_gte();
    var lte = require_lte();
    var cmp = require_cmp();
    var coerce = require_coerce();
    var Comparator = require_comparator();
    var Range = require_range();
    var satisfies = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects = require_intersects();
    var simplifyRange = require_simplify();
    var subset = require_subset();
    module2.exports = {
      parse,
      valid,
      clean,
      inc,
      diff,
      major,
      minor,
      patch,
      prerelease,
      compare,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt,
      lt,
      eq,
      neq,
      gte,
      lte,
      cmp,
      coerce,
      Comparator,
      Range,
      satisfies,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
  }
});

// node_modules/onetime/node_modules/mimic-fn/index.js
var require_mimic_fn2 = __commonJS({
  "node_modules/onetime/node_modules/mimic-fn/index.js"(exports2, module2) {
    "use strict";
    var mimicFn = (to, from) => {
      for (const prop of Reflect.ownKeys(from)) {
        Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));
      }
      return to;
    };
    module2.exports = mimicFn;
    module2.exports.default = mimicFn;
  }
});

// node_modules/onetime/index.js
var require_onetime = __commonJS({
  "node_modules/onetime/index.js"(exports2, module2) {
    "use strict";
    var mimicFn = require_mimic_fn2();
    var calledFunctions = /* @__PURE__ */ new WeakMap();
    var onetime = (function_, options = {}) => {
      if (typeof function_ !== "function") {
        throw new TypeError("Expected a function");
      }
      let returnValue;
      let callCount = 0;
      const functionName = function_.displayName || function_.name || "<anonymous>";
      const onetime2 = function(...arguments_) {
        calledFunctions.set(onetime2, ++callCount);
        if (callCount === 1) {
          returnValue = function_.apply(this, arguments_);
          function_ = null;
        } else if (options.throw === true) {
          throw new Error(`Function \`${functionName}\` can only be called once`);
        }
        return returnValue;
      };
      mimicFn(onetime2, function_);
      calledFunctions.set(onetime2, callCount);
      return onetime2;
    };
    module2.exports = onetime;
    module2.exports.default = onetime;
    module2.exports.callCount = (function_) => {
      if (!calledFunctions.has(function_)) {
        throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
      }
      return calledFunctions.get(function_);
    };
  }
});

// node_modules/conf/dist/source/index.js
var require_source = __commonJS({
  "node_modules/conf/dist/source/index.js"(exports2, module2) {
    "use strict";
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m") throw new TypeError("Private method is not writable");
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _a;
    var _b;
    var _Conf_validator;
    var _Conf_encryptionKey;
    var _Conf_options;
    var _Conf_defaultValues;
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require("util");
    var fs14 = require("fs");
    var path16 = require("path");
    var crypto2 = require("crypto");
    var assert = require("assert");
    var events_1 = require("events");
    var dotProp = require_dot_prop();
    var pkgUp = require_pkg_up();
    var envPaths = require_env_paths();
    var atomically = require_dist();
    var ajv_1 = require_ajv();
    var ajv_formats_1 = require_dist2();
    var debounceFn = require_debounce_fn();
    var semver = require_semver2();
    var onetime = require_onetime();
    var encryptionAlgorithm = "aes-256-cbc";
    var createPlainObject = () => {
      return /* @__PURE__ */ Object.create(null);
    };
    var isExist = (data) => {
      return data !== void 0 && data !== null;
    };
    var parentDir = "";
    try {
      delete require.cache[__filename];
      parentDir = path16.dirname((_b = (_a = module2.parent) === null || _a === void 0 ? void 0 : _a.filename) !== null && _b !== void 0 ? _b : ".");
    } catch (_c) {
    }
    var checkValueType = (key, value) => {
      const nonJsonTypes = /* @__PURE__ */ new Set([
        "undefined",
        "symbol",
        "function"
      ]);
      const type = typeof value;
      if (nonJsonTypes.has(type)) {
        throw new TypeError(`Setting a value of type \`${type}\` for key \`${key}\` is not allowed as it's not supported by JSON`);
      }
    };
    var INTERNAL_KEY = "__internal__";
    var MIGRATION_KEY = `${INTERNAL_KEY}.migrations.version`;
    var Conf = class {
      constructor(partialOptions = {}) {
        var _a2;
        _Conf_validator.set(this, void 0);
        _Conf_encryptionKey.set(this, void 0);
        _Conf_options.set(this, void 0);
        _Conf_defaultValues.set(this, {});
        this._deserialize = (value) => JSON.parse(value);
        this._serialize = (value) => JSON.stringify(value, void 0, "	");
        const options = {
          configName: "config",
          fileExtension: "json",
          projectSuffix: "nodejs",
          clearInvalidConfig: false,
          accessPropertiesByDotNotation: true,
          configFileMode: 438,
          ...partialOptions
        };
        const getPackageData = onetime(() => {
          const packagePath = pkgUp.sync({ cwd: parentDir });
          const packageData = packagePath && JSON.parse(fs14.readFileSync(packagePath, "utf8"));
          return packageData !== null && packageData !== void 0 ? packageData : {};
        });
        if (!options.cwd) {
          if (!options.projectName) {
            options.projectName = getPackageData().name;
          }
          if (!options.projectName) {
            throw new Error("Project name could not be inferred. Please specify the `projectName` option.");
          }
          options.cwd = envPaths(options.projectName, { suffix: options.projectSuffix }).config;
        }
        __classPrivateFieldSet(this, _Conf_options, options, "f");
        if (options.schema) {
          if (typeof options.schema !== "object") {
            throw new TypeError("The `schema` option must be an object.");
          }
          const ajv = new ajv_1.default({
            allErrors: true,
            useDefaults: true
          });
          (0, ajv_formats_1.default)(ajv);
          const schema = {
            type: "object",
            properties: options.schema
          };
          __classPrivateFieldSet(this, _Conf_validator, ajv.compile(schema), "f");
          for (const [key, value] of Object.entries(options.schema)) {
            if (value === null || value === void 0 ? void 0 : value.default) {
              __classPrivateFieldGet(this, _Conf_defaultValues, "f")[key] = value.default;
            }
          }
        }
        if (options.defaults) {
          __classPrivateFieldSet(this, _Conf_defaultValues, {
            ...__classPrivateFieldGet(this, _Conf_defaultValues, "f"),
            ...options.defaults
          }, "f");
        }
        if (options.serialize) {
          this._serialize = options.serialize;
        }
        if (options.deserialize) {
          this._deserialize = options.deserialize;
        }
        this.events = new events_1.EventEmitter();
        __classPrivateFieldSet(this, _Conf_encryptionKey, options.encryptionKey, "f");
        const fileExtension = options.fileExtension ? `.${options.fileExtension}` : "";
        this.path = path16.resolve(options.cwd, `${(_a2 = options.configName) !== null && _a2 !== void 0 ? _a2 : "config"}${fileExtension}`);
        const fileStore = this.store;
        const store2 = Object.assign(createPlainObject(), options.defaults, fileStore);
        this._validate(store2);
        try {
          assert.deepEqual(fileStore, store2);
        } catch (_b2) {
          this.store = store2;
        }
        if (options.watch) {
          this._watch();
        }
        if (options.migrations) {
          if (!options.projectVersion) {
            options.projectVersion = getPackageData().version;
          }
          if (!options.projectVersion) {
            throw new Error("Project version could not be inferred. Please specify the `projectVersion` option.");
          }
          this._migrate(options.migrations, options.projectVersion, options.beforeEachMigration);
        }
      }
      get(key, defaultValue) {
        if (__classPrivateFieldGet(this, _Conf_options, "f").accessPropertiesByDotNotation) {
          return this._get(key, defaultValue);
        }
        const { store: store2 } = this;
        return key in store2 ? store2[key] : defaultValue;
      }
      set(key, value) {
        if (typeof key !== "string" && typeof key !== "object") {
          throw new TypeError(`Expected \`key\` to be of type \`string\` or \`object\`, got ${typeof key}`);
        }
        if (typeof key !== "object" && value === void 0) {
          throw new TypeError("Use `delete()` to clear values");
        }
        if (this._containsReservedKey(key)) {
          throw new TypeError(`Please don't use the ${INTERNAL_KEY} key, as it's used to manage this module internal operations.`);
        }
        const { store: store2 } = this;
        const set = (key2, value2) => {
          checkValueType(key2, value2);
          if (__classPrivateFieldGet(this, _Conf_options, "f").accessPropertiesByDotNotation) {
            dotProp.set(store2, key2, value2);
          } else {
            store2[key2] = value2;
          }
        };
        if (typeof key === "object") {
          const object = key;
          for (const [key2, value2] of Object.entries(object)) {
            set(key2, value2);
          }
        } else {
          set(key, value);
        }
        this.store = store2;
      }
      /**
          Check if an item exists.
      
          @param key - The key of the item to check.
          */
      has(key) {
        if (__classPrivateFieldGet(this, _Conf_options, "f").accessPropertiesByDotNotation) {
          return dotProp.has(this.store, key);
        }
        return key in this.store;
      }
      /**
          Reset items to their default values, as defined by the `defaults` or `schema` option.
      
          @see `clear()` to reset all items.
      
          @param keys - The keys of the items to reset.
          */
      reset(...keys) {
        for (const key of keys) {
          if (isExist(__classPrivateFieldGet(this, _Conf_defaultValues, "f")[key])) {
            this.set(key, __classPrivateFieldGet(this, _Conf_defaultValues, "f")[key]);
          }
        }
      }
      /**
          Delete an item.
      
          @param key - The key of the item to delete.
          */
      delete(key) {
        const { store: store2 } = this;
        if (__classPrivateFieldGet(this, _Conf_options, "f").accessPropertiesByDotNotation) {
          dotProp.delete(store2, key);
        } else {
          delete store2[key];
        }
        this.store = store2;
      }
      /**
          Delete all items.
      
          This resets known items to their default values, if defined by the `defaults` or `schema` option.
          */
      clear() {
        this.store = createPlainObject();
        for (const key of Object.keys(__classPrivateFieldGet(this, _Conf_defaultValues, "f"))) {
          this.reset(key);
        }
      }
      /**
          Watches the given `key`, calling `callback` on any changes.
      
          @param key - The key wo watch.
          @param callback - A callback function that is called on any changes. When a `key` is first set `oldValue` will be `undefined`, and when a key is deleted `newValue` will be `undefined`.
          @returns A function, that when called, will unsubscribe.
          */
      onDidChange(key, callback) {
        if (typeof key !== "string") {
          throw new TypeError(`Expected \`key\` to be of type \`string\`, got ${typeof key}`);
        }
        if (typeof callback !== "function") {
          throw new TypeError(`Expected \`callback\` to be of type \`function\`, got ${typeof callback}`);
        }
        return this._handleChange(() => this.get(key), callback);
      }
      /**
          Watches the whole config object, calling `callback` on any changes.
      
          @param callback - A callback function that is called on any changes. When a `key` is first set `oldValue` will be `undefined`, and when a key is deleted `newValue` will be `undefined`.
          @returns A function, that when called, will unsubscribe.
          */
      onDidAnyChange(callback) {
        if (typeof callback !== "function") {
          throw new TypeError(`Expected \`callback\` to be of type \`function\`, got ${typeof callback}`);
        }
        return this._handleChange(() => this.store, callback);
      }
      get size() {
        return Object.keys(this.store).length;
      }
      get store() {
        try {
          const data = fs14.readFileSync(this.path, __classPrivateFieldGet(this, _Conf_encryptionKey, "f") ? null : "utf8");
          const dataString = this._encryptData(data);
          const deserializedData = this._deserialize(dataString);
          this._validate(deserializedData);
          return Object.assign(createPlainObject(), deserializedData);
        } catch (error) {
          if ((error === null || error === void 0 ? void 0 : error.code) === "ENOENT") {
            this._ensureDirectory();
            return createPlainObject();
          }
          if (__classPrivateFieldGet(this, _Conf_options, "f").clearInvalidConfig && error.name === "SyntaxError") {
            return createPlainObject();
          }
          throw error;
        }
      }
      set store(value) {
        this._ensureDirectory();
        this._validate(value);
        this._write(value);
        this.events.emit("change");
      }
      *[(_Conf_validator = /* @__PURE__ */ new WeakMap(), _Conf_encryptionKey = /* @__PURE__ */ new WeakMap(), _Conf_options = /* @__PURE__ */ new WeakMap(), _Conf_defaultValues = /* @__PURE__ */ new WeakMap(), Symbol.iterator)]() {
        for (const [key, value] of Object.entries(this.store)) {
          yield [key, value];
        }
      }
      _encryptData(data) {
        if (!__classPrivateFieldGet(this, _Conf_encryptionKey, "f")) {
          return data.toString();
        }
        try {
          if (__classPrivateFieldGet(this, _Conf_encryptionKey, "f")) {
            try {
              if (data.slice(16, 17).toString() === ":") {
                const initializationVector = data.slice(0, 16);
                const password = crypto2.pbkdf2Sync(__classPrivateFieldGet(this, _Conf_encryptionKey, "f"), initializationVector.toString(), 1e4, 32, "sha512");
                const decipher = crypto2.createDecipheriv(encryptionAlgorithm, password, initializationVector);
                data = Buffer.concat([decipher.update(Buffer.from(data.slice(17))), decipher.final()]).toString("utf8");
              } else {
                const decipher = crypto2.createDecipher(encryptionAlgorithm, __classPrivateFieldGet(this, _Conf_encryptionKey, "f"));
                data = Buffer.concat([decipher.update(Buffer.from(data)), decipher.final()]).toString("utf8");
              }
            } catch (_a2) {
            }
          }
        } catch (_b2) {
        }
        return data.toString();
      }
      _handleChange(getter, callback) {
        let currentValue = getter();
        const onChange = () => {
          const oldValue = currentValue;
          const newValue = getter();
          if ((0, util_1.isDeepStrictEqual)(newValue, oldValue)) {
            return;
          }
          currentValue = newValue;
          callback.call(this, newValue, oldValue);
        };
        this.events.on("change", onChange);
        return () => this.events.removeListener("change", onChange);
      }
      _validate(data) {
        if (!__classPrivateFieldGet(this, _Conf_validator, "f")) {
          return;
        }
        const valid = __classPrivateFieldGet(this, _Conf_validator, "f").call(this, data);
        if (valid || !__classPrivateFieldGet(this, _Conf_validator, "f").errors) {
          return;
        }
        const errors = __classPrivateFieldGet(this, _Conf_validator, "f").errors.map(({ instancePath, message = "" }) => `\`${instancePath.slice(1)}\` ${message}`);
        throw new Error("Config schema violation: " + errors.join("; "));
      }
      _ensureDirectory() {
        fs14.mkdirSync(path16.dirname(this.path), { recursive: true });
      }
      _write(value) {
        let data = this._serialize(value);
        if (__classPrivateFieldGet(this, _Conf_encryptionKey, "f")) {
          const initializationVector = crypto2.randomBytes(16);
          const password = crypto2.pbkdf2Sync(__classPrivateFieldGet(this, _Conf_encryptionKey, "f"), initializationVector.toString(), 1e4, 32, "sha512");
          const cipher = crypto2.createCipheriv(encryptionAlgorithm, password, initializationVector);
          data = Buffer.concat([initializationVector, Buffer.from(":"), cipher.update(Buffer.from(data)), cipher.final()]);
        }
        if (process.env.SNAP) {
          fs14.writeFileSync(this.path, data, { mode: __classPrivateFieldGet(this, _Conf_options, "f").configFileMode });
        } else {
          try {
            atomically.writeFileSync(this.path, data, { mode: __classPrivateFieldGet(this, _Conf_options, "f").configFileMode });
          } catch (error) {
            if ((error === null || error === void 0 ? void 0 : error.code) === "EXDEV") {
              fs14.writeFileSync(this.path, data, { mode: __classPrivateFieldGet(this, _Conf_options, "f").configFileMode });
              return;
            }
            throw error;
          }
        }
      }
      _watch() {
        this._ensureDirectory();
        if (!fs14.existsSync(this.path)) {
          this._write(createPlainObject());
        }
        if (process.platform === "win32") {
          fs14.watch(this.path, { persistent: false }, debounceFn(() => {
            this.events.emit("change");
          }, { wait: 100 }));
        } else {
          fs14.watchFile(this.path, { persistent: false }, debounceFn(() => {
            this.events.emit("change");
          }, { wait: 5e3 }));
        }
      }
      _migrate(migrations, versionToMigrate, beforeEachMigration) {
        let previousMigratedVersion = this._get(MIGRATION_KEY, "0.0.0");
        const newerVersions = Object.keys(migrations).filter((candidateVersion) => this._shouldPerformMigration(candidateVersion, previousMigratedVersion, versionToMigrate));
        let storeBackup = { ...this.store };
        for (const version of newerVersions) {
          try {
            if (beforeEachMigration) {
              beforeEachMigration(this, {
                fromVersion: previousMigratedVersion,
                toVersion: version,
                finalVersion: versionToMigrate,
                versions: newerVersions
              });
            }
            const migration = migrations[version];
            migration(this);
            this._set(MIGRATION_KEY, version);
            previousMigratedVersion = version;
            storeBackup = { ...this.store };
          } catch (error) {
            this.store = storeBackup;
            throw new Error(`Something went wrong during the migration! Changes applied to the store until this failed migration will be restored. ${error}`);
          }
        }
        if (this._isVersionInRangeFormat(previousMigratedVersion) || !semver.eq(previousMigratedVersion, versionToMigrate)) {
          this._set(MIGRATION_KEY, versionToMigrate);
        }
      }
      _containsReservedKey(key) {
        if (typeof key === "object") {
          const firsKey = Object.keys(key)[0];
          if (firsKey === INTERNAL_KEY) {
            return true;
          }
        }
        if (typeof key !== "string") {
          return false;
        }
        if (__classPrivateFieldGet(this, _Conf_options, "f").accessPropertiesByDotNotation) {
          if (key.startsWith(`${INTERNAL_KEY}.`)) {
            return true;
          }
          return false;
        }
        return false;
      }
      _isVersionInRangeFormat(version) {
        return semver.clean(version) === null;
      }
      _shouldPerformMigration(candidateVersion, previousMigratedVersion, versionToMigrate) {
        if (this._isVersionInRangeFormat(candidateVersion)) {
          if (previousMigratedVersion !== "0.0.0" && semver.satisfies(previousMigratedVersion, candidateVersion)) {
            return false;
          }
          return semver.satisfies(versionToMigrate, candidateVersion);
        }
        if (semver.lte(candidateVersion, previousMigratedVersion)) {
          return false;
        }
        if (semver.gt(candidateVersion, versionToMigrate)) {
          return false;
        }
        return true;
      }
      _get(key, defaultValue) {
        return dotProp.get(this.store, key, defaultValue);
      }
      _set(key, value) {
        const { store: store2 } = this;
        dotProp.set(store2, key, value);
        this.store = store2;
      }
    };
    exports2.default = Conf;
    module2.exports = Conf;
    module2.exports.default = Conf;
  }
});

// node_modules/electron-store/index.js
var require_electron_store = __commonJS({
  "node_modules/electron-store/index.js"(exports2, module2) {
    "use strict";
    var path16 = require("path");
    var { app: app13, ipcMain: ipcMain3, ipcRenderer, shell } = require("electron");
    var Conf = require_source();
    var isInitialized = false;
    var initDataListener = () => {
      if (!ipcMain3 || !app13) {
        throw new Error("Electron Store: You need to call `.initRenderer()` from the main process.");
      }
      const appData = {
        defaultCwd: app13.getPath("userData"),
        appVersion: app13.getVersion()
      };
      if (isInitialized) {
        return appData;
      }
      ipcMain3.on("electron-store-get-data", (event) => {
        event.returnValue = appData;
      });
      isInitialized = true;
      return appData;
    };
    var ElectronStore = class extends Conf {
      constructor(options) {
        let defaultCwd;
        let appVersion;
        if (ipcRenderer) {
          const appData = ipcRenderer.sendSync("electron-store-get-data");
          if (!appData) {
            throw new Error("Electron Store: You need to call `.initRenderer()` from the main process.");
          }
          ({ defaultCwd, appVersion } = appData);
        } else if (ipcMain3 && app13) {
          ({ defaultCwd, appVersion } = initDataListener());
        }
        options = {
          name: "config",
          ...options
        };
        if (!options.projectVersion) {
          options.projectVersion = appVersion;
        }
        if (options.cwd) {
          options.cwd = path16.isAbsolute(options.cwd) ? options.cwd : path16.join(defaultCwd, options.cwd);
        } else {
          options.cwd = defaultCwd;
        }
        options.configName = options.name;
        delete options.name;
        super(options);
      }
      static initRenderer() {
        initDataListener();
      }
      async openInEditor() {
        const error = await shell.openPath(this.path);
        if (error) {
          throw new Error(error);
        }
      }
    };
    module2.exports = ElectronStore;
  }
});

// electron/src/services/diagnosticsService.ts
var diagnosticsService_exports = {};
__export(diagnosticsService_exports, {
  enableReadOnlyMode: () => enableReadOnlyMode,
  enableSafeMode: () => enableSafeMode,
  exportDBSnapshot: () => exportDBSnapshot,
  exportLogs: () => exportLogs,
  getDiagnosticInfo: () => getDiagnosticInfo,
  getDiagnosticReport: () => getDiagnosticReport,
  getSystemHealth: () => getSystemHealth,
  isReadOnlyMode: () => isReadOnlyMode,
  isSafeMode: () => isSafeMode,
  validateDatabaseIntegrity: () => validateDatabaseIntegrity
});
async function getDiagnosticInfo() {
  const dbPath = path10.join(import_electron8.app.getPath("userData"), "dev.db");
  let dbSize = 0;
  let dbExists = false;
  try {
    if (fs9.existsSync(dbPath)) {
      const stats = fs9.statSync(dbPath);
      dbSize = stats.size;
      dbExists = true;
    }
  } catch (error) {
    console.error("Error checking database:", error);
  }
  return {
    appVersion: import_electron8.app.getVersion(),
    electronVersion: process.versions.electron,
    nodeVersion: process.versions.node,
    platform: process.platform,
    arch: process.arch,
    dbPath,
    dbSize,
    dbExists,
    timestamp: (/* @__PURE__ */ new Date()).toISOString()
  };
}
async function exportLogs(outputPath) {
  const logDir = import_electron8.app.getPath("logs");
  const outputFile = path10.join(outputPath, `mediclone-logs-${Date.now()}.zip`);
  if (!fs9.existsSync(logDir)) {
    throw new Error("Logs directory not found");
  }
  const logFiles = fs9.readdirSync(logDir).filter((f) => f.endsWith(".log"));
  if (logFiles.length === 0) {
    throw new Error("No log files found");
  }
  const outputDir = path10.dirname(outputFile);
  if (!fs9.existsSync(outputDir)) {
    fs9.mkdirSync(outputDir, { recursive: true });
  }
  const logContents = [];
  for (const logFile of logFiles) {
    const logPath = path10.join(logDir, logFile);
    try {
      const content = fs9.readFileSync(logPath, "utf-8");
      logContents.push(`=== ${logFile} ===
${content}

`);
    } catch (error) {
      console.error(`Error reading log file ${logFile}:`, error);
    }
  }
  fs9.writeFileSync(outputFile, logContents.join("\n"), "utf-8");
  return outputFile;
}
async function exportDBSnapshot(outputPath) {
  const dbPath = path10.join(import_electron8.app.getPath("userData"), "dev.db");
  if (!fs9.existsSync(dbPath)) {
    throw new Error("Database file not found");
  }
  const timestamp = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-");
  const snapshotPath = path10.join(outputPath, `mediclone-db-snapshot-${timestamp}.db`);
  const outputDir = path10.dirname(snapshotPath);
  if (!fs9.existsSync(outputDir)) {
    fs9.mkdirSync(outputDir, { recursive: true });
  }
  fs9.copyFileSync(dbPath, snapshotPath);
  try {
    await createBackup();
  } catch (error) {
    console.warn("Failed to create backup during snapshot:", error);
  }
  return snapshotPath;
}
async function getSystemHealth() {
  const issues = [];
  const warnings = [];
  let status = "healthy";
  let dbConnected = false;
  let dbSize = 0;
  try {
    const prisma2 = getPrismaClient();
    await prisma2.$queryRaw`SELECT 1`;
    dbConnected = true;
    const dbPath = path10.join(import_electron8.app.getPath("userData"), "dev.db");
    if (fs9.existsSync(dbPath)) {
      const stats = fs9.statSync(dbPath);
      dbSize = stats.size;
    }
  } catch (error) {
    dbConnected = false;
    issues.push("Database connection failed");
    status = "critical";
  }
  let freeSpace = 0;
  let totalSpace = 0;
  try {
    const userDataPath2 = import_electron8.app.getPath("userData");
    const stats = fs9.statSync(userDataPath2);
    freeSpace = 1024 * 1024 * 1024;
    totalSpace = 1024 * 1024 * 1024 * 10;
  } catch (error) {
    warnings.push("Could not check disk space");
  }
  const usagePercent = totalSpace > 0 ? (totalSpace - freeSpace) / totalSpace * 100 : 0;
  if (usagePercent > 90) {
    issues.push("Disk space critically low");
    status = status === "healthy" ? "degraded" : "critical";
  } else if (usagePercent > 80) {
    warnings.push("Disk space running low");
    if (status === "healthy") {
      status = "degraded";
    }
  }
  if (dbSize > 100 * 1024 * 1024) {
    warnings.push("Database size is large (>100MB). Consider cleanup.");
  }
  return {
    status,
    issues,
    warnings,
    database: {
      connected: dbConnected,
      size: dbSize
    },
    disk: {
      freeSpace,
      totalSpace,
      usagePercent
    }
  };
}
function enableSafeMode() {
  process.env.MEDICLONE_SAFE_MODE = "true";
}
function isSafeMode() {
  return process.env.MEDICLONE_SAFE_MODE === "true";
}
function enableReadOnlyMode() {
  process.env.MEDICLONE_READ_ONLY = "true";
}
function isReadOnlyMode() {
  return process.env.MEDICLONE_READ_ONLY === "true";
}
async function validateDatabaseIntegrity() {
  const errors = [];
  const warnings = [];
  try {
    const prisma2 = getPrismaClient();
    const dbPath = path10.join(import_electron8.app.getPath("userData"), "dev.db");
    if (!fs9.existsSync(dbPath)) {
      errors.push("Database file does not exist");
      return { valid: false, errors, warnings };
    }
    await prisma2.$queryRaw`SELECT 1`;
    const orphanedBatches = await prisma2.batch.findMany({
      where: {
        productId: {
          notIn: (await prisma2.product.findMany({ select: { id: true } })).map((p) => p.id)
        }
      }
    });
    if (orphanedBatches.length > 0) {
      warnings.push(`Found ${orphanedBatches.length} orphaned batches`);
    }
    const negativeStock = await prisma2.batch.findMany({
      where: {
        quantity: { lt: 0 }
      }
    });
    if (negativeStock.length > 0) {
      errors.push(`Found ${negativeStock.length} batches with negative quantity`);
    }
  } catch (error) {
    errors.push(`Database validation failed: ${error instanceof Error ? error.message : "Unknown error"}`);
    return { valid: false, errors, warnings };
  }
  return {
    valid: errors.length === 0,
    errors,
    warnings
  };
}
async function getDiagnosticReport() {
  const [info, health, integrity] = await Promise.all([
    getDiagnosticInfo(),
    getSystemHealth(),
    validateDatabaseIntegrity()
  ]);
  return {
    info,
    health,
    integrity
  };
}
var fs9, path10, import_electron8;
var init_diagnosticsService = __esm({
  "electron/src/services/diagnosticsService.ts"() {
    "use strict";
    fs9 = __toESM(require("fs"));
    path10 = __toESM(require("path"));
    import_electron8 = require("electron");
    init_prismaClient();
    init_backupService();
  }
});

// electron/src/services/migrationService.ts
var migrationService_exports = {};
__export(migrationService_exports, {
  getAppliedMigrations: () => getAppliedMigrations,
  getCurrentSchemaVersion: () => getCurrentSchemaVersion,
  getMigrationStatus: () => getMigrationStatus,
  runMigrations: () => runMigrations,
  validateSchemaCompatibility: () => validateSchemaCompatibility
});
async function ensureMigrationTable() {
  const prisma2 = getPrismaClient();
  try {
    await prisma2.$queryRawUnsafe(`SELECT 1 FROM ${MIGRATION_TABLE} LIMIT 1`);
  } catch (error) {
    if (error.message?.includes("no such table")) {
      await prisma2.$executeRawUnsafe(`
        CREATE TABLE IF NOT EXISTS ${MIGRATION_TABLE} (
          version TEXT PRIMARY KEY,
          name TEXT NOT NULL,
          applied_at DATETIME DEFAULT CURRENT_TIMESTAMP
        )
      `);
    } else {
      throw error;
    }
  }
}
async function getCurrentSchemaVersion() {
  await ensureMigrationTable();
  const prisma2 = getPrismaClient();
  try {
    const result = await prisma2.$queryRawUnsafe(
      `SELECT version FROM ${MIGRATION_TABLE} ORDER BY applied_at DESC LIMIT 1`
    );
    return result.length > 0 ? result[0].version : null;
  } catch (error) {
    console.error("Error getting schema version:", error);
    return null;
  }
}
async function isMigrationApplied(version) {
  await ensureMigrationTable();
  const prisma2 = getPrismaClient();
  try {
    const result = await prisma2.$queryRawUnsafe(
      `SELECT version FROM ${MIGRATION_TABLE} WHERE version = ?`,
      version
    );
    return result.length > 0;
  } catch (error) {
    return false;
  }
}
async function markMigrationApplied(version, name) {
  await ensureMigrationTable();
  const prisma2 = getPrismaClient();
  await prisma2.$executeRawUnsafe(
    `INSERT OR IGNORE INTO ${MIGRATION_TABLE} (version, name) VALUES (?, ?)`,
    version,
    name
  );
}
async function getAppliedMigrations() {
  await ensureMigrationTable();
  const prisma2 = getPrismaClient();
  try {
    const result = await prisma2.$queryRawUnsafe(
      `SELECT version, name, applied_at as applied_at FROM ${MIGRATION_TABLE} ORDER BY applied_at ASC`
    );
    return result.map((r) => ({
      version: r.version,
      name: r.name,
      appliedAt: new Date(r.applied_at)
    }));
  } catch (error) {
    console.error("Error getting applied migrations:", error);
    return [];
  }
}
async function runMigration(migration) {
  const prisma2 = getPrismaClient();
  if (await isMigrationApplied(migration.version)) {
    console.log(`Migration ${migration.version} (${migration.name}) already applied, skipping`);
    return;
  }
  console.log(`Running migration ${migration.version}: ${migration.name}`);
  try {
    try {
      await createBackup();
      console.log("Backup created before migration");
    } catch (error) {
      console.warn("Failed to create backup before migration:", error);
    }
    await prisma2.$transaction(
      async (tx) => {
        await migration.up(tx);
        await markMigrationApplied(migration.version, migration.name);
      },
      { timeout: 1e4 }
    );
    console.log(`Migration ${migration.version} completed successfully`);
  } catch (error) {
    console.error(`Migration ${migration.version} failed:`, error);
    throw new Error(`Migration ${migration.version} (${migration.name}) failed: ${error instanceof Error ? error.message : "Unknown error"}`);
  }
}
async function runMigrations(migrations) {
  await ensureMigrationTable();
  const applied = [];
  const skipped = [];
  const errors = [];
  const sortedMigrations = [...migrations].sort(
    (a, b) => a.version.localeCompare(b.version, void 0, { numeric: true, sensitivity: "base" })
  );
  for (const migration of sortedMigrations) {
    try {
      if (await isMigrationApplied(migration.version)) {
        skipped.push(migration.version);
        continue;
      }
      await runMigration(migration);
      applied.push(migration.version);
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : "Unknown error";
      errors.push(`${migration.version}: ${errorMsg}`);
      console.error(`Failed to apply migration ${migration.version}:`, error);
      break;
    }
  }
  return {
    applied: applied.length,
    skipped: skipped.length,
    errors
  };
}
async function getMigrationStatus(migrations) {
  const currentVersion = await getCurrentSchemaVersion();
  const appliedVersions = (await getAppliedMigrations()).map((m) => m.version);
  const pendingMigrations = migrations.filter((m) => !appliedVersions.includes(m.version));
  return {
    currentVersion,
    pendingMigrations,
    appliedMigrations: appliedVersions
  };
}
async function validateSchemaCompatibility(requiredVersion, migrations) {
  const currentVersion = await getCurrentSchemaVersion();
  if (!currentVersion) {
    return {
      compatible: false,
      currentVersion: null,
      requiredVersion,
      message: "Database schema version not found. Migration required."
    };
  }
  const compatible = currentVersion >= requiredVersion;
  return {
    compatible,
    currentVersion,
    requiredVersion,
    message: compatible ? "Database schema is compatible" : `Database schema version ${currentVersion} is older than required ${requiredVersion}. Migration required.`
  };
}
var MIGRATION_TABLE;
var init_migrationService = __esm({
  "electron/src/services/migrationService.ts"() {
    "use strict";
    init_prismaClient();
    init_backupService();
    MIGRATION_TABLE = "schema_migrations";
  }
});

// electron/src/services/draftService.ts
var draftService_exports = {};
__export(draftService_exports, {
  autoSaveDraft: () => autoSaveDraft,
  cleanupOldDrafts: () => cleanupOldDrafts,
  getRecoverableDrafts: () => getRecoverableDrafts
});
async function autoSaveDraft(billId, payload, userId) {
  if (billId) {
    return updateBill(billId, payload);
  } else {
    const draftPayload = {
      ...payload
      // Status will be set to DRAFT by default in createBill
    };
    return createBill(draftPayload, userId);
  }
}
async function getRecoverableDrafts(userId) {
  const prisma2 = getPrismaClient();
  const drafts = await prisma2.bill.findMany({
    where: {
      status: "DRAFT"
      // Note: If user-specific drafts are needed, add createdBy field to Bill schema
    },
    include: {
      lines: {
        include: {
          product: true,
          batch: true
        },
        orderBy: { lineNumber: "asc" }
      },
      customer: true,
      supplier: true,
      template: true,
      mr: true,
      doctor: true
    },
    orderBy: {
      updatedAt: "desc"
    },
    take: 50
    // Limit to last 50 drafts
  });
  const { getBillById: getBillById2 } = await Promise.resolve().then(() => (init_billService(), billService_exports));
  return Promise.all(drafts.map((draft) => getBillById2(draft.id)));
}
async function cleanupOldDrafts() {
  const prisma2 = getPrismaClient();
  const cutoffDate = /* @__PURE__ */ new Date();
  cutoffDate.setDate(cutoffDate.getDate() - DRAFT_TIMEOUT_DAYS);
  const result = await prisma2.bill.deleteMany({
    where: {
      status: "DRAFT",
      updatedAt: {
        lt: cutoffDate
      }
    }
  });
  return result.count;
}
var DRAFT_TIMEOUT_DAYS;
var init_draftService = __esm({
  "electron/src/services/draftService.ts"() {
    "use strict";
    init_prismaClient();
    init_billService();
    DRAFT_TIMEOUT_DAYS = 7;
  }
});

// electron/src/services/scheduleH1RegisterService.ts
var scheduleH1RegisterService_exports = {};
__export(scheduleH1RegisterService_exports, {
  exportScheduleH1RegisterCSV: () => exportScheduleH1RegisterCSV,
  exportScheduleH1RegisterPDF: () => exportScheduleH1RegisterPDF,
  getScheduleH1Register: () => getScheduleH1Register
});
async function getScheduleH1Register(filters) {
  const prisma2 = getPrismaClient();
  const fromDate = new Date(filters.fromDate);
  const toDate = new Date(filters.toDate);
  toDate.setHours(23, 59, 59, 999);
  const where = {
    bill: {
      billType: "SALES",
      status: "FINALIZED",
      billDate: {
        gte: fromDate,
        lte: toDate
      },
      deletedAt: null,
      ...filters.customerId && { customerId: filters.customerId },
      ...filters.doctorId && { doctorId: filters.doctorId }
    },
    product: {
      schedule: {
        name: {
          in: ["H1", "H"]
          // Include both H and H1
        }
      },
      ...filters.productId && { id: filters.productId }
    }
  };
  const billLines = await prisma2.billLine.findMany({
    where,
    include: {
      bill: {
        include: {
          customer: true,
          doctor: true
        }
      },
      product: {
        include: {
          schedule: true
        }
      },
      batch: true
    },
    orderBy: {
      bill: {
        billDate: "asc"
      }
    }
  });
  return billLines.map((line) => ({
    date: line.bill.billDate.toISOString().split("T")[0],
    invoiceNumber: line.bill.billNumber || `BILL-${line.bill.id}`,
    customerName: line.bill.customer?.name || "N/A",
    customerAddress: line.bill.customer ? [
      line.bill.customer.addressLine1,
      line.bill.customer.addressLine2,
      line.bill.customer.city,
      line.bill.customer.state,
      line.bill.customer.postalCode
    ].filter(Boolean).join(", ") : "",
    customerDL: line.bill.customer?.drugLicenseNumber || null,
    doctorName: line.bill.doctor?.name || null,
    // Doctor DL is not present in the current Prisma model; keep it nullable for now
    doctorDL: null,
    patientName: line.bill.patientName || null,
    // Patient name if stored
    productName: line.product.name,
    batchNumber: line.batch?.batchNumber || "N/A",
    quantity: Number(line.quantity),
    unit: line.product.unitOfMeasure || "pcs",
    schedule: line.product.schedule?.name || "N/A"
  }));
}
async function exportScheduleH1RegisterCSV(filters, outputPath) {
  const entries = await getScheduleH1Register(filters);
  const headers = [
    "Date",
    "Invoice Number",
    "Customer Name",
    "Customer Address",
    "Customer DL",
    "Doctor Name",
    "Doctor DL",
    "Patient Name",
    "Product Name",
    "Batch Number",
    "Quantity",
    "Unit",
    "Schedule"
  ];
  const rows = entries.map((entry) => [
    entry.date,
    entry.invoiceNumber,
    `"${entry.customerName}"`,
    `"${entry.customerAddress}"`,
    entry.customerDL || "",
    entry.doctorName || "",
    entry.doctorDL || "",
    entry.patientName || "",
    `"${entry.productName}"`,
    entry.batchNumber,
    entry.quantity.toString(),
    entry.unit,
    entry.schedule
  ]);
  const csvContent = [
    headers.join(","),
    ...rows.map((row) => row.join(","))
  ].join("\n");
  const finalPath = outputPath || path11.join(
    import_electron9.app.getPath("documents"),
    `Schedule_H1_Register_${filters.fromDate}_to_${filters.toDate}.csv`
  );
  const dir = path11.dirname(finalPath);
  if (!fs10.existsSync(dir)) {
    fs10.mkdirSync(dir, { recursive: true });
  }
  fs10.writeFileSync(finalPath, csvContent, "utf-8");
  logger.info(`Schedule H1 register exported to: ${finalPath}`);
  return finalPath;
}
async function exportScheduleH1RegisterPDF(filters, outputPath) {
  const entries = await getScheduleH1Register(filters);
  const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Schedule H1 Register</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      font-size: 10pt;
      margin: 20px;
    }
    h1 {
      text-align: center;
      margin-bottom: 20px;
    }
    .period {
      text-align: center;
      margin-bottom: 20px;
      color: #666;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
    }
    th, td {
      border: 1px solid #000;
      padding: 6px;
      text-align: left;
    }
    th {
      background-color: #f0f0f0;
      font-weight: bold;
    }
    tr:nth-child(even) {
      background-color: #f9f9f9;
    }
    .footer {
      margin-top: 30px;
      text-align: right;
      font-size: 9pt;
      color: #666;
    }
  </style>
</head>
<body>
  <h1>Schedule H1 Register</h1>
  <div class="period">
    Period: ${filters.fromDate} to ${filters.toDate}
  </div>
  <table>
    <thead>
      <tr>
        <th>Date</th>
        <th>Invoice No.</th>
        <th>Customer Name</th>
        <th>Customer Address</th>
        <th>Customer DL</th>
        <th>Doctor Name</th>
        <th>Doctor DL</th>
        <th>Patient Name</th>
        <th>Product Name</th>
        <th>Batch No.</th>
        <th>Qty</th>
        <th>Unit</th>
        <th>Schedule</th>
      </tr>
    </thead>
    <tbody>
      ${entries.map((entry) => `
        <tr>
          <td>${entry.date}</td>
          <td>${entry.invoiceNumber}</td>
          <td>${entry.customerName}</td>
          <td>${entry.customerAddress}</td>
          <td>${entry.customerDL || ""}</td>
          <td>${entry.doctorName || ""}</td>
          <td>${entry.doctorDL || ""}</td>
          <td>${entry.patientName || ""}</td>
          <td>${entry.productName}</td>
          <td>${entry.batchNumber}</td>
          <td>${entry.quantity}</td>
          <td>${entry.unit}</td>
          <td>${entry.schedule}</td>
        </tr>
      `).join("")}
    </tbody>
  </table>
  <div class="footer">
    Generated on: ${(/* @__PURE__ */ new Date()).toLocaleString()}<br>
    Total Entries: ${entries.length}
  </div>
</body>
</html>
  `;
  const finalPath = outputPath || path11.join(
    import_electron9.app.getPath("documents"),
    `Schedule_H1_Register_${filters.fromDate}_to_${filters.toDate}.html`
  );
  const dir = path11.dirname(finalPath);
  if (!fs10.existsSync(dir)) {
    fs10.mkdirSync(dir, { recursive: true });
  }
  fs10.writeFileSync(finalPath, html, "utf-8");
  logger.info(`Schedule H1 register HTML exported to: ${finalPath}`);
  return finalPath;
}
var fs10, path11, import_electron9;
var init_scheduleH1RegisterService = __esm({
  "electron/src/services/scheduleH1RegisterService.ts"() {
    "use strict";
    init_prismaClient();
    fs10 = __toESM(require("fs"));
    path11 = __toESM(require("path"));
    import_electron9 = require("electron");
    init_logger();
  }
});

// electron/src/services/gstr1ExportService.ts
var gstr1ExportService_exports = {};
__export(gstr1ExportService_exports, {
  exportGSTR1Excel: () => exportGSTR1Excel,
  exportGSTR1JSON: () => exportGSTR1JSON,
  getGSTR1Data: () => getGSTR1Data
});
async function getGSTR1Data(filters) {
  const prisma2 = getPrismaClient();
  const companyInfo = await getCompanyInfo();
  const fromDate = new Date(filters.fromDate);
  const toDate = new Date(filters.toDate);
  toDate.setHours(23, 59, 59, 999);
  const month = String(fromDate.getMonth() + 1).padStart(2, "0");
  const year = fromDate.getFullYear();
  const retPeriod = `${month}-${year}`;
  const bills = await prisma2.bill.findMany({
    where: {
      billType: "SALES",
      status: "FINALIZED",
      billDate: {
        gte: fromDate,
        lte: toDate
      },
      deletedAt: null
    },
    include: {
      customer: true,
      lines: {
        include: {
          product: true
        }
      }
    },
    orderBy: {
      billDate: "asc"
    }
  });
  const b2b = [];
  const b2cl = [];
  const b2cs = [];
  const hsnMap = /* @__PURE__ */ new Map();
  for (const bill of bills) {
    const customerGstin = bill.customer?.gstin;
    const isB2B = customerGstin && customerGstin.length >= 15;
    const isInterState = bill.customer?.state !== companyInfo?.state;
    const invDate = bill.billDate.toLocaleDateString("en-GB", {
      day: "2-digit",
      month: "2-digit",
      year: "numeric"
    }).replace(/\//g, "-");
    const inv = {
      num: bill.billNumber,
      dt: invDate,
      val: Number(bill.totalAmount),
      pos: bill.customer?.stateCode || "00",
      rchrg: "N",
      inv_typ: "R",
      // Regular
      itms: bill.lines.map((line, idx) => {
        const hsnCode = line.hsnCode || "00000000";
        const rt = Number(line.taxPercent);
        const txval = Number(line.taxableAmount);
        const iamt = Number(line.igstAmount);
        const camt = Number(line.cgstAmount);
        const samt = Number(line.sgstAmount);
        const qty = Number(line.quantity);
        const uqc = line.unitOfMeasure || "PCS";
        const hsnKey = hsnCode;
        if (!hsnMap.has(hsnKey)) {
          hsnMap.set(hsnKey, {
            hsn_sc: hsnCode,
            desc: line.productName,
            uqc,
            qty: 0,
            rt,
            txval: 0,
            iamt: 0,
            camt: 0,
            samt: 0,
            csamt: 0
          });
        }
        const hsnEntry = hsnMap.get(hsnKey);
        hsnEntry.qty += qty;
        hsnEntry.txval += txval;
        hsnEntry.iamt += iamt;
        hsnEntry.camt += camt;
        hsnEntry.samt += samt;
        return {
          num: idx + 1,
          hsn_sc: hsnCode,
          qty,
          uqc,
          rt,
          txval,
          iamt,
          camt,
          samt,
          csamt: 0
        };
      })
    };
    if (isB2B) {
      const ctin = customerGstin;
      let b2bEntry = b2b.find((e) => e.ctin === ctin);
      if (!b2bEntry) {
        b2bEntry = {
          ctin,
          pos: bill.customer?.stateCode || "00",
          typ: "B2B",
          rt: "R",
          flag: "",
          chksum: "",
          inv: []
        };
        b2b.push(b2bEntry);
      }
      b2bEntry.inv.push(inv);
    } else if (isInterState && Number(bill.totalAmount) >= 25e4) {
      b2cl.push({
        typ: "B2CL",
        pos: bill.customer?.stateCode || "00",
        rt: "R",
        flag: "",
        chksum: "",
        inv: [inv]
      });
    } else {
      b2cs.push({
        typ: "B2CS",
        pos: bill.customer?.stateCode || "00",
        rt: "R",
        flag: "",
        chksum: "",
        inv: [inv]
      });
    }
  }
  const hsn = Array.from(hsnMap.entries()).map(([_, data], idx) => ({
    num: idx + 1,
    ...data
  }));
  return {
    gstin: companyInfo?.gstNumber || "",
    ret_period: retPeriod,
    b2b,
    b2cl,
    b2cs,
    hsn
  };
}
async function exportGSTR1JSON(filters, outputPath) {
  const data = await getGSTR1Data(filters);
  const finalPath = outputPath || path12.join(
    import_electron10.app.getPath("documents"),
    `GSTR1_${filters.fromDate}_to_${filters.toDate}.json`
  );
  const dir = path12.dirname(finalPath);
  if (!fs11.existsSync(dir)) {
    fs11.mkdirSync(dir, { recursive: true });
  }
  fs11.writeFileSync(finalPath, JSON.stringify(data, null, 2), "utf-8");
  logger.info(`GSTR-1 JSON exported to: ${finalPath}`);
  return finalPath;
}
async function exportGSTR1Excel(filters, outputPath) {
  const data = await getGSTR1Data(filters);
  const rows = [];
  rows.push("GSTIN,Return Period,Type,Customer GSTIN,Invoice Number,Invoice Date,Place of Supply,HSN Code,Quantity,Unit,Tax Rate,Taxable Value,IGST,CGST,SGST,Cess");
  for (const b2bEntry of data.b2b) {
    for (const inv of b2bEntry.inv) {
      for (const itm of inv.itms) {
        rows.push([
          data.gstin,
          data.ret_period,
          "B2B",
          b2bEntry.ctin,
          inv.num,
          inv.dt,
          inv.pos,
          itm.hsn_sc,
          itm.qty.toString(),
          itm.uqc,
          itm.rt.toString(),
          itm.txval.toString(),
          itm.iamt.toString(),
          itm.camt.toString(),
          itm.samt.toString(),
          itm.csamt.toString()
        ].join(","));
      }
    }
  }
  for (const b2clEntry of data.b2cl) {
    for (const inv of b2clEntry.inv) {
      for (const itm of inv.itms) {
        rows.push([
          data.gstin,
          data.ret_period,
          "B2CL",
          "",
          inv.num,
          inv.dt,
          inv.pos,
          itm.hsn_sc,
          itm.qty.toString(),
          itm.uqc,
          itm.rt.toString(),
          itm.txval.toString(),
          itm.iamt.toString(),
          itm.camt.toString(),
          itm.samt.toString(),
          itm.csamt.toString()
        ].join(","));
      }
    }
  }
  for (const b2csEntry of data.b2cs) {
    for (const inv of b2csEntry.inv) {
      for (const itm of inv.itms) {
        rows.push([
          data.gstin,
          data.ret_period,
          "B2CS",
          "",
          inv.num,
          inv.dt,
          inv.pos,
          itm.hsn_sc,
          itm.qty.toString(),
          itm.uqc,
          itm.rt.toString(),
          itm.txval.toString(),
          itm.iamt.toString(),
          itm.camt.toString(),
          itm.samt.toString(),
          itm.csamt.toString()
        ].join(","));
      }
    }
  }
  rows.push("");
  rows.push("HSN Summary");
  rows.push("HSN Code,Description,Unit,Quantity,Tax Rate,Taxable Value,IGST,CGST,SGST,Cess");
  for (const hsnEntry of data.hsn) {
    rows.push([
      hsnEntry.hsn_sc,
      hsnEntry.desc,
      hsnEntry.uqc,
      hsnEntry.qty.toString(),
      hsnEntry.rt.toString(),
      hsnEntry.txval.toString(),
      hsnEntry.iamt.toString(),
      hsnEntry.camt.toString(),
      hsnEntry.samt.toString(),
      hsnEntry.csamt.toString()
    ].join(","));
  }
  const csvContent = rows.join("\n");
  const finalPath = outputPath || path12.join(
    import_electron10.app.getPath("documents"),
    `GSTR1_${filters.fromDate}_to_${filters.toDate}.csv`
  );
  const dir = path12.dirname(finalPath);
  if (!fs11.existsSync(dir)) {
    fs11.mkdirSync(dir, { recursive: true });
  }
  fs11.writeFileSync(finalPath, csvContent, "utf-8");
  logger.info(`GSTR-1 CSV exported to: ${finalPath}`);
  return finalPath;
}
var fs11, path12, import_electron10;
var init_gstr1ExportService = __esm({
  "electron/src/services/gstr1ExportService.ts"() {
    "use strict";
    init_prismaClient();
    fs11 = __toESM(require("fs"));
    path12 = __toESM(require("path"));
    import_electron10 = require("electron");
    init_logger();
    init_companyInfoService();
  }
});

// electron/src/services/auditExportService.ts
var auditExportService_exports = {};
__export(auditExportService_exports, {
  exportAuditLogCSV: () => exportAuditLogCSV,
  exportAuditLogJSON: () => exportAuditLogJSON,
  getAuditLogs: () => getAuditLogs
});
async function getAuditLogs(filters) {
  const prisma2 = getPrismaClient();
  const where = {};
  if (filters.fromDate || filters.toDate) {
    where.createdAt = {};
    if (filters.fromDate) {
      where.createdAt.gte = new Date(filters.fromDate);
    }
    if (filters.toDate) {
      const toDate = new Date(filters.toDate);
      toDate.setHours(23, 59, 59, 999);
      where.createdAt.lte = toDate;
    }
  }
  if (filters.entity) {
    where.entity = filters.entity;
  }
  if (filters.entityId) {
    where.entityId = filters.entityId;
  }
  if (filters.userId) {
    where.userId = filters.userId;
  }
  if (filters.action) {
    where.action = filters.action;
  }
  const logs = await prisma2.auditLog.findMany({
    where,
    include: {
      user: {
        select: {
          fullName: true
        }
      }
    },
    orderBy: {
      createdAt: "desc"
    },
    take: 1e4
    // Limit to prevent memory issues
  });
  return logs.map((log2) => ({
    id: log2.id,
    timestamp: log2.createdAt.toISOString(),
    entity: log2.entity,
    entityId: log2.entityId ?? void 0,
    action: log2.action,
    userId: log2.userId ?? void 0,
    userName: log2.user?.fullName ?? void 0,
    details: log2.details ? JSON.parse(log2.details) : void 0
  }));
}
async function exportAuditLogCSV(filters, outputPath) {
  const entries = await getAuditLogs(filters);
  const headers = [
    "ID",
    "Timestamp",
    "Entity",
    "Entity ID",
    "Action",
    "User ID",
    "User Name",
    "Details"
  ];
  const rows = entries.map((entry) => [
    entry.id.toString(),
    entry.timestamp,
    entry.entity,
    entry.entityId?.toString() || "",
    entry.action,
    entry.userId?.toString() || "",
    entry.userName || "",
    entry.details ? JSON.stringify(entry.details) : ""
  ]);
  const csvContent = [
    headers.join(","),
    ...rows.map((row) => row.map((cell) => `"${cell}"`).join(","))
  ].join("\n");
  const finalPath = outputPath || path13.join(
    import_electron11.app.getPath("documents"),
    `Audit_Log_${filters.fromDate || "all"}_to_${filters.toDate || "all"}.csv`
  );
  const dir = path13.dirname(finalPath);
  if (!fs12.existsSync(dir)) {
    fs12.mkdirSync(dir, { recursive: true });
  }
  fs12.writeFileSync(finalPath, csvContent, "utf-8");
  logger.info(`Audit log CSV exported to: ${finalPath}`);
  return finalPath;
}
async function exportAuditLogJSON(filters, outputPath) {
  const entries = await getAuditLogs(filters);
  const finalPath = outputPath || path13.join(
    import_electron11.app.getPath("documents"),
    `Audit_Log_${filters.fromDate || "all"}_to_${filters.toDate || "all"}.json`
  );
  const dir = path13.dirname(finalPath);
  if (!fs12.existsSync(dir)) {
    fs12.mkdirSync(dir, { recursive: true });
  }
  fs12.writeFileSync(finalPath, JSON.stringify(entries, null, 2), "utf-8");
  logger.info(`Audit log JSON exported to: ${finalPath}`);
  return finalPath;
}
var fs12, path13, import_electron11;
var init_auditExportService = __esm({
  "electron/src/services/auditExportService.ts"() {
    "use strict";
    init_prismaClient();
    fs12 = __toESM(require("fs"));
    path13 = __toESM(require("path"));
    import_electron11 = require("electron");
    init_logger();
  }
});

// electron/src/services/outstandingService.ts
var outstandingService_exports = {};
__export(outstandingService_exports, {
  autoReconcileAllBills: () => autoReconcileAllBills,
  canDeleteBill: () => canDeleteBill,
  getCustomerOutstanding: () => getCustomerOutstanding,
  getOutstandingBills: () => getOutstandingBills,
  getSupplierOutstanding: () => getSupplierOutstanding,
  reconcileBillOutstanding: () => reconcileBillOutstanding,
  validateOutstanding: () => validateOutstanding
});
function calculateDaysOverdue(billDate, dueDate) {
  const referenceDate = dueDate || billDate;
  const now = /* @__PURE__ */ new Date();
  const diffTime = now.getTime() - referenceDate.getTime();
  return Math.max(0, Math.floor(diffTime / (1e3 * 60 * 60 * 24)));
}
function calculateAging(outstanding, daysOverdue) {
  if (outstanding <= 0) {
    return { current: 0, days30: 0, days60: 0, days90: 0, total: 0 };
  }
  if (daysOverdue <= 30) {
    return { current: outstanding, days30: 0, days60: 0, days90: 0, total: outstanding };
  } else if (daysOverdue <= 60) {
    return { current: 0, days30: outstanding, days60: 0, days90: 0, total: outstanding };
  } else if (daysOverdue <= 90) {
    return { current: 0, days30: 0, days60: outstanding, days90: 0, total: outstanding };
  } else {
    return { current: 0, days30: 0, days60: 0, days90: outstanding, total: outstanding };
  }
}
async function getOutstandingBills(filters) {
  const prisma2 = getPrismaClient();
  const bills = await prisma2.bill.findMany({
    where: {
      status: "FINALIZED",
      ...filters?.billType && { billType: filters.billType },
      ...filters?.customerId && { customerId: filters.customerId },
      ...filters?.supplierId && { supplierId: filters.supplierId },
      ...filters?.includePaid !== true && {
        paymentStatus: { in: ["UNPAID", "PARTIAL"] }
      }
    },
    include: {
      customer: true,
      supplier: true
    },
    orderBy: {
      billDate: "asc"
    }
  });
  return bills.map((bill) => {
    const totalAmount = toNumber12(bill.totalAmount);
    const paidAmount = toNumber12(bill.paidAmount);
    const outstanding = Math.max(0, totalAmount - paidAmount);
    const daysOverdue = calculateDaysOverdue(bill.billDate, bill.dueDate);
    const aging = calculateAging(outstanding, daysOverdue);
    return {
      billId: bill.id,
      billNumber: bill.billNumber,
      billType: bill.billType,
      billDate: bill.billDate,
      dueDate: bill.dueDate,
      customerId: bill.customerId ?? void 0,
      customerName: bill.customerName || bill.customer?.name,
      supplierId: bill.supplierId ?? void 0,
      supplierName: bill.supplierName || bill.supplier?.name,
      totalAmount,
      paidAmount,
      outstanding,
      daysOverdue,
      aging,
      paymentStatus: bill.paymentStatus
    };
  });
}
async function getCustomerOutstanding(filters) {
  const bills = await getOutstandingBills({
    billType: "SALES",
    customerId: filters?.customerId,
    includePaid: filters?.includePaid
  });
  const customerMap = /* @__PURE__ */ new Map();
  bills.forEach((bill) => {
    if (!bill.customerId) return;
    const existing = customerMap.get(bill.customerId);
    if (existing) {
      existing.bills.push(bill);
    } else {
      customerMap.set(bill.customerId, {
        customerName: bill.customerName || "Unknown",
        bills: [bill]
      });
    }
  });
  return Array.from(customerMap.entries()).map(([customerId, data]) => {
    const totalOutstanding = data.bills.reduce((sum, b) => sum + b.outstanding, 0);
    const aging = data.bills.reduce(
      (acc, bill) => ({
        current: acc.current + bill.aging.current,
        days30: acc.days30 + bill.aging.days30,
        days60: acc.days60 + bill.aging.days60,
        days90: acc.days90 + bill.aging.days90,
        total: acc.total + bill.aging.total
      }),
      { current: 0, days30: 0, days60: 0, days90: 0, total: 0 }
    );
    return {
      customerId,
      customerName: data.customerName,
      totalOutstanding,
      billCount: data.bills.length,
      aging,
      bills: data.bills.sort((a, b) => b.daysOverdue - a.daysOverdue)
    };
  }).sort((a, b) => b.totalOutstanding - a.totalOutstanding);
}
async function getSupplierOutstanding(filters) {
  const bills = await getOutstandingBills({
    billType: "PURCHASE",
    supplierId: filters?.supplierId,
    includePaid: filters?.includePaid
  });
  const supplierMap = /* @__PURE__ */ new Map();
  bills.forEach((bill) => {
    if (!bill.supplierId) return;
    const existing = supplierMap.get(bill.supplierId);
    if (existing) {
      existing.bills.push(bill);
    } else {
      supplierMap.set(bill.supplierId, {
        supplierName: bill.supplierName || "Unknown",
        bills: [bill]
      });
    }
  });
  return Array.from(supplierMap.entries()).map(([supplierId, data]) => {
    const totalOutstanding = data.bills.reduce((sum, b) => sum + b.outstanding, 0);
    const aging = data.bills.reduce(
      (acc, bill) => ({
        current: acc.current + bill.aging.current,
        days30: acc.days30 + bill.aging.days30,
        days60: acc.days60 + bill.aging.days60,
        days90: acc.days90 + bill.aging.days90,
        total: acc.total + bill.aging.total
      }),
      { current: 0, days30: 0, days60: 0, days90: 0, total: 0 }
    );
    return {
      supplierId,
      supplierName: data.supplierName,
      totalOutstanding,
      billCount: data.bills.length,
      aging,
      bills: data.bills.sort((a, b) => b.daysOverdue - a.daysOverdue)
    };
  }).sort((a, b) => b.totalOutstanding - a.totalOutstanding);
}
async function validateOutstanding(billId) {
  const prisma2 = getPrismaClient();
  const bill = await prisma2.bill.findUnique({
    where: { id: billId },
    select: {
      totalAmount: true,
      paidAmount: true
    }
  });
  if (!bill) {
    return {
      valid: false,
      outstanding: 0,
      totalAmount: 0,
      paidAmount: 0,
      error: "Bill not found"
    };
  }
  const totalAmount = toNumber12(bill.totalAmount);
  const paidAmount = toNumber12(bill.paidAmount);
  const outstanding = totalAmount - paidAmount;
  if (outstanding < 0) {
    return {
      valid: false,
      outstanding,
      totalAmount,
      paidAmount,
      error: `Negative outstanding detected: ${outstanding}. Paid amount (${paidAmount}) exceeds total (${totalAmount})`
    };
  }
  return {
    valid: true,
    outstanding,
    totalAmount,
    paidAmount
  };
}
async function reconcileBillOutstanding(billId) {
  const prisma2 = getPrismaClient();
  return prisma2.$transaction(
    async (tx) => {
      const bill = await tx.bill.findUnique({
        where: { id: billId },
        include: {
          payments: true
        }
      });
      if (!bill) {
        throw new Error("Bill not found");
      }
      const actualPaid = bill.payments.filter((p) => {
        if (p.paymentMethod !== "CHEQUE") return true;
        if (p.isCleared === true) return true;
        if (p.bouncedDate) return false;
        return false;
      }).reduce((sum, p) => sum + toNumber12(p.amount), 0);
      const totalAmount = toNumber12(bill.totalAmount);
      const oldPaid = toNumber12(bill.paidAmount);
      const newOutstanding = Math.max(0, totalAmount - actualPaid);
      const oldOutstanding = Math.max(0, totalAmount - oldPaid);
      const reconciled = Math.abs(oldPaid - actualPaid) > 0.01;
      if (reconciled) {
        const paymentStatus = actualPaid >= totalAmount ? "PAID" : actualPaid > 0 ? "PARTIAL" : "UNPAID";
        await tx.bill.update({
          where: { id: billId },
          data: {
            paidAmount: new import_client20.Prisma.Decimal(actualPaid),
            paymentStatus
          }
        });
      }
      return {
        reconciled,
        oldOutstanding,
        newOutstanding,
        difference: newOutstanding - oldOutstanding
      };
    },
    { timeout: 1e4 }
  );
}
async function autoReconcileAllBills() {
  const prisma2 = getPrismaClient();
  const errors = [];
  let reconciled = 0;
  const bills = await prisma2.bill.findMany({
    where: {
      status: "FINALIZED"
    },
    select: { id: true }
  });
  for (const bill of bills) {
    try {
      const result = await reconcileBillOutstanding(bill.id);
      if (result.reconciled) {
        reconciled++;
      }
    } catch (error) {
      errors.push(
        `Failed to reconcile bill ${bill.id}: ${error instanceof Error ? error.message : "Unknown error"}`
      );
    }
  }
  return {
    totalBills: bills.length,
    reconciled,
    errors
  };
}
async function canDeleteBill(billId) {
  const prisma2 = getPrismaClient();
  const bill = await prisma2.bill.findUnique({
    where: { id: billId },
    include: {
      payments: true
    }
  });
  if (!bill) {
    return {
      canDelete: false,
      reason: "Bill not found",
      paymentCount: 0
    };
  }
  const paymentCount = bill.payments.length;
  if (paymentCount > 0) {
    return {
      canDelete: false,
      reason: `Cannot delete bill with ${paymentCount} payment(s). Delete payments first.`,
      paymentCount
    };
  }
  return {
    canDelete: true,
    paymentCount: 0
  };
}
var import_client20, toNumber12;
var init_outstandingService = __esm({
  "electron/src/services/outstandingService.ts"() {
    "use strict";
    import_client20 = require("@prisma/client");
    init_prismaClient();
    toNumber12 = (value) => {
      if (value instanceof import_client20.Prisma.Decimal) return value.toNumber();
      return Number(value ?? 0);
    };
  }
});

// electron/src/services/consistencyScannerService.ts
var consistencyScannerService_exports = {};
__export(consistencyScannerService_exports, {
  autoFixAllIssues: () => autoFixAllIssues,
  fixConsistencyIssue: () => fixConsistencyIssue,
  runConsistencyScan: () => runConsistencyScan,
  scanLedgerInconsistencies: () => scanLedgerInconsistencies,
  scanOrphanBatches: () => scanOrphanBatches,
  scanOrphanPayments: () => scanOrphanPayments,
  scanPaymentMismatches: () => scanPaymentMismatches,
  scanStockMismatches: () => scanStockMismatches
});
async function scanStockMismatches() {
  const prisma2 = getPrismaClient();
  const issues = [];
  const batches = await prisma2.batch.findMany({
    where: { quantity: { gt: 0 } },
    include: {
      product: {
        select: { name: true }
      }
    }
  });
  for (const batch of batches) {
    const validation = await validateBatchConsistency(batch.id);
    if (!validation.consistent) {
      issues.push({
        type: "STOCK_MISMATCH",
        severity: Math.abs(validation.difference) > 10 ? "HIGH" : "MEDIUM",
        entity: "Batch",
        entityId: batch.id,
        description: `Stock mismatch for batch ${batch.batchNumber} (${batch.product.name})`,
        currentValue: validation.batchQuantity,
        expectedValue: validation.ledgerQuantity,
        difference: validation.difference,
        fixable: true,
        fixSuggestion: `Reconcile batch quantity from ${validation.batchQuantity} to ${validation.ledgerQuantity}`,
        fixAction: "reconcileBatch"
      });
    }
  }
  return issues;
}
async function scanOrphanBatches() {
  const prisma2 = getPrismaClient();
  const issues = [];
  const batches = await prisma2.batch.findMany({
    include: {
      product: true
    }
  });
  for (const batch of batches) {
    if (!batch.product) {
      issues.push({
        type: "ORPHAN_BATCH",
        severity: "HIGH",
        entity: "Batch",
        entityId: batch.id,
        description: `Orphan batch ${batch.batchNumber} - product ${batch.productId} not found`,
        currentValue: batch.productId,
        expectedValue: null,
        fixable: false,
        fixSuggestion: `Delete batch ${batch.batchNumber} or assign to valid product`
      });
    }
  }
  return issues;
}
async function scanPaymentMismatches() {
  const prisma2 = getPrismaClient();
  const issues = [];
  const bills = await prisma2.bill.findMany({
    where: {
      status: "FINALIZED"
    },
    include: {
      payments: true
    }
  });
  for (const bill of bills) {
    const actualPaid = bill.payments.filter((p) => {
      if (p.paymentMethod !== "CHEQUE") return true;
      if (p.isCleared === true) return true;
      if (p.bouncedDate) return false;
      return false;
    }).reduce((sum, p) => sum + Number(p.amount), 0);
    const recordedPaid = Number(bill.paidAmount);
    const difference = Math.abs(actualPaid - recordedPaid);
    if (difference > 0.01) {
      issues.push({
        type: "PAYMENT_MISMATCH",
        severity: difference > 100 ? "HIGH" : "MEDIUM",
        entity: "Bill",
        entityId: bill.id,
        description: `Payment mismatch for bill ${bill.billNumber}`,
        currentValue: recordedPaid,
        expectedValue: actualPaid,
        difference,
        fixable: true,
        fixSuggestion: `Reconcile paid amount from \u20B9${recordedPaid.toFixed(2)} to \u20B9${actualPaid.toFixed(2)}`,
        fixAction: "reconcileBill"
      });
    }
  }
  return issues;
}
async function scanLedgerInconsistencies() {
  const prisma2 = getPrismaClient();
  const issues = [];
  const ledgerEntries = await prisma2.stockLedger.findMany({
    include: {
      product: true,
      batch: true
    }
  });
  for (const entry of ledgerEntries) {
    if (!entry.product) {
      issues.push({
        type: "LEDGER_INCONSISTENCY",
        severity: "HIGH",
        entity: "StockLedger",
        entityId: entry.id,
        description: `Ledger entry references invalid product ${entry.productId}`,
        currentValue: entry.productId,
        expectedValue: null,
        fixable: false,
        fixSuggestion: `Delete or fix ledger entry ${entry.id}`
      });
    }
    if (entry.batchId && !entry.batch) {
      issues.push({
        type: "LEDGER_INCONSISTENCY",
        severity: "HIGH",
        entity: "StockLedger",
        entityId: entry.id,
        description: `Ledger entry references invalid batch ${entry.batchId}`,
        currentValue: entry.batchId,
        expectedValue: null,
        fixable: false,
        fixSuggestion: `Fix or delete ledger entry ${entry.id}`
      });
    }
    if (entry.batchId && entry.batch && entry.batch.productId !== entry.productId) {
      issues.push({
        type: "LEDGER_INCONSISTENCY",
        severity: "CRITICAL",
        entity: "StockLedger",
        entityId: entry.id,
        description: `Ledger entry: batch ${entry.batchId} does not belong to product ${entry.productId}`,
        currentValue: { productId: entry.productId, batchProductId: entry.batch.productId },
        expectedValue: { productId: entry.productId, batchProductId: entry.productId },
        fixable: false,
        fixSuggestion: `Fix product/batch mismatch in ledger entry ${entry.id}`
      });
    }
  }
  return issues;
}
async function scanOrphanPayments() {
  const prisma2 = getPrismaClient();
  const issues = [];
  const payments = await prisma2.billPayment.findMany({
    include: {
      bill: true
    }
  });
  for (const payment of payments) {
    if (!payment.bill) {
      issues.push({
        type: "ORPHAN_PAYMENT",
        severity: "HIGH",
        entity: "BillPayment",
        entityId: payment.id,
        description: `Orphan payment - bill ${payment.billId} not found`,
        currentValue: payment.billId,
        expectedValue: null,
        fixable: false,
        fixSuggestion: `Delete payment ${payment.id} or assign to valid bill`
      });
    }
  }
  return issues;
}
async function runConsistencyScan() {
  const [
    stockMismatches,
    orphanBatches,
    paymentMismatches,
    ledgerInconsistencies,
    orphanPayments
  ] = await Promise.all([
    scanStockMismatches(),
    scanOrphanBatches(),
    scanPaymentMismatches(),
    scanLedgerInconsistencies(),
    scanOrphanPayments()
  ]);
  const allIssues = [
    ...stockMismatches,
    ...orphanBatches,
    ...paymentMismatches,
    ...ledgerInconsistencies,
    ...orphanPayments
  ];
  const criticalIssues = allIssues.filter((i) => i.severity === "CRITICAL");
  const fixableIssues = allIssues.filter((i) => i.fixable);
  return {
    totalIssues: allIssues.length,
    criticalIssues: criticalIssues.length,
    fixableIssues: fixableIssues.length,
    issues: allIssues.sort((a, b) => {
      const severityOrder = { CRITICAL: 4, HIGH: 3, MEDIUM: 2, LOW: 1 };
      return severityOrder[b.severity] - severityOrder[a.severity];
    }),
    summary: {
      stockMismatches: stockMismatches.length,
      orphanBatches: orphanBatches.length,
      paymentMismatches: paymentMismatches.length,
      ledgerInconsistencies: ledgerInconsistencies.length,
      orphanPayments: orphanPayments.length
    }
  };
}
async function fixConsistencyIssue(issue, userId) {
  try {
    switch (issue.type) {
      case "STOCK_MISMATCH":
        if (issue.fixAction === "reconcileBatch") {
          const result = await reconcileBatchQuantity(issue.entityId);
          return {
            success: true,
            message: `Reconciled batch ${issue.entityId}. Old: ${result.oldQuantity}, New: ${result.newQuantity}`
          };
        }
        break;
      case "PAYMENT_MISMATCH":
        if (issue.fixAction === "reconcileBill") {
          const result = await reconcileBillOutstanding(issue.entityId);
          return {
            success: true,
            message: `Reconciled bill ${issue.entityId}. Old outstanding: ${result.oldOutstanding}, New: ${result.newOutstanding}`
          };
        }
        break;
      default:
        return {
          success: false,
          message: "This issue cannot be automatically fixed",
          error: "No fix action available"
        };
    }
    return {
      success: false,
      message: "Fix action not implemented",
      error: "Unknown fix action"
    };
  } catch (error) {
    return {
      success: false,
      message: "Failed to fix issue",
      error: error instanceof Error ? error.message : "Unknown error"
    };
  }
}
async function autoFixAllIssues(userId) {
  const scanResult = await runConsistencyScan();
  const fixableIssues = scanResult.issues.filter((i) => i.fixable);
  const results = [];
  let totalFixed = 0;
  let totalFailed = 0;
  for (const issue of fixableIssues) {
    const result = await fixConsistencyIssue(issue, userId);
    results.push({
      issue,
      success: result.success,
      message: result.message
    });
    if (result.success) {
      totalFixed++;
    } else {
      totalFailed++;
    }
  }
  return {
    totalFixed,
    totalFailed,
    results
  };
}
var init_consistencyScannerService = __esm({
  "electron/src/services/consistencyScannerService.ts"() {
    "use strict";
    init_prismaClient();
    init_stockLedgerService();
    init_outstandingService();
  }
});

// electron/src/services/mrPerformanceService.ts
var mrPerformanceService_exports = {};
__export(mrPerformanceService_exports, {
  getMRPerformanceReport: () => getMRPerformanceReport
});
async function getMRPerformanceReport(filters) {
  const prisma2 = getPrismaClient();
  const whereClause = {
    billType: "SALES",
    status: "FINALIZED",
    mrId: { not: null }
  };
  if (filters?.fromDate || filters?.toDate) {
    whereClause.billDate = {};
    if (filters.fromDate) {
      whereClause.billDate.gte = new Date(filters.fromDate);
    }
    if (filters.toDate) {
      const toDate = new Date(filters.toDate);
      toDate.setHours(23, 59, 59, 999);
      whereClause.billDate.lte = toDate;
    }
  }
  if (filters?.mrId) {
    whereClause.mrId = filters.mrId;
  }
  const bills = await prisma2.bill.findMany({
    where: whereClause,
    include: {
      mr: {
        select: {
          id: true,
          name: true,
          code: true
        }
      },
      customer: {
        select: { id: true }
      },
      lines: {
        select: {
          productId: true,
          quantity: true,
          lineTotal: true
        }
      }
    }
  });
  const mrMap = /* @__PURE__ */ new Map();
  for (const bill of bills) {
    if (!bill.mrId || !bill.mr) continue;
    const existing = mrMap.get(bill.mrId);
    if (existing) {
      existing.bills.push(bill);
      if (bill.customerId) {
        existing.customers.add(bill.customerId);
      }
      bill.lines.forEach((line) => {
        existing.products.add(line.productId);
      });
    } else {
      const customers = /* @__PURE__ */ new Set();
      const products = /* @__PURE__ */ new Set();
      if (bill.customerId) {
        customers.add(bill.customerId);
      }
      bill.lines.forEach((line) => {
        products.add(line.productId);
      });
      mrMap.set(bill.mrId, {
        mrId: bill.mr.id,
        mrName: bill.mr.name,
        mrCode: bill.mr.code ?? void 0,
        bills: [bill],
        customers,
        products
      });
    }
  }
  const byMR = Array.from(mrMap.values()).map((data) => {
    const totalSales2 = data.bills.reduce((sum, b) => sum + Number(b.totalAmount), 0);
    const totalQuantity = data.bills.reduce(
      (sum, b) => sum + b.lines.reduce((lineSum, line) => lineSum + line.quantity, 0),
      0
    );
    const billCount = data.bills.length;
    const averageBillValue = billCount > 0 ? totalSales2 / billCount : 0;
    return {
      mrId: data.mrId,
      mrName: data.mrName,
      mrCode: data.mrCode,
      billCount,
      totalSales: totalSales2,
      averageBillValue,
      totalQuantity,
      uniqueCustomers: data.customers.size,
      uniqueProducts: data.products.size
    };
  }).sort((a, b) => b.totalSales - a.totalSales);
  const totalMRs = byMR.length;
  const totalBills = byMR.reduce((sum, m) => sum + m.billCount, 0);
  const totalSales = byMR.reduce((sum, m) => sum + m.totalSales, 0);
  const averageSalesPerMR = totalMRs > 0 ? totalSales / totalMRs : 0;
  return {
    summary: {
      totalMRs,
      totalBills,
      totalSales,
      averageSalesPerMR
    },
    byMR
  };
}
var init_mrPerformanceService = __esm({
  "electron/src/services/mrPerformanceService.ts"() {
    "use strict";
    init_prismaClient();
  }
});

// electron/src/services/doctorROIService.ts
var doctorROIService_exports = {};
__export(doctorROIService_exports, {
  getDoctorROIReport: () => getDoctorROIReport
});
async function getDoctorROIReport(filters) {
  const prisma2 = getPrismaClient();
  const whereClause = {
    billType: "SALES",
    status: "FINALIZED",
    doctorId: { not: null }
  };
  if (filters?.fromDate || filters?.toDate) {
    whereClause.billDate = {};
    if (filters.fromDate) {
      whereClause.billDate.gte = new Date(filters.fromDate);
    }
    if (filters.toDate) {
      const toDate = new Date(filters.toDate);
      toDate.setHours(23, 59, 59, 999);
      whereClause.billDate.lte = toDate;
    }
  }
  if (filters?.doctorId) {
    whereClause.doctorId = filters.doctorId;
  }
  const bills = await prisma2.bill.findMany({
    where: whereClause,
    include: {
      doctor: {
        select: {
          id: true,
          name: true,
          code: true
        }
      },
      lines: {
        select: {
          productId: true,
          quantity: true,
          lineTotal: true
        }
      }
    }
  });
  const doctorMap = /* @__PURE__ */ new Map();
  for (const bill of bills) {
    if (!bill.doctorId || !bill.doctor) continue;
    const existing = doctorMap.get(bill.doctorId);
    if (existing) {
      existing.bills.push(bill);
      bill.lines.forEach((line) => {
        existing.products.add(line.productId);
      });
    } else {
      const products = /* @__PURE__ */ new Set();
      bill.lines.forEach((line) => {
        products.add(line.productId);
      });
      doctorMap.set(bill.doctorId, {
        doctorId: bill.doctor.id,
        doctorName: bill.doctor.name,
        doctorCode: bill.doctor.code ?? void 0,
        bills: [bill],
        products
      });
    }
  }
  const byDoctor = Array.from(doctorMap.values()).map((data) => {
    const totalSales2 = data.bills.reduce((sum, b) => sum + Number(b.totalAmount), 0);
    const totalQuantity = data.bills.reduce(
      (sum, b) => sum + b.lines.reduce((lineSum, line) => lineSum + line.quantity, 0),
      0
    );
    const billCount = data.bills.length;
    const averageBillValue = billCount > 0 ? totalSales2 / billCount : 0;
    const prescriptionValue = totalSales2;
    return {
      doctorId: data.doctorId,
      doctorName: data.doctorName,
      doctorCode: data.doctorCode,
      billCount,
      totalSales: totalSales2,
      averageBillValue,
      totalQuantity,
      uniqueProducts: data.products.size,
      prescriptionValue
    };
  }).sort((a, b) => b.totalSales - a.totalSales);
  const totalDoctors = byDoctor.length;
  const totalBills = byDoctor.reduce((sum, d) => sum + d.billCount, 0);
  const totalSales = byDoctor.reduce((sum, d) => sum + d.totalSales, 0);
  const averageSalesPerDoctor = totalDoctors > 0 ? totalSales / totalDoctors : 0;
  const totalPrescriptionValue = totalSales;
  return {
    summary: {
      totalDoctors,
      totalBills,
      totalSales,
      averageSalesPerDoctor,
      totalPrescriptionValue
    },
    byDoctor
  };
}
var init_doctorROIService = __esm({
  "electron/src/services/doctorROIService.ts"() {
    "use strict";
    init_prismaClient();
  }
});

// electron/src/services/deadStockService.ts
var deadStockService_exports = {};
__export(deadStockService_exports, {
  getDeadStock: () => getDeadStock,
  getExpiryIntelligenceReport: () => getExpiryIntelligenceReport,
  getExpiryLossAccounting: () => getExpiryLossAccounting,
  getNearExpiryStock: () => getNearExpiryStock
});
async function getDeadStock(filters) {
  const prisma2 = getPrismaClient();
  const minDays = filters?.minDays || DEAD_STOCK_DAYS;
  const batches = await prisma2.batch.findMany({
    where: {
      quantity: { gt: 0 },
      ...filters?.productId && { productId: filters.productId }
    },
    include: {
      product: {
        include: {
          category: true
        }
      },
      stockLedgers: {
        orderBy: { createdAt: "desc" },
        take: 1,
        select: { createdAt: true }
      }
    },
    ...filters?.categoryId && {
      where: {
        product: {
          categoryId: filters.categoryId
        }
      }
    }
  });
  const now = /* @__PURE__ */ new Date();
  const deadStock = [];
  const slowMoving = [];
  for (const batch of batches) {
    const lastMovement = batch.stockLedgers[0]?.createdAt || null;
    const daysSinceLastMovement = lastMovement ? Math.floor((now.getTime() - lastMovement.getTime()) / (1e3 * 60 * 60 * 24)) : Infinity;
    const stockValue = Number(batch.ptr) * batch.quantity;
    const item = {
      batchId: batch.id,
      batchNumber: batch.batchNumber,
      productId: batch.productId,
      productName: batch.product.name,
      quantity: batch.quantity,
      lastMovementDate: lastMovement,
      daysSinceLastMovement,
      stockValue,
      mrp: Number(batch.mrp),
      ptr: Number(batch.ptr),
      category: daysSinceLastMovement >= minDays ? "DEAD" : "SLOW_MOVING"
    };
    if (daysSinceLastMovement >= minDays) {
      deadStock.push(item);
    } else if (daysSinceLastMovement >= SLOW_MOVING_DAYS) {
      slowMoving.push(item);
    }
  }
  const totalDeadStockValue = deadStock.reduce((sum, item) => sum + item.stockValue, 0);
  const totalSlowMovingValue = slowMoving.reduce((sum, item) => sum + item.stockValue, 0);
  return {
    deadStock: deadStock.sort((a, b) => b.daysSinceLastMovement - a.daysSinceLastMovement),
    slowMoving: slowMoving.sort((a, b) => b.daysSinceLastMovement - a.daysSinceLastMovement),
    totalDeadStockValue,
    totalSlowMovingValue
  };
}
async function getNearExpiryStock(filters) {
  const prisma2 = getPrismaClient();
  const thresholdDays = filters?.thresholdDays || NEAR_EXPIRY_DAYS3;
  const includeExpired = filters?.includeExpired ?? true;
  const now = /* @__PURE__ */ new Date();
  const thresholdDate = new Date(now);
  thresholdDate.setDate(thresholdDate.getDate() + thresholdDays);
  const batches = await prisma2.batch.findMany({
    where: {
      quantity: { gt: 0 },
      expiryDate: {
        ...includeExpired ? { lte: thresholdDate } : { lte: thresholdDate, gt: now }
      },
      ...filters?.productId && { productId: filters.productId }
    },
    include: {
      product: {
        select: { name: true }
      },
      expiryReturns: {
        select: {
          quantity: true,
          lossAmount: true
        }
      }
    },
    orderBy: {
      expiryDate: "asc"
    }
  });
  const critical = [];
  const nearExpiry = [];
  const expired = [];
  for (const batch of batches) {
    const daysUntil = getDaysUntilExpiry(batch.expiryDate);
    const stockValue = Number(batch.ptr) * batch.quantity;
    const isExpired = isBatchExpired(batch.expiryDate);
    if (isExpired) {
      const returnedQuantity = batch.expiryReturns.reduce((sum, ret) => sum + ret.quantity, 0);
      const returnedLoss = batch.expiryReturns.reduce(
        (sum, ret) => sum + Number(ret.lossAmount),
        0
      );
      const remainingQuantity = batch.quantity - returnedQuantity;
      const estimatedLoss = remainingQuantity > 0 && returnedQuantity > 0 ? returnedLoss / returnedQuantity * remainingQuantity : stockValue;
      expired.push({
        batchId: batch.id,
        batchNumber: batch.batchNumber,
        productId: batch.productId,
        productName: batch.product.name,
        quantity: batch.quantity,
        expiryDate: batch.expiryDate,
        daysExpired: Math.abs(daysUntil),
        stockValue,
        lossAmount: returnedLoss + estimatedLoss,
        mrp: Number(batch.mrp),
        ptr: Number(batch.ptr)
      });
    } else {
      const item = {
        batchId: batch.id,
        batchNumber: batch.batchNumber,
        productId: batch.productId,
        productName: batch.product.name,
        quantity: batch.quantity,
        expiryDate: batch.expiryDate,
        daysUntilExpiry: daysUntil,
        stockValue,
        mrp: Number(batch.mrp),
        ptr: Number(batch.ptr),
        category: daysUntil <= CRITICAL_EXPIRY_DAYS2 ? "CRITICAL" : "NEAR_EXPIRY"
      };
      if (daysUntil <= CRITICAL_EXPIRY_DAYS2) {
        critical.push(item);
      } else {
        nearExpiry.push(item);
      }
    }
  }
  const totalCriticalValue = critical.reduce((sum, item) => sum + item.stockValue, 0);
  const totalNearExpiryValue = nearExpiry.reduce((sum, item) => sum + item.stockValue, 0);
  const totalExpiredValue = expired.reduce((sum, item) => sum + item.stockValue, 0);
  const totalExpiredLoss = expired.reduce((sum, item) => sum + item.lossAmount, 0);
  return {
    critical,
    nearExpiry,
    expired,
    totalCriticalValue,
    totalNearExpiryValue,
    totalExpiredValue,
    totalExpiredLoss
  };
}
async function getExpiryIntelligenceReport(filters) {
  const [deadStockData, nearExpiryData] = await Promise.all([
    getDeadStock(filters),
    getNearExpiryStock({ ...filters, includeExpired: true })
  ]);
  const prisma2 = getPrismaClient();
  const allBatches = await prisma2.batch.findMany({
    where: {
      quantity: { gt: 0 },
      ...filters?.productId && { productId: filters.productId }
    },
    include: {
      product: {
        include: {
          category: true
        }
      }
    }
  });
  const totalStockValue = allBatches.reduce(
    (sum, batch) => sum + Number(batch.ptr) * batch.quantity,
    0
  );
  const productMap = /* @__PURE__ */ new Map();
  deadStockData.deadStock.forEach((item) => {
    const existing = productMap.get(item.productId) || {
      productName: item.productName,
      deadStockValue: 0,
      nearExpiryValue: 0,
      expiredValue: 0
    };
    existing.deadStockValue += item.stockValue;
    productMap.set(item.productId, existing);
  });
  nearExpiryData.nearExpiry.forEach((item) => {
    const existing = productMap.get(item.productId) || {
      productName: item.productName,
      deadStockValue: 0,
      nearExpiryValue: 0,
      expiredValue: 0
    };
    existing.nearExpiryValue += item.stockValue;
    productMap.set(item.productId, existing);
  });
  nearExpiryData.critical.forEach((item) => {
    const existing = productMap.get(item.productId) || {
      productName: item.productName,
      deadStockValue: 0,
      nearExpiryValue: 0,
      expiredValue: 0
    };
    existing.nearExpiryValue += item.stockValue;
    productMap.set(item.productId, existing);
  });
  nearExpiryData.expired.forEach((item) => {
    const existing = productMap.get(item.productId) || {
      productName: item.productName,
      deadStockValue: 0,
      nearExpiryValue: 0,
      expiredValue: 0
    };
    existing.expiredValue += item.stockValue;
    productMap.set(item.productId, existing);
  });
  const byProduct = Array.from(productMap.entries()).map(([productId, data]) => ({
    productId,
    productName: data.productName,
    deadStockValue: data.deadStockValue,
    nearExpiryValue: data.nearExpiryValue,
    expiredValue: data.expiredValue,
    totalRiskValue: data.deadStockValue + data.nearExpiryValue + data.expiredValue
  })).sort((a, b) => b.totalRiskValue - a.totalRiskValue);
  const categoryMap = /* @__PURE__ */ new Map();
  allBatches.forEach((batch) => {
    if (!batch.product.category) return;
    const categoryId = batch.product.category.id;
    const categoryName = batch.product.category.name;
    const stockValue = Number(batch.ptr) * batch.quantity;
    const existing = categoryMap.get(categoryId) || {
      categoryName,
      deadStockValue: 0,
      nearExpiryValue: 0,
      expiredValue: 0
    };
    const isDead = deadStockData.deadStock.some((d) => d.batchId === batch.id);
    const isNearExpiry3 = nearExpiryData.nearExpiry.some((n) => n.batchId === batch.id) || nearExpiryData.critical.some((c) => c.batchId === batch.id);
    const isExpired = nearExpiryData.expired.some((e) => e.batchId === batch.id);
    if (isDead) existing.deadStockValue += stockValue;
    if (isNearExpiry3) existing.nearExpiryValue += stockValue;
    if (isExpired) existing.expiredValue += stockValue;
    categoryMap.set(categoryId, existing);
  });
  const byCategory = Array.from(categoryMap.entries()).map(([categoryId, data]) => ({
    categoryId,
    categoryName: data.categoryName,
    deadStockValue: data.deadStockValue,
    nearExpiryValue: data.nearExpiryValue,
    expiredValue: data.expiredValue,
    totalRiskValue: data.deadStockValue + data.nearExpiryValue + data.expiredValue
  })).sort((a, b) => b.totalRiskValue - a.totalRiskValue);
  const totalRiskValue = deadStockData.totalDeadStockValue + nearExpiryData.totalNearExpiryValue + nearExpiryData.totalCriticalValue + nearExpiryData.totalExpiredValue;
  return {
    summary: {
      totalStockValue,
      deadStockValue: deadStockData.totalDeadStockValue,
      slowMovingValue: deadStockData.totalSlowMovingValue,
      nearExpiryValue: nearExpiryData.totalNearExpiryValue,
      criticalExpiryValue: nearExpiryData.totalCriticalValue,
      expiredValue: nearExpiryData.totalExpiredValue,
      expiredLoss: nearExpiryData.totalExpiredLoss,
      totalRiskValue
    },
    deadStock: deadStockData.deadStock,
    slowMoving: deadStockData.slowMoving,
    nearExpiry: nearExpiryData.nearExpiry,
    critical: nearExpiryData.critical,
    expired: nearExpiryData.expired,
    byProduct,
    byCategory
  };
}
async function getExpiryLossAccounting(filters) {
  const prisma2 = getPrismaClient();
  const returns = await prisma2.expiryReturn.findMany({
    where: {
      ...filters?.fromDate || filters?.toDate ? {
        returnDate: {
          ...filters.fromDate && { gte: new Date(filters.fromDate) },
          ...filters.toDate && { lte: new Date(filters.toDate) }
        }
      } : void 0,
      ...filters?.supplierId && { supplierId: filters.supplierId },
      ...filters?.productId && {
        batch: {
          productId: filters.productId
        }
      }
    },
    include: {
      supplier: true,
      batch: {
        include: {
          product: true
        }
      }
    },
    orderBy: {
      returnDate: "desc"
    }
  });
  let totalQuantity = 0;
  let totalLossAmount = 0;
  const supplierMap = /* @__PURE__ */ new Map();
  const productMap = /* @__PURE__ */ new Map();
  const monthMap = /* @__PURE__ */ new Map();
  returns.forEach((ret) => {
    totalQuantity += ret.quantity;
    totalLossAmount += Number(ret.lossAmount);
    if (ret.supplierId) {
      const supplierName = ret.supplier?.name ?? "Unknown";
      const existing2 = supplierMap.get(ret.supplierId);
      if (existing2) {
        existing2.count++;
        existing2.quantity += ret.quantity;
        existing2.lossAmount += Number(ret.lossAmount);
      } else {
        supplierMap.set(ret.supplierId, {
          name: supplierName,
          count: 1,
          quantity: ret.quantity,
          lossAmount: Number(ret.lossAmount)
        });
      }
    }
    const productId = ret.batch.product.id;
    const productName = ret.batch.product.name;
    const existing = productMap.get(productId);
    if (existing) {
      existing.count++;
      existing.quantity += ret.quantity;
      existing.lossAmount += Number(ret.lossAmount);
    } else {
      productMap.set(productId, {
        name: productName,
        count: 1,
        quantity: ret.quantity,
        lossAmount: Number(ret.lossAmount)
      });
    }
    const month = ret.returnDate.toISOString().substring(0, 7);
    const monthExisting = monthMap.get(month);
    if (monthExisting) {
      monthExisting.count++;
      monthExisting.quantity += ret.quantity;
      monthExisting.lossAmount += Number(ret.lossAmount);
    } else {
      monthMap.set(month, {
        count: 1,
        quantity: ret.quantity,
        lossAmount: Number(ret.lossAmount)
      });
    }
  });
  const averageLossPerUnit = totalQuantity > 0 ? totalLossAmount / totalQuantity : 0;
  return {
    totalReturns: returns.length,
    totalQuantity,
    totalLossAmount,
    averageLossPerUnit,
    bySupplier: Array.from(supplierMap.entries()).map(([id, data]) => ({
      supplierId: id,
      supplierName: data.name,
      returnCount: data.count,
      totalQuantity: data.quantity,
      totalLossAmount: data.lossAmount
    })),
    byProduct: Array.from(productMap.entries()).map(([id, data]) => ({
      productId: id,
      productName: data.name,
      returnCount: data.count,
      totalQuantity: data.quantity,
      totalLossAmount: data.lossAmount,
      averageLossPerUnit: data.quantity > 0 ? data.lossAmount / data.quantity : 0
    })),
    byMonth: Array.from(monthMap.entries()).map(([month, data]) => ({
      month,
      returnCount: data.count,
      totalQuantity: data.quantity,
      totalLossAmount: data.lossAmount
    })).sort((a, b) => b.month.localeCompare(a.month))
  };
}
var DEAD_STOCK_DAYS, SLOW_MOVING_DAYS, NEAR_EXPIRY_DAYS3, CRITICAL_EXPIRY_DAYS2;
var init_deadStockService = __esm({
  "electron/src/services/deadStockService.ts"() {
    "use strict";
    init_prismaClient();
    init_fefoService();
    DEAD_STOCK_DAYS = 180;
    SLOW_MOVING_DAYS = 90;
    NEAR_EXPIRY_DAYS3 = 30;
    CRITICAL_EXPIRY_DAYS2 = 7;
  }
});

// electron/src/services/templateInitializationService.ts
var templateInitializationService_exports = {};
__export(templateInitializationService_exports, {
  initializeTemplatesFromDisk: () => initializeTemplatesFromDisk
});
function scanTemplateFiles() {
  const templates = [];
  const templateDirs = [
    path14.join(process.cwd(), "templates"),
    path14.join(__dirname, "..", "templates"),
    import_electron12.app.isPackaged ? path14.join(import_electron12.app.getAppPath(), "templates") : null
  ].filter((p) => p !== null && fs13.existsSync(p));
  const seen = /* @__PURE__ */ new Set();
  for (const templateDir of templateDirs) {
    try {
      const files = fs13.readdirSync(templateDir);
      for (const file of files) {
        if (file.endsWith(".html") && !seen.has(file)) {
          const htmlPath = path14.join(templateDir, file);
          const cssPath = path14.join(templateDir, file.replace(".html", ".css"));
          let templateType = "A4";
          if (file.includes("thermal") || file.includes("80mm") || file.includes("3inch")) {
            templateType = "THERMAL_3INCH";
          }
          templates.push({
            name: file.replace(".html", ""),
            htmlPath,
            cssPath: fs13.existsSync(cssPath) ? cssPath : void 0,
            templateType
          });
          seen.add(file);
        }
      }
    } catch (error) {
      logger.warn(`Error scanning template directory ${templateDir}`, error);
    }
  }
  return templates;
}
async function initializeTemplatesFromDisk(userId) {
  const prisma2 = getPrismaClient();
  const templateFiles = scanTemplateFiles();
  let created = 0;
  let updated = 0;
  let skipped = 0;
  const errors = [];
  logger.info(`Scanning templates folder: Found ${templateFiles.length} template files`);
  for (const templateFile of templateFiles) {
    try {
      let htmlContent;
      let cssContent = "";
      try {
        htmlContent = fs13.readFileSync(templateFile.htmlPath, "utf-8");
      } catch (error) {
        errors.push(`Failed to read ${templateFile.htmlPath}: ${error instanceof Error ? error.message : "Unknown error"}`);
        continue;
      }
      if (templateFile.cssPath && fs13.existsSync(templateFile.cssPath)) {
        try {
          cssContent = fs13.readFileSync(templateFile.cssPath, "utf-8");
        } catch (error) {
          logger.warn(`CSS file read error for ${templateFile.name}, using empty CSS`);
        }
      } else {
        const altCssPath = templateFile.htmlPath.replace(".html", ".css");
        if (fs13.existsSync(altCssPath)) {
          try {
            cssContent = fs13.readFileSync(altCssPath, "utf-8");
          } catch (error) {
            logger.warn(`Alternative CSS file read error for ${templateFile.name}`);
          }
        }
      }
      const existing = await prisma2.billTemplate.findFirst({
        where: {
          name: templateFile.name,
          isActive: true
        }
      });
      if (existing) {
        const contentChanged = existing.htmlContent !== htmlContent || existing.cssContent !== cssContent;
        if (contentChanged) {
          await prisma2.billTemplate.update({
            where: { id: existing.id },
            data: {
              htmlContent,
              cssContent,
              updatedBy: userId ?? null
            }
          });
          updated++;
          logger.info(`Updated template: ${templateFile.name}`);
        } else {
          skipped++;
        }
      } else {
        const placeholders = getDefaultA4TemplatePlaceholders();
        const isDefault = templateFile.name === "default-a4-bill" || templateFile.templateType === "A4" && created === 0;
        await createBillTemplate({
          name: templateFile.name,
          description: `Template loaded from ${templateFile.htmlPath}`,
          templateType: templateFile.templateType,
          htmlContent,
          cssContent,
          placeholders,
          isDefault,
          editorMode: "LEGACY",
          // For legacy templates, treat file HTML as the generatedHtml source
          generatedHtml: htmlContent
        }, userId);
        created++;
        logger.info(`Created template: ${templateFile.name}`);
      }
    } catch (error) {
      const errorMsg = `Failed to initialize template ${templateFile.name}: ${error instanceof Error ? error.message : "Unknown error"}`;
      errors.push(errorMsg);
      logger.error(errorMsg, error);
    }
  }
  const defaultTemplate = await prisma2.billTemplate.findFirst({
    where: {
      isDefault: true,
      isActive: true
    }
  });
  if (!defaultTemplate) {
    const firstA4 = await prisma2.billTemplate.findFirst({
      where: {
        templateType: "A4",
        isActive: true
      },
      orderBy: { createdAt: "asc" }
    });
    if (firstA4) {
      await prisma2.billTemplate.update({
        where: { id: firstA4.id },
        data: { isDefault: true }
      });
      logger.info(`Set ${firstA4.name} as default template`);
    }
  }
  logger.info(`Template initialization complete: ${created} created, ${updated} updated, ${skipped} skipped, ${errors.length} errors`);
  return { created, updated, skipped, errors };
}
var fs13, path14, import_electron12;
var init_templateInitializationService = __esm({
  "electron/src/services/templateInitializationService.ts"() {
    "use strict";
    fs13 = __toESM(require("fs"));
    path14 = __toESM(require("path"));
    import_electron12 = require("electron");
    init_prismaClient();
    init_defaultTemplateLoader();
    init_logger();
    init_billTemplateService();
  }
});

// electron/main.ts
var import_electron14 = require("electron");
var import_node_path4 = __toESM(require("node:path"));
var import_node_url = __toESM(require("node:url"));

// electron/src/ipcHandlers/index.ts
var import_electron13 = require("electron");
init_errorHandler();
init_logger();

// electron/src/services/authService.ts
var import_bcryptjs = __toESM(require_bcryptjs());
init_prismaClient();
init_securityService();
var DEFAULT_ADMIN = {
  role: {
    name: "ADMIN",
    description: "System administrator"
  },
  user: {
    fullName: "Local Administrator",
    email: "admin@local",
    password: "Admin@123"
  }
};
var bootstrapRoles = async () => {
  const prisma2 = getPrismaClient();
  const requiredRoles = [
    { name: "ADMIN", description: "Full system access" },
    { name: "MANAGER", description: "Operations manager with full CRUD access" },
    { name: "ACCOUNTANT", description: "Financial operations and reporting" },
    { name: "SALES", description: "Sales operations and customer management" }
  ];
  await Promise.all(
    requiredRoles.map(
      (role) => prisma2.role.upsert({
        where: { name: role.name },
        update: {},
        create: role
      })
    )
  );
};
var ensureDefaultAdmin = async () => {
  const prisma2 = getPrismaClient();
  await bootstrapRoles();
  const adminRole = await prisma2.role.findUnique({
    where: { name: DEFAULT_ADMIN.role.name }
  });
  if (!adminRole) {
    throw new Error("Admin role missing during bootstrap");
  }
  const existingAdmin = await prisma2.user.findUnique({
    where: { email: DEFAULT_ADMIN.user.email }
  });
  const allAdminUsers = await prisma2.user.findMany({
    where: { roleId: adminRole.id }
  });
  if (!existingAdmin) {
    const hashedPassword = await import_bcryptjs.default.hash(DEFAULT_ADMIN.user.password, 10);
    await prisma2.user.create({
      data: {
        fullName: DEFAULT_ADMIN.user.fullName,
        email: DEFAULT_ADMIN.user.email,
        hashedPassword,
        roleId: adminRole.id
      }
    });
  } else {
    await prisma2.user.update({
      where: { id: existingAdmin.id },
      data: {
        isActive: true,
        roleId: adminRole.id
      }
    });
  }
  if (allAdminUsers.length > 1) {
    const adminUserIds = allAdminUsers.filter((u) => u.email !== DEFAULT_ADMIN.user.email).map((u) => u.id);
    if (adminUserIds.length > 0) {
      await prisma2.user.deleteMany({
        where: {
          id: { in: adminUserIds }
        }
      });
      console.log(`Removed ${adminUserIds.length} duplicate admin user(s). Only one admin user is allowed.`);
    }
  }
};
var authenticateUser = async ({
  username,
  password
}) => {
  if (isAccountLocked(username)) {
    const remainingSeconds = getRemainingLockTime(username);
    const remainingMinutes = Math.ceil(remainingSeconds / 60);
    throw new Error(
      `Account locked due to too many failed login attempts. Please try again in ${remainingMinutes} minute(s).`
    );
  }
  const prisma2 = getPrismaClient();
  const user = await prisma2.user.findUnique({
    where: { email: username },
    include: { role: true }
  });
  if (!user) {
    recordLoginAttempt(username, false);
    throw new Error("Invalid credentials");
  }
  if (!user.isActive) {
    recordLoginAttempt(username, false);
    throw new Error("User account is inactive");
  }
  const passwordMatch = await import_bcryptjs.default.compare(password, user.hashedPassword);
  if (!passwordMatch) {
    recordLoginAttempt(username, false);
    throw new Error("Invalid credentials");
  }
  recordLoginAttempt(username, true);
  trackSessionActivity(user.id);
  await prisma2.user.update({
    where: { id: user.id },
    data: { lastLoginAt: /* @__PURE__ */ new Date() }
  });
  return {
    token: Buffer.from(`${user.id}:${Date.now()}`).toString("base64"),
    displayName: user.fullName,
    role: user.role.name
  };
};
var getUserIdFromToken = (token) => {
  try {
    const decoded = Buffer.from(token, "base64").toString("utf-8");
    const [userId] = decoded.split(":");
    return userId ? parseInt(userId, 10) : null;
  } catch {
    return null;
  }
};

// electron/src/services/permissionService.ts
init_prismaClient();
var ROLE_PERMISSIONS = {
  ADMIN: [
    // Full access to everything
    "users.create",
    "users.update",
    "users.delete",
    "users.view",
    "bills.create",
    "bills.update",
    "bills.delete",
    "bills.finalize",
    "bills.cancel",
    "bills.view",
    "payments.create",
    "payments.update",
    "payments.delete",
    "payments.view",
    "products.create",
    "products.update",
    "products.delete",
    "products.view",
    "stock.adjust",
    "stock.transfer",
    "stock.view",
    "reports.view",
    "reports.export",
    "settings.company",
    "settings.templates",
    "settings.backup",
    "settings.users",
    "audit.override",
    "audit.view",
    "consistency.fix",
    "validation.override"
  ],
  MANAGER: [
    "users.view",
    "bills.create",
    "bills.update",
    "bills.finalize",
    "bills.cancel",
    "bills.view",
    "payments.create",
    "payments.update",
    "payments.view",
    "products.create",
    "products.update",
    "products.view",
    "stock.adjust",
    "stock.transfer",
    "stock.view",
    "reports.view",
    "reports.export",
    "settings.company",
    "settings.templates",
    "audit.view",
    "validation.override"
  ],
  ACCOUNTANT: [
    "bills.create",
    "bills.update",
    "bills.finalize",
    "bills.view",
    "payments.create",
    "payments.update",
    "payments.view",
    "products.view",
    "stock.view",
    "reports.view",
    "reports.export",
    "audit.view"
  ],
  SALES: [
    "bills.create",
    "bills.view",
    "payments.create",
    "payments.view",
    "products.view",
    "stock.view",
    "reports.view"
  ]
};
async function getUserRole(userId) {
  const prisma2 = getPrismaClient();
  const user = await prisma2.user.findUnique({
    where: { id: userId },
    include: { role: true }
  });
  if (!user || !user.role) {
    return null;
  }
  const roleName = user.role.name.toUpperCase();
  return roleName in ROLE_PERMISSIONS ? roleName : null;
}
async function hasPermission(userId, permission) {
  const roleName = await getUserRole(userId);
  if (!roleName) {
    return false;
  }
  const permissions = ROLE_PERMISSIONS[roleName];
  return permissions.includes(permission);
}
async function requirePermission(userId, permission, errorMessage) {
  const hasAccess = await hasPermission(userId, permission);
  if (!hasAccess) {
    throw new Error(
      errorMessage || `Permission denied: ${permission}`
    );
  }
}
async function isAdmin(userId) {
  const roleName = await getUserRole(userId);
  return roleName === "ADMIN";
}
async function requireAdmin(userId, errorMessage) {
  const admin = await isAdmin(userId);
  if (!admin) {
    throw new Error(errorMessage || "Admin access required");
  }
}

// electron/src/services/stockService.ts
var import_client2 = require("@prisma/client");
init_prismaClient();
var toNumber = (value) => {
  if (value instanceof import_client2.Prisma.Decimal) {
    return value.toNumber();
  }
  return Number(value ?? 0);
};
var getStockKPIs = async () => {
  const prisma2 = getPrismaClient();
  const today = /* @__PURE__ */ new Date();
  today.setHours(0, 0, 0, 0);
  const thirtyDaysFromNow = new Date(today);
  thirtyDaysFromNow.setDate(thirtyDaysFromNow.getDate() + 30);
  const products = await prisma2.product.findMany({
    include: {
      batches: {
        where: { quantity: { gt: 0 } }
      },
      category: true
    }
  });
  let totalStockValue = 0;
  let lowStockCount = 0;
  let expiringSoonCount = 0;
  let expiredCount = 0;
  const productMap = /* @__PURE__ */ new Map();
  products.forEach((product) => {
    let totalQty = 0;
    product.batches.forEach((batch) => {
      totalQty += batch.quantity;
      totalStockValue += toNumber(batch.ptr) * batch.quantity;
      if (batch.expiryDate) {
        const expiryDate = new Date(batch.expiryDate);
        expiryDate.setHours(0, 0, 0, 0);
        if (expiryDate < today) {
          expiredCount++;
        } else if (expiryDate <= thirtyDaysFromNow) {
          expiringSoonCount++;
        }
      }
    });
    productMap.set(product.id, {
      quantity: totalQty,
      minStock: product.minStock ?? 0
    });
    if (product.minStock > 0 && totalQty <= product.minStock) {
      lowStockCount++;
    }
  });
  return {
    totalSKUs: products.length,
    totalStockValue,
    lowStockCount,
    expiringSoonCount,
    expiredCount
  };
};
var getStockSnapshot = async (filters) => {
  const prisma2 = getPrismaClient();
  const where = {};
  if (filters?.categoryId) {
    where.categoryId = filters.categoryId;
  }
  if (filters?.manufacturer) {
    where.manufacturer = { contains: filters.manufacturer, mode: "insensitive" };
  }
  const products = await prisma2.product.findMany({
    where,
    include: {
      batches: {
        include: {
          godown: true
        },
        where: filters?.godownId ? { godownId: filters.godownId } : void 0
      },
      category: true
    }
  });
  const snapshotMap = /* @__PURE__ */ new Map();
  products.forEach((product) => {
    const batches = product.batches || [];
    let totalQuantity = 0;
    const godownBreakupMap = /* @__PURE__ */ new Map();
    batches.forEach((batch) => {
      totalQuantity += batch.quantity;
      const godownId = batch.godownId ?? null;
      const godownName = batch.godown?.name ?? "Unassigned";
      const existing = godownBreakupMap.get(godownId);
      if (existing) {
        existing.quantity += batch.quantity;
      } else {
        godownBreakupMap.set(godownId, {
          godownId,
          godownName,
          quantity: batch.quantity
        });
      }
    });
    if (filters?.minStock !== void 0 && totalQuantity < filters.minStock) {
      return;
    }
    if (filters?.maxStock !== void 0 && totalQuantity > filters.maxStock) {
      return;
    }
    if (filters?.search) {
      const searchLower = filters.search.toLowerCase();
      if (!product.name.toLowerCase().includes(searchLower) && !product.sku.toLowerCase().includes(searchLower) && !product.manufacturer?.toLowerCase().includes(searchLower)) {
        return;
      }
    }
    let stockValue = 0;
    batches.forEach((batch) => {
      stockValue += toNumber(batch.ptr) * batch.quantity;
    });
    snapshotMap.set(product.id, {
      productId: product.id,
      sku: product.sku,
      name: product.name,
      minStock: product.minStock ?? 0,
      totalQuantity,
      godownBreakup: Array.from(godownBreakupMap.values()),
      manufacturer: product.manufacturer ?? void 0,
      category: product.category?.name ?? void 0,
      unitOfMeasure: product.unitOfMeasure ?? void 0,
      packSize: product.packSize ?? void 0,
      stockValue
    });
  });
  return Array.from(snapshotMap.values()).sort(
    (a, b) => a.name.localeCompare(b.name)
  );
};
var mapStockMovement = (entry) => ({
  id: entry.id,
  productId: entry.productId,
  productName: entry.product?.name ?? "",
  batchId: entry.batchId ?? void 0,
  batchNumber: entry.batch?.batchNumber ?? void 0,
  godownId: entry.godownId ?? void 0,
  godownName: entry.godown?.name ?? void 0,
  movementType: entry.movementType,
  reference: entry.reference ?? "",
  quantityChange: entry.quantityChange,
  balanceAfter: entry.balanceAfter,
  narration: entry.narration ?? void 0,
  createdAt: entry.createdAt.toISOString()
});
var getStockMovements = async (filters) => {
  const prisma2 = getPrismaClient();
  const where = {};
  if (filters?.productId) {
    where.productId = filters.productId;
  }
  if (filters?.movementType) {
    where.movementType = filters.movementType;
  }
  if (filters?.batchId) {
    where.batchId = filters.batchId;
  }
  if (filters?.fromDate || filters?.toDate) {
    where.createdAt = {};
    if (filters.fromDate) {
      where.createdAt.gte = new Date(filters.fromDate);
    }
    if (filters.toDate) {
      const toDate = new Date(filters.toDate);
      toDate.setHours(23, 59, 59, 999);
      where.createdAt.lte = toDate;
    }
  }
  const movements = await prisma2.stockLedger.findMany({
    where,
    orderBy: { createdAt: "desc" },
    take: filters?.limit ?? 500,
    include: {
      product: true,
      batch: true,
      godown: true
    }
  });
  return movements.map(mapStockMovement);
};
var getStockMovementChartData = async (fromDate, toDate) => {
  const prisma2 = getPrismaClient();
  const startDate = new Date(fromDate);
  const endDate = new Date(toDate);
  endDate.setHours(23, 59, 59, 999);
  const movements = await prisma2.stockLedger.findMany({
    where: {
      createdAt: {
        gte: startDate,
        lte: endDate
      }
    },
    select: {
      createdAt: true,
      quantityChange: true,
      movementType: true
    }
  });
  const dateMap = /* @__PURE__ */ new Map();
  movements.forEach((movement) => {
    const dateKey = movement.createdAt.toISOString().substring(0, 10);
    const existing = dateMap.get(dateKey) || { in: 0, out: 0 };
    if (movement.quantityChange > 0) {
      existing.in += movement.quantityChange;
    } else {
      existing.out += Math.abs(movement.quantityChange);
    }
    dateMap.set(dateKey, existing);
  });
  return Array.from(dateMap.entries()).map(([date, data]) => ({ date, ...data })).sort((a, b) => a.date.localeCompare(b.date));
};
var mapExpiringBatch = (batch, daysUntilExpiry) => ({
  id: batch.id,
  productId: batch.productId,
  productName: batch.product?.name ?? "",
  sku: batch.product?.sku ?? "",
  batchNumber: batch.batchNumber,
  expiryDate: batch.expiryDate?.toISOString() ?? "",
  quantity: batch.quantity,
  daysUntilExpiry,
  godownId: batch.godownId ?? void 0,
  godownName: batch.godown?.name ?? void 0,
  manufacturer: batch.product?.manufacturer ?? void 0,
  category: batch.product?.category?.name ?? void 0
});
var getExpiringBatches = async (filters) => {
  const prisma2 = getPrismaClient();
  const daysAhead = filters?.daysAhead ?? 90;
  const includeExpired = filters?.includeExpired ?? false;
  const today = /* @__PURE__ */ new Date();
  today.setHours(0, 0, 0, 0);
  const cutoffDate = new Date(today);
  cutoffDate.setDate(cutoffDate.getDate() + daysAhead);
  const productWhere = {};
  if (filters?.categoryId) {
    productWhere.categoryId = filters.categoryId;
  }
  if (filters?.manufacturer) {
    productWhere.manufacturer = { contains: filters.manufacturer, mode: "insensitive" };
  }
  const batches = await prisma2.batch.findMany({
    where: {
      expiryDate: {
        lte: cutoffDate,
        ...includeExpired ? {} : { gte: today }
      },
      quantity: { gt: 0 },
      product: productWhere
    },
    include: {
      product: {
        include: {
          category: true
        }
      },
      godown: true
    },
    orderBy: { expiryDate: "asc" }
  });
  const result = batches.map((batch) => {
    if (!batch.expiryDate) {
      throw new Error("Batch expiry date is null");
    }
    const expiryDate = new Date(batch.expiryDate);
    expiryDate.setHours(0, 0, 0, 0);
    const diffTime = expiryDate.getTime() - today.getTime();
    const daysUntilExpiry = Math.ceil(diffTime / (1e3 * 60 * 60 * 24));
    return mapExpiringBatch(batch, daysUntilExpiry);
  });
  return result;
};
var getStockAlerts = async () => {
  const prisma2 = getPrismaClient();
  const products = await prisma2.product.findMany({
    include: {
      batches: {
        where: { quantity: { gt: 0 } }
      },
      category: true,
      purchaseItems: {
        include: {
          purchaseInvoice: {
            include: {
              supplier: true
            }
          }
        },
        orderBy: {
          createdAt: "desc"
        },
        take: 1
      }
    }
  });
  const lowStock = [];
  const outOfStock = [];
  const overstock = [];
  const reorderRequired = [];
  products.forEach((product) => {
    const totalQty = product.batches.reduce((sum, b) => sum + b.quantity, 0);
    const minStock = product.minStock ?? 0;
    const maxStock = product.maxStock;
    const lastPurchase = product.purchaseItems[0];
    const supplierId = lastPurchase?.purchaseInvoice.supplierId ?? void 0;
    const supplierName = lastPurchase?.purchaseInvoice.supplier?.name ?? void 0;
    const suggestedOrderQty = minStock > 0 ? Math.max(minStock * 2 - totalQty, minStock) : 0;
    const entry = {
      productId: product.id,
      productName: product.name,
      sku: product.sku,
      currentQty: totalQty,
      reorderLevel: minStock,
      suggestedOrderQty,
      supplierId,
      supplierName,
      category: product.category?.name ?? void 0,
      manufacturer: product.manufacturer ?? void 0,
      unitOfMeasure: product.unitOfMeasure ?? void 0
    };
    if (totalQty === 0) {
      outOfStock.push(entry);
      reorderRequired.push(entry);
    } else if (minStock > 0 && totalQty <= minStock) {
      lowStock.push(entry);
      reorderRequired.push(entry);
    } else if (maxStock && totalQty > maxStock * 1.5) {
      overstock.push(entry);
    }
  });
  return {
    lowStock: lowStock.sort((a, b) => a.productName.localeCompare(b.productName)),
    outOfStock: outOfStock.sort((a, b) => a.productName.localeCompare(b.productName)),
    overstock: overstock.sort((a, b) => b.currentQty - a.currentQty),
    reorderRequired: reorderRequired.sort((a, b) => a.productName.localeCompare(b.productName))
  };
};

// electron/src/services/dashboardService.ts
init_prismaClient();
var getDashboardSummary = async () => {
  const prisma2 = getPrismaClient();
  const today = /* @__PURE__ */ new Date();
  today.setHours(0, 0, 0, 0);
  const tomorrow = new Date(today);
  tomorrow.setDate(tomorrow.getDate() + 1);
  const [todaySales, todayPurchases, products, customers, suppliers, stockSnapshot, expiringBatches, recentAudits] = await Promise.all([
    prisma2.salesInvoice.findMany({
      where: {
        invoiceDate: {
          gte: today,
          lt: tomorrow
        }
      },
      select: {
        totalAmount: true
      }
    }),
    prisma2.purchaseInvoice.findMany({
      where: {
        invoiceDate: {
          gte: today,
          lt: tomorrow
        }
      },
      select: {
        totalAmount: true
      }
    }),
    prisma2.product.count(),
    prisma2.customer.count(),
    prisma2.supplier.count(),
    getStockSnapshot(),
    getExpiringBatches({ daysAhead: 30, includeExpired: false }),
    prisma2.auditLog.findMany({
      orderBy: { createdAt: "desc" },
      take: 5,
      include: {
        user: {
          select: {
            email: true,
            fullName: true
          }
        }
      }
    })
  ]);
  const todaySalesTotal = todaySales.reduce(
    (sum, inv) => sum + Number(inv.totalAmount),
    0
  );
  const todayPurchasesTotal = todayPurchases.reduce(
    (sum, inv) => sum + Number(inv.totalAmount),
    0
  );
  const lowStockCount = stockSnapshot.filter(
    (item) => item.totalQuantity <= item.minStock
  ).length;
  const recentActivity = recentAudits.map((audit) => ({
    type: audit.action,
    description: `${audit.entity} ${audit.action.toLowerCase()}${audit.user ? ` by ${audit.user.fullName || audit.user.email}` : ""}`,
    timestamp: audit.createdAt.toISOString()
  }));
  return {
    todaySales: {
      count: todaySales.length,
      totalAmount: todaySalesTotal
    },
    todayPurchases: {
      count: todayPurchases.length,
      totalAmount: todayPurchasesTotal
    },
    lowStockCount,
    expiringBatchesCount: expiringBatches.length,
    totalProducts: products,
    totalCustomers: customers,
    totalSuppliers: suppliers,
    recentActivity
  };
};

// electron/src/services/userService.ts
var import_bcryptjs2 = __toESM(require_bcryptjs());
init_prismaClient();
init_auditService();
var mapUser = (user) => ({
  id: user.id,
  username: user.email,
  roleName: user.role?.name ?? "",
  createdAt: user.createdAt.toISOString()
});
var mapRole = (role) => ({
  id: role.id,
  name: role.name,
  description: role.description ?? void 0
});
var listUsers = async () => {
  const prisma2 = getPrismaClient();
  const users = await prisma2.user.findMany({
    include: {
      role: true
    },
    orderBy: { createdAt: "desc" }
  });
  return users.map(mapUser);
};
var createUser = async (payload) => {
  if (!payload.username || !payload.password || !payload.roleId) {
    throw new Error("Username, password, and role are required");
  }
  const prisma2 = getPrismaClient();
  const role = await prisma2.role.findUnique({
    where: { id: payload.roleId }
  });
  if (!role) {
    throw new Error("Role not found");
  }
  if (role.name === "ADMIN") {
    throw new Error("Cannot create additional admin users. Only one admin user is allowed in the system.");
  }
  const existingUser = await prisma2.user.findUnique({
    where: { email: payload.username }
  });
  if (existingUser) {
    throw new Error("User with this email already exists");
  }
  const hashedPassword = await import_bcryptjs2.default.hash(payload.password, 10);
  const user = await prisma2.user.create({
    data: {
      email: payload.username,
      fullName: payload.username.split("@")[0],
      hashedPassword,
      roleId: payload.roleId
    },
    include: {
      role: true
    }
  });
  await logAudit({
    entity: "User",
    entityId: user.id,
    action: "CREATE",
    details: { email: user.email, roleId: payload.roleId }
  });
  return mapUser(user);
};
var listRoles = async () => {
  const prisma2 = getPrismaClient();
  const roles = await prisma2.role.findMany({
    orderBy: { name: "asc" }
  });
  return roles.map(mapRole);
};
var getUserById = async (id) => {
  const prisma2 = getPrismaClient();
  const user = await prisma2.user.findUnique({
    where: { id },
    include: { role: true }
  });
  if (!user) {
    throw new Error("User not found");
  }
  return mapUser(user);
};
var updateUser = async (id, payload) => {
  const prisma2 = getPrismaClient();
  const updateData = {};
  if (payload.fullName) updateData.fullName = payload.fullName;
  if (payload.roleId) updateData.roleId = payload.roleId;
  if (payload.isActive !== void 0) updateData.isActive = payload.isActive;
  if (payload.password) {
    updateData.hashedPassword = await import_bcryptjs2.default.hash(payload.password, 10);
  }
  const user = await prisma2.user.update({
    where: { id },
    data: updateData,
    include: { role: true }
  });
  await logAudit({
    entity: "User",
    entityId: user.id,
    action: "UPDATE",
    details: { email: user.email }
  });
  return mapUser(user);
};
var deleteUser = async (id) => {
  const prisma2 = getPrismaClient();
  const user = await prisma2.user.findUnique({
    where: { id }
  });
  if (!user) {
    throw new Error("User not found");
  }
  await prisma2.user.delete({ where: { id } });
  await logAudit({
    entity: "User",
    entityId: id,
    action: "DELETE",
    details: { email: user.email }
  });
};

// electron/src/ipcHandlers/index.ts
init_reportService();
init_backupService();

// electron/src/services/eInvoiceService.ts
init_prismaClient();
var mapQueue = (row) => ({
  id: row.id,
  salesInvoiceId: row.salesInvoiceId,
  invoiceNumber: row.salesInvoice.invoiceNumber,
  status: row.status,
  errorMessage: row.errorMessage ?? void 0,
  createdAt: row.createdAt.toISOString(),
  lastAttemptAt: row.lastAttemptAt?.toISOString()
});
var queueEInvoice = async (payload) => {
  const prisma2 = getPrismaClient();
  const invoice = await prisma2.salesInvoice.findUnique({
    where: { id: payload.salesInvoiceId },
    include: { customer: true, items: true }
  });
  if (!invoice) {
    throw new Error("Sales invoice not found");
  }
  const payloadJson = JSON.stringify({
    invoiceNumber: invoice.invoiceNumber,
    customer: invoice.customer.name,
    items: invoice.items.map((item) => ({
      productId: item.productId,
      quantity: item.quantity,
      lineTotal: item.lineTotal
    }))
  });
  const queued = await prisma2.eInvoiceQueue.create({
    data: {
      salesInvoiceId: invoice.id,
      payloadJson,
      status: "PENDING"
    },
    include: {
      salesInvoice: true
    }
  });
  return mapQueue(queued);
};
var listEInvoiceQueue = async () => {
  const prisma2 = getPrismaClient();
  const rows = await prisma2.eInvoiceQueue.findMany({
    orderBy: { createdAt: "desc" },
    include: {
      salesInvoice: true
    }
  });
  return rows.map(mapQueue);
};
var syncEInvoiceQueue = async () => {
  const prisma2 = getPrismaClient();
  const pending = await prisma2.eInvoiceQueue.findMany({
    where: { status: "PENDING" }
  });
  let synced = 0;
  let failed = 0;
  for (const row of pending) {
    try {
      await prisma2.eInvoiceQueue.update({
        where: { id: row.id },
        data: {
          status: "SENT",
          irn: `MOCK-IRN-${row.id}`,
          ackNumber: `ACK-${row.id}`,
          lastAttemptAt: /* @__PURE__ */ new Date(),
          responseJson: JSON.stringify({ mock: true })
        }
      });
      synced += 1;
    } catch {
      await prisma2.eInvoiceQueue.update({
        where: { id: row.id },
        data: {
          status: "FAILED",
          errorMessage: "Local sync error",
          lastAttemptAt: /* @__PURE__ */ new Date()
        }
      });
      failed += 1;
    }
  }
  return { synced, failed };
};

// electron/src/ipcHandlers/index.ts
init_companyInfoService();

// electron/src/services/godownService.ts
init_prismaClient();
init_auditService();
var mapGodown = (godown) => ({
  id: godown.id,
  name: godown.name,
  location: godown.location ?? void 0,
  isDefault: godown.isDefault,
  createdAt: godown.createdAt.toISOString()
});
var listGodowns = async () => {
  const prisma2 = getPrismaClient();
  const godowns = await prisma2.godown.findMany({
    orderBy: [{ isDefault: "desc" }, { name: "asc" }]
  });
  return godowns.map(mapGodown);
};
var createGodown = async (payload) => {
  if (!payload.name) {
    throw new Error("Godown name is required");
  }
  const prisma2 = getPrismaClient();
  const existing = await prisma2.godown.findUnique({
    where: { name: payload.name }
  });
  if (existing) {
    throw new Error("Godown with this name already exists");
  }
  if (payload.isDefault) {
    await prisma2.godown.updateMany({
      where: { isDefault: true },
      data: { isDefault: false }
    });
  }
  const godown = await prisma2.godown.create({
    data: {
      name: payload.name,
      location: payload.location,
      isDefault: payload.isDefault ?? false
    }
  });
  await logAudit({
    entity: "Godown",
    entityId: godown.id,
    action: "CREATE",
    details: { name: godown.name, location: godown.location }
  });
  return mapGodown(godown);
};
var updateGodown = async (id, payload) => {
  const prisma2 = getPrismaClient();
  if (payload.name) {
    const existing = await prisma2.godown.findUnique({
      where: { name: payload.name }
    });
    if (existing && existing.id !== id) {
      throw new Error("Godown with this name already exists");
    }
  }
  if (payload.isDefault) {
    await prisma2.godown.updateMany({
      where: { isDefault: true },
      data: { isDefault: false }
    });
  }
  const godown = await prisma2.godown.update({
    where: { id },
    data: {
      ...payload.name && { name: payload.name },
      ...payload.location !== void 0 && { location: payload.location },
      ...payload.isDefault !== void 0 && { isDefault: payload.isDefault }
    }
  });
  await logAudit({
    entity: "Godown",
    entityId: godown.id,
    action: "UPDATE",
    details: { name: godown.name }
  });
  return mapGodown(godown);
};
var deleteGodown = async (id) => {
  const prisma2 = getPrismaClient();
  const godown = await prisma2.godown.findUnique({
    where: { id },
    include: {
      batches: { where: { quantity: { gt: 0 } }, take: 1 }
    }
  });
  if (!godown) {
    throw new Error("Godown not found");
  }
  if (godown.batches.length > 0) {
    throw new Error("Cannot delete godown with existing batches");
  }
  await prisma2.godown.delete({ where: { id } });
  await logAudit({
    entity: "Godown",
    entityId: id,
    action: "DELETE",
    details: { name: godown.name }
  });
};

// electron/src/services/batchService.ts
var import_client4 = require("@prisma/client");
init_prismaClient();
init_auditService();
var toNumber2 = (value) => {
  if (value instanceof import_client4.Prisma.Decimal) {
    return value.toNumber();
  }
  return Number(value ?? 0);
};
var mapBatch = (batch) => ({
  id: batch.id,
  productId: batch.productId,
  productName: batch.product?.name ?? "",
  godownId: batch.godownId ?? void 0,
  godownName: batch.godown?.name ?? void 0,
  batchNumber: batch.batchNumber,
  expiryDate: batch.expiryDate.toISOString(),
  mrp: toNumber2(batch.mrp),
  ptr: toNumber2(batch.ptr),
  pts: toNumber2(batch.pts),
  taxPercent: toNumber2(batch.taxPercent),
  quantity: batch.quantity,
  createdAt: batch.createdAt.toISOString(),
  updatedAt: batch.updatedAt.toISOString()
});
var listBatches = async (productId) => {
  const prisma2 = getPrismaClient();
  const batches = await prisma2.batch.findMany({
    where: productId ? { productId } : void 0,
    include: {
      product: true,
      godown: true
    },
    orderBy: [{ expiryDate: "asc" }, { batchNumber: "asc" }]
  });
  return batches.map(mapBatch);
};
var getBatchById = async (id) => {
  const prisma2 = getPrismaClient();
  const batch = await prisma2.batch.findUnique({
    where: { id },
    include: {
      product: true,
      godown: true
    }
  });
  if (!batch) {
    throw new Error("Batch not found");
  }
  return mapBatch(batch);
};
var createBatch = async (payload) => {
  if (!payload.productId || !payload.batchNumber || !payload.expiryDate) {
    throw new Error("Product ID, batch number, and expiry date are required");
  }
  const prisma2 = getPrismaClient();
  const product = await prisma2.product.findUnique({
    where: { id: payload.productId }
  });
  if (!product) {
    throw new Error("Product not found");
  }
  const existing = await prisma2.batch.findUnique({
    where: {
      productId_batchNumber: {
        productId: payload.productId,
        batchNumber: payload.batchNumber
      }
    }
  });
  if (existing) {
    throw new Error("Batch with this number already exists for this product");
  }
  const batch = await prisma2.batch.create({
    data: {
      productId: payload.productId,
      batchNumber: payload.batchNumber,
      expiryDate: new Date(payload.expiryDate),
      mrp: new import_client4.Prisma.Decimal(payload.mrp),
      ptr: new import_client4.Prisma.Decimal(payload.ptr),
      pts: new import_client4.Prisma.Decimal(payload.pts),
      taxPercent: new import_client4.Prisma.Decimal(payload.taxPercent),
      quantity: payload.quantity,
      godownId: payload.godownId
    },
    include: {
      product: true,
      godown: true
    }
  });
  await logAudit({
    entity: "Batch",
    entityId: batch.id,
    action: "CREATE",
    details: {
      productId: batch.productId,
      batchNumber: batch.batchNumber,
      quantity: batch.quantity
    }
  });
  return mapBatch(batch);
};
var updateBatch = async (id, payload) => {
  const prisma2 = getPrismaClient();
  const existing = await prisma2.batch.findUnique({
    where: { id },
    include: { product: true }
  });
  if (!existing) {
    throw new Error("Batch not found");
  }
  if (payload.batchNumber && payload.batchNumber !== existing.batchNumber) {
    const duplicate = await prisma2.batch.findUnique({
      where: {
        productId_batchNumber: {
          productId: existing.productId,
          batchNumber: payload.batchNumber
        }
      }
    });
    if (duplicate) {
      throw new Error("Batch with this number already exists for this product");
    }
  }
  const updateData = {};
  if (payload.batchNumber) updateData.batchNumber = payload.batchNumber;
  if (payload.expiryDate) updateData.expiryDate = new Date(payload.expiryDate);
  if (payload.mrp !== void 0) updateData.mrp = new import_client4.Prisma.Decimal(payload.mrp);
  if (payload.ptr !== void 0) updateData.ptr = new import_client4.Prisma.Decimal(payload.ptr);
  if (payload.pts !== void 0) updateData.pts = new import_client4.Prisma.Decimal(payload.pts);
  if (payload.taxPercent !== void 0) updateData.taxPercent = new import_client4.Prisma.Decimal(payload.taxPercent);
  if (payload.quantity !== void 0) updateData.quantity = payload.quantity;
  if (payload.godownId !== void 0) updateData.godownId = payload.godownId;
  const batch = await prisma2.batch.update({
    where: { id },
    data: updateData,
    include: {
      product: true,
      godown: true
    }
  });
  await logAudit({
    entity: "Batch",
    entityId: batch.id,
    action: "UPDATE",
    details: {
      productId: batch.productId,
      batchNumber: batch.batchNumber
    }
  });
  return mapBatch(batch);
};
var deleteBatch = async (id) => {
  const prisma2 = getPrismaClient();
  const batch = await prisma2.batch.findUnique({
    where: { id },
    include: {
      purchaseItems: { take: 1 },
      salesItems: { take: 1 },
      stockLedgers: { take: 1 }
    }
  });
  if (!batch) {
    throw new Error("Batch not found");
  }
  if (batch.quantity > 0) {
    throw new Error("Cannot delete batch with remaining stock");
  }
  if (batch.purchaseItems.length > 0 || batch.salesItems.length > 0) {
    throw new Error("Cannot delete batch that has been used in invoices");
  }
  await prisma2.batch.delete({ where: { id } });
  await logAudit({
    entity: "Batch",
    entityId: id,
    action: "DELETE",
    details: {
      productId: batch.productId,
      batchNumber: batch.batchNumber
    }
  });
};

// electron/src/services/productService.ts
var import_client5 = require("@prisma/client");
init_prismaClient();
init_auditService();
var toNumber3 = (value) => {
  if (value instanceof import_client5.Prisma.Decimal) {
    return value.toNumber();
  }
  return Number(value ?? 0);
};
var mapProduct = (product) => ({
  id: product.id,
  sku: product.sku,
  name: product.name,
  hsnCode: product.hsnCode,
  manufacturer: product.manufacturer,
  packSize: product.packSize,
  drugCategory: product.drugCategory ?? void 0,
  drugGroup: product.drugGroup ?? void 0,
  drugContent: product.drugContent ?? void 0,
  unitOfMeasure: product.unitOfMeasure ?? void 0,
  purchasePack: product.purchasePack ?? void 0,
  stripQuantity: product.stripQuantity ?? void 0,
  barcode: product.barcode ?? void 0,
  stripCode: product.stripCode ?? void 0,
  itemCode: product.itemCode ?? void 0,
  categoryName: product.category?.name,
  subcategoryName: product.subcategory?.name,
  companyName: product.company?.name,
  scheduleName: product.schedule?.name,
  storageTypeName: product.storageType?.name,
  gstRate: toNumber3(product.gstRate),
  minStock: product.minStock,
  maxStock: product.maxStock,
  isBatchManaged: product.isBatchManaged,
  batches: product.batches?.map((batch) => ({
    id: batch.id,
    batchNumber: batch.batchNumber,
    expiryDate: batch.expiryDate.toISOString(),
    quantity: batch.quantity,
    mrp: toNumber3(batch.mrp),
    ptr: toNumber3(batch.ptr),
    pts: toNumber3(batch.pts)
  })),
  createdAt: product.createdAt.toISOString()
});
var createProduct = async (payload) => {
  if (!payload.sku || !payload.name || !payload.hsnCode) {
    throw new Error("SKU, name, and HSN code are required");
  }
  const prisma2 = getPrismaClient();
  const existing = await prisma2.product.findUnique({
    where: { sku: payload.sku }
  });
  if (existing) {
    throw new Error("Product with this SKU already exists");
  }
  return prisma2.$transaction(
    async (tx) => {
      const toNull = (value) => value && value.trim() !== "" ? value.trim() : null;
      const product = await tx.product.create({
        data: {
          sku: payload.sku.trim(),
          name: payload.name.trim(),
          hsnCode: payload.hsnCode.trim(),
          manufacturer: toNull(payload.manufacturer),
          drugCategory: toNull(payload.drugCategory),
          drugGroup: toNull(payload.drugGroup),
          drugContent: toNull(payload.drugContent),
          unitOfMeasure: toNull(payload.unitOfMeasure),
          purchasePack: toNull(payload.purchasePack),
          stripQuantity: payload.stripQuantity ?? null,
          barcode: toNull(payload.barcode),
          stripCode: toNull(payload.stripCode),
          itemCode: toNull(payload.itemCode),
          categoryId: payload.categoryId ?? null,
          subcategoryId: payload.subcategoryId ?? null,
          companyId: payload.companyId ?? null,
          scheduleId: payload.scheduleId ?? null,
          storageTypeId: payload.storageTypeId ?? null,
          packSize: toNull(payload.packSize),
          gstRate: new import_client5.Prisma.Decimal(payload.gstRate ?? 0),
          minStock: payload.minStock ?? 0,
          maxStock: payload.maxStock ?? null,
          isBatchManaged: payload.isBatchManaged ?? true
        },
        include: {
          category: true,
          subcategory: true,
          company: true,
          schedule: true,
          storageType: true,
          batches: {
            orderBy: {
              expiryDate: "asc"
            }
          }
        }
      });
      if (payload.initialBatch && payload.initialBatch.batchNumber && payload.initialBatch.batchNumber.trim() !== "") {
        if (!payload.initialBatch.expiryDate) {
          throw new Error("Expiry date is required for initial batch");
        }
        if ((payload.initialBatch.quantity || 0) <= 0) {
          throw new Error("Quantity must be greater than 0 for initial batch");
        }
        const totalQuantity = (payload.initialBatch.quantity || 0) + (payload.initialBatch.freeQuantity || 0);
        const batch = await tx.batch.create({
          data: {
            productId: product.id,
            batchNumber: payload.initialBatch.batchNumber.trim(),
            expiryDate: new Date(payload.initialBatch.expiryDate),
            mrp: new import_client5.Prisma.Decimal(payload.initialBatch.mrp || 0),
            ptr: new import_client5.Prisma.Decimal(payload.initialBatch.ptr || 0),
            pts: new import_client5.Prisma.Decimal(payload.initialBatch.pts || payload.initialBatch.ptr || 0),
            taxPercent: new import_client5.Prisma.Decimal(payload.gstRate ?? 0),
            quantity: totalQuantity,
            godownId: payload.initialBatch.godownId ?? null
          }
        });
        await tx.stockLedger.create({
          data: {
            productId: product.id,
            batchId: batch.id,
            godownId: payload.initialBatch.godownId ?? null,
            movementType: "PURCHASE",
            reference: `Initial batch for ${product.sku}`,
            quantityChange: totalQuantity,
            balanceAfter: batch.quantity,
            narration: `Initial batch creation`
          }
        });
      }
      await logAuditAsync({
        entity: "Product",
        entityId: product.id,
        action: "CREATE",
        details: { sku: product.sku, name: product.name }
      });
      const productWithBatches = await tx.product.findUnique({
        where: { id: product.id },
        include: {
          category: true,
          subcategory: true,
          company: true,
          schedule: true,
          storageType: true,
          batches: {
            orderBy: {
              expiryDate: "asc"
            }
          }
        }
      });
      if (!productWithBatches) {
        throw new Error("Product not found after creation");
      }
      return mapProduct(productWithBatches);
    },
    {
      timeout: 1e4
      // 10 second timeout for product creation with batch
    }
  );
};
var listProducts = async (filters) => {
  const prisma2 = getPrismaClient();
  const page = filters?.page ?? 1;
  const pageSize = filters?.pageSize ?? 50;
  const skip = (page - 1) * pageSize;
  const sortBy = filters?.sortBy ?? "name";
  const sortOrder = filters?.sortOrder ?? "asc";
  const where = {
    deletedAt: null
    // Exclude deleted products
  };
  if (filters?.search) {
    where.OR = [
      { name: { contains: filters.search } },
      { sku: { contains: filters.search } }
    ];
  }
  const [products, total] = await Promise.all([
    prisma2.product.findMany({
      where,
      include: {
        category: true,
        subcategory: true,
        company: true,
        schedule: true,
        storageType: true,
        batches: {
          where: {
            quantity: { gt: 0 }
          },
          orderBy: {
            expiryDate: "asc"
          }
        }
      },
      orderBy: { [sortBy]: sortOrder },
      skip,
      take: pageSize
    }),
    prisma2.product.count({ where })
  ]);
  return {
    products: products.map(mapProduct),
    total,
    page,
    pageSize,
    totalPages: Math.ceil(total / pageSize)
  };
};
var getProductById = async (id) => {
  const prisma2 = getPrismaClient();
  const today = /* @__PURE__ */ new Date();
  today.setHours(0, 0, 0, 0);
  const product = await prisma2.product.findUnique({
    where: { id },
    include: {
      category: true,
      subcategory: true,
      company: true,
      schedule: true,
      storageType: true,
      batches: {
        where: {
          quantity: { gt: 0 },
          expiryDate: { gt: today }
          // Exclude expired batches for autofill
        },
        orderBy: {
          expiryDate: "asc"
          // FEFO order - earliest expiry first
        },
        include: {
          godown: true
        }
      }
    }
  });
  if (!product) {
    throw new Error("Product not found");
  }
  return mapProduct(product);
};
var updateProduct = async (id, payload) => {
  const prisma2 = getPrismaClient();
  if (payload.sku) {
    const existing = await prisma2.product.findUnique({
      where: { sku: payload.sku }
    });
    if (existing && existing.id !== id) {
      throw new Error("Product with this SKU already exists");
    }
  }
  const product = await prisma2.product.update({
    where: { id },
    data: {
      ...payload.sku && { sku: payload.sku },
      ...payload.name && { name: payload.name },
      ...payload.hsnCode && { hsnCode: payload.hsnCode },
      ...payload.manufacturer !== void 0 && { manufacturer: payload.manufacturer },
      ...payload.packSize !== void 0 && { packSize: payload.packSize },
      ...payload.gstRate !== void 0 && { gstRate: new import_client5.Prisma.Decimal(payload.gstRate) },
      ...payload.minStock !== void 0 && { minStock: payload.minStock },
      ...payload.maxStock !== void 0 && { maxStock: payload.maxStock },
      ...payload.isBatchManaged !== void 0 && { isBatchManaged: payload.isBatchManaged }
    },
    include: {
      batches: {
        where: {
          quantity: { gt: 0 }
        },
        orderBy: {
          expiryDate: "asc"
        }
      }
    }
  });
  await logAuditAsync({
    entity: "Product",
    entityId: product.id,
    action: "UPDATE",
    details: { sku: product.sku, name: product.name }
  });
  return mapProduct(product);
};
var deleteProduct = async (id, userId, reason) => {
  const { safeDeleteProduct: safeDeleteProduct2 } = await Promise.resolve().then(() => (init_safeDeleteService(), safeDeleteService_exports));
  if (!userId) {
    throw new Error("User ID is required for deletion");
  }
  await safeDeleteProduct2(id, { userId, reason });
};

// electron/src/ipcHandlers/index.ts
init_customerService();

// electron/src/services/supplierService.ts
var import_client7 = require("@prisma/client");
init_prismaClient();
init_auditService();
var toNumber4 = (value) => {
  if (value instanceof import_client7.Prisma.Decimal) {
    return value.toNumber();
  }
  return Number(value ?? 0);
};
var mapSupplier = (supplier) => ({
  id: supplier.id,
  name: supplier.name,
  gstin: supplier.gstin ?? void 0,
  drugLicenseNumber: supplier.drugLicenseNumber ?? void 0,
  dlNo2: supplier.dlNo2 ?? void 0,
  fullAddress: supplier.fullAddress ?? void 0,
  addressLine1: supplier.addressLine1 ?? void 0,
  addressLine2: supplier.addressLine2 ?? void 0,
  locality: supplier.locality ?? void 0,
  city: supplier.city ?? void 0,
  state: supplier.state ?? void 0,
  postalCode: supplier.postalCode ?? void 0,
  phone: supplier.phone ?? void 0,
  email: supplier.email ?? void 0,
  openingBalance: toNumber4(supplier.openingBalance),
  createdAt: supplier.createdAt.toISOString(),
  updatedAt: supplier.updatedAt.toISOString()
});
var listSuppliers = async (search) => {
  const prisma2 = getPrismaClient();
  const suppliers = await prisma2.supplier.findMany({
    where: search ? {
      name: { contains: search }
    } : void 0,
    orderBy: { name: "asc" }
  });
  return suppliers.map((s) => {
    const supplier = s;
    return mapSupplier({
      id: supplier.id,
      name: supplier.name,
      gstin: supplier.gstin,
      drugLicenseNumber: supplier.drugLicenseNumber,
      dlNo2: supplier.dlNo2,
      fullAddress: supplier.fullAddress,
      addressLine1: supplier.addressLine1,
      addressLine2: supplier.addressLine2,
      locality: supplier.locality,
      city: supplier.city,
      state: supplier.state,
      postalCode: supplier.postalCode,
      phone: supplier.phone,
      email: supplier.email,
      openingBalance: supplier.openingBalance,
      createdAt: supplier.createdAt,
      updatedAt: supplier.updatedAt
    });
  });
};
var createSupplier = async (payload) => {
  if (!payload.name) {
    throw new Error("Supplier name is required");
  }
  const prisma2 = getPrismaClient();
  const supplier = await prisma2.supplier.create({
    data: {
      name: payload.name,
      gstin: payload.gstin,
      drugLicenseNumber: payload.drugLicenseNumber,
      dlNo2: payload.dlNo2,
      fullAddress: payload.fullAddress,
      addressLine1: payload.addressLine1,
      addressLine2: payload.addressLine2,
      locality: payload.locality,
      city: payload.city,
      state: payload.state,
      postalCode: payload.postalCode,
      phone: payload.phone,
      email: payload.email,
      openingBalance: new import_client7.Prisma.Decimal(payload.openingBalance ?? 0)
    }
  });
  await logAudit({
    entity: "Supplier",
    entityId: supplier.id,
    action: "CREATE",
    details: { name: supplier.name, gstin: supplier.gstin }
  });
  const supplierWithFields = supplier;
  return mapSupplier({
    id: supplierWithFields.id,
    name: supplierWithFields.name,
    gstin: supplierWithFields.gstin,
    drugLicenseNumber: supplierWithFields.drugLicenseNumber,
    dlNo2: supplierWithFields.dlNo2,
    fullAddress: supplierWithFields.fullAddress,
    addressLine1: supplierWithFields.addressLine1,
    addressLine2: supplierWithFields.addressLine2,
    locality: supplierWithFields.locality,
    city: supplierWithFields.city,
    state: supplierWithFields.state,
    postalCode: supplierWithFields.postalCode,
    phone: supplierWithFields.phone,
    email: supplierWithFields.email,
    openingBalance: supplierWithFields.openingBalance,
    createdAt: supplierWithFields.createdAt,
    updatedAt: supplierWithFields.updatedAt
  });
};
var getSupplierById = async (id) => {
  const prisma2 = getPrismaClient();
  const supplier = await prisma2.supplier.findUnique({
    where: { id }
  });
  if (!supplier) {
    throw new Error("Supplier not found");
  }
  const supplierWithFields = supplier;
  return mapSupplier({
    id: supplierWithFields.id,
    name: supplierWithFields.name,
    gstin: supplierWithFields.gstin,
    drugLicenseNumber: supplierWithFields.drugLicenseNumber,
    dlNo2: supplierWithFields.dlNo2,
    fullAddress: supplierWithFields.fullAddress,
    addressLine1: supplierWithFields.addressLine1,
    addressLine2: supplierWithFields.addressLine2,
    locality: supplierWithFields.locality,
    city: supplierWithFields.city,
    state: supplierWithFields.state,
    postalCode: supplierWithFields.postalCode,
    phone: supplierWithFields.phone,
    email: supplierWithFields.email,
    openingBalance: supplierWithFields.openingBalance,
    createdAt: supplierWithFields.createdAt,
    updatedAt: supplierWithFields.updatedAt
  });
};
var updateSupplier = async (id, payload) => {
  const prisma2 = getPrismaClient();
  const supplier = await prisma2.supplier.update({
    where: { id },
    data: {
      ...payload.name && { name: payload.name },
      ...payload.gstin !== void 0 && { gstin: payload.gstin },
      ...payload.drugLicenseNumber !== void 0 && { drugLicenseNumber: payload.drugLicenseNumber },
      ...payload.dlNo2 !== void 0 && { dlNo2: payload.dlNo2 },
      ...payload.fullAddress !== void 0 && { fullAddress: payload.fullAddress },
      ...payload.addressLine1 !== void 0 && { addressLine1: payload.addressLine1 },
      ...payload.addressLine2 !== void 0 && { addressLine2: payload.addressLine2 },
      ...payload.locality !== void 0 && { locality: payload.locality },
      ...payload.city !== void 0 && { city: payload.city },
      ...payload.state !== void 0 && { state: payload.state },
      ...payload.postalCode !== void 0 && { postalCode: payload.postalCode },
      ...payload.phone !== void 0 && { phone: payload.phone },
      ...payload.email !== void 0 && { email: payload.email },
      ...payload.openingBalance !== void 0 && { openingBalance: new import_client7.Prisma.Decimal(payload.openingBalance) }
    }
  });
  await logAudit({
    entity: "Supplier",
    entityId: supplier.id,
    action: "UPDATE",
    details: { name: supplier.name }
  });
  const supplierWithFields = supplier;
  return mapSupplier({
    id: supplierWithFields.id,
    name: supplierWithFields.name,
    gstin: supplierWithFields.gstin,
    drugLicenseNumber: supplierWithFields.drugLicenseNumber,
    dlNo2: supplierWithFields.dlNo2,
    fullAddress: supplierWithFields.fullAddress,
    addressLine1: supplierWithFields.addressLine1,
    addressLine2: supplierWithFields.addressLine2,
    locality: supplierWithFields.locality,
    city: supplierWithFields.city,
    state: supplierWithFields.state,
    postalCode: supplierWithFields.postalCode,
    phone: supplierWithFields.phone,
    email: supplierWithFields.email,
    openingBalance: supplierWithFields.openingBalance,
    createdAt: supplierWithFields.createdAt,
    updatedAt: supplierWithFields.updatedAt
  });
};
var deleteSupplier = async (id) => {
  const prisma2 = getPrismaClient();
  const supplier = await prisma2.supplier.findUnique({
    where: { id },
    include: {
      purchaseInvoices: { take: 1 }
    }
  });
  if (!supplier) {
    throw new Error("Supplier not found");
  }
  if (supplier.purchaseInvoices.length > 0) {
    throw new Error("Cannot delete supplier with existing purchase invoices");
  }
  await prisma2.supplier.delete({ where: { id } });
  await logAudit({
    entity: "Supplier",
    entityId: id,
    action: "DELETE",
    details: { name: supplier.name }
  });
};

// electron/src/services/schemeService.ts
init_prismaClient();
init_auditService();
var mapSchemeItem = (item) => ({
  id: item.id,
  productId: item.productId,
  productName: item.product?.name ?? "",
  purchaseQuantity: item.purchaseQuantity,
  bonusQuantity: item.bonusQuantity,
  bonusProductId: item.bonusProductId ?? void 0,
  bonusProductName: item.bonusProduct?.name ?? void 0
});
var mapScheme = (scheme) => ({
  id: scheme.id,
  name: scheme.name,
  description: scheme.description ?? void 0,
  validFrom: scheme.validFrom.toISOString(),
  validTo: scheme.validTo.toISOString(),
  isActive: scheme.isActive,
  items: scheme.items.map(mapSchemeItem),
  createdAt: scheme.createdAt.toISOString()
});
var createScheme = async (payload) => {
  const prisma2 = getPrismaClient();
  const scheme = await prisma2.scheme.create({
    data: {
      name: payload.name,
      description: payload.description,
      validFrom: new Date(payload.validFrom),
      validTo: new Date(payload.validTo),
      isActive: true,
      items: {
        create: payload.items.map((item) => ({
          productId: item.productId,
          purchaseQuantity: item.purchaseQuantity,
          bonusQuantity: item.bonusQuantity,
          bonusProductId: item.bonusProductId
        }))
      }
    },
    include: {
      items: {
        include: {
          product: true,
          bonusProduct: true
        }
      }
    }
  });
  await logAudit({
    entity: "Scheme",
    entityId: scheme.id,
    action: "CREATE",
    details: {
      name: scheme.name,
      validFrom: scheme.validFrom,
      validTo: scheme.validTo
    }
  });
  return mapScheme(scheme);
};
var listSchemes = async () => {
  const prisma2 = getPrismaClient();
  const schemes = await prisma2.scheme.findMany({
    orderBy: { createdAt: "desc" },
    include: {
      items: {
        include: {
          product: true,
          bonusProduct: true
        }
      }
    }
  });
  return schemes.map(mapScheme);
};
var updateScheme = async (id, payload) => {
  const prisma2 = getPrismaClient();
  const scheme = await prisma2.scheme.update({
    where: { id },
    data: {
      ...payload.name && { name: payload.name },
      ...payload.description !== void 0 && { description: payload.description },
      ...payload.validFrom && { validFrom: new Date(payload.validFrom) },
      ...payload.validTo && { validTo: new Date(payload.validTo) },
      ...payload.isActive !== void 0 && { isActive: payload.isActive }
    },
    include: {
      items: {
        include: {
          product: true,
          bonusProduct: true
        }
      }
    }
  });
  await logAudit({
    entity: "Scheme",
    entityId: scheme.id,
    action: "UPDATE",
    details: { name: scheme.name }
  });
  return mapScheme(scheme);
};
var deleteScheme = async (id) => {
  const prisma2 = getPrismaClient();
  const scheme = await prisma2.scheme.findUnique({
    where: { id }
  });
  if (!scheme) {
    throw new Error("Scheme not found");
  }
  await prisma2.scheme.delete({ where: { id } });
  await logAudit({
    entity: "Scheme",
    entityId: id,
    action: "DELETE",
    details: { name: scheme.name }
  });
};

// electron/src/services/invoiceService.ts
var import_client8 = require("@prisma/client");
init_prismaClient();
init_auditService();
var toDecimal = (value) => new import_client8.Prisma.Decimal(Number(value || 0));
var mapPurchaseInvoice = (invoice) => ({
  id: invoice.id,
  invoiceNumber: invoice.invoiceNumber,
  supplierName: invoice.supplierName,
  supplierId: invoice.supplierId ?? void 0,
  invoiceDate: invoice.invoiceDate.toISOString(),
  totalAmount: Number(invoice.totalAmount),
  totalTax: Number(invoice.totalTax),
  notes: invoice.notes ?? void 0,
  items: invoice.items.map((item) => ({
    id: item.id,
    productId: item.productId,
    productName: item.product?.name ?? "",
    batchNumber: item.batch?.batchNumber,
    quantity: item.quantity,
    freeQuantity: item.freeQuantity,
    costPrice: Number(item.costPrice),
    taxPercent: Number(item.taxPercent),
    discountPercent: Number(item.discountPercent),
    lineTotal: Number(item.lineTotal)
  }))
});
var ensureSupplier = async (payload, prisma2) => {
  if (payload.supplierId) {
    return payload.supplierId;
  }
  const supplier = await prisma2.supplier.create({
    data: {
      name: payload.supplierName
    }
  });
  return supplier.id;
};
var prepareItemTotals = (item) => {
  const baseValue = item.costPrice * item.quantity;
  const discountValue = baseValue * (item.discountPercent ?? 0) * 0.01;
  const taxableValue = baseValue - discountValue;
  const taxValue = taxableValue * item.taxPercent * 0.01;
  return {
    lineTotal: taxableValue + taxValue,
    taxAmount: taxValue
  };
};
var upsertBatch = async (tx, item) => {
  const totalQuantity = item.quantity + (item.freeQuantity ?? 0);
  const batchKey = {
    productId_batchNumber: {
      productId: item.productId,
      batchNumber: item.batchNumber
    }
  };
  const batch = await tx.batch.upsert({
    where: batchKey,
    create: {
      productId: item.productId,
      batchNumber: item.batchNumber,
      godownId: item.godownId,
      expiryDate: new Date(item.expiryDate),
      mrp: toDecimal(item.mrp),
      ptr: toDecimal(item.ptr ?? item.costPrice),
      pts: toDecimal(item.pts ?? item.costPrice),
      taxPercent: toDecimal(item.taxPercent),
      quantity: 0
      // Start with 0, ledger will set correct quantity
    },
    update: {
      godownId: item.godownId,
      expiryDate: new Date(item.expiryDate),
      mrp: toDecimal(item.mrp),
      ptr: toDecimal(item.ptr ?? item.costPrice),
      pts: toDecimal(item.pts ?? item.costPrice),
      taxPercent: toDecimal(item.taxPercent)
      // Don't update quantity here - ledger service will handle it
    }
  });
  return { batch, totalQuantity };
};
var createPurchaseInvoice = async (payload) => {
  if (!payload.supplierName || payload.supplierName.trim() === "") {
    throw new Error("Supplier name is required");
  }
  if (!payload.items || payload.items.length === 0) {
    throw new Error("Invoice must contain at least one item");
  }
  if (!payload.invoiceNumber || payload.invoiceNumber.trim() === "") {
    throw new Error("Invoice number is required");
  }
  if (!payload.invoiceDate) {
    throw new Error("Invoice date is required");
  }
  for (let i = 0; i < payload.items.length; i++) {
    const item = payload.items[i];
    if (!item.productId || item.productId <= 0) {
      throw new Error(`Item ${i + 1}: Product is required`);
    }
    if (!item.quantity || item.quantity <= 0) {
      throw new Error(`Item ${i + 1}: Quantity must be greater than 0`);
    }
    if (!item.batchNumber || item.batchNumber.trim() === "") {
      throw new Error(`Item ${i + 1}: Batch number is required`);
    }
    if (!item.expiryDate) {
      throw new Error(`Item ${i + 1}: Expiry date is required`);
    }
    if (!item.costPrice || item.costPrice <= 0 || isNaN(item.costPrice)) {
      throw new Error(`Item ${i + 1}: Cost price is required and must be valid`);
    }
    if (!item.mrp || item.mrp <= 0 || isNaN(item.mrp)) {
      throw new Error(`Item ${i + 1}: MRP is required and must be valid`);
    }
    if (!item.taxPercent || isNaN(item.taxPercent)) {
      throw new Error(`Item ${i + 1}: Tax percent is required`);
    }
    if (isNaN(item.discountPercent ?? 0)) {
      throw new Error(`Item ${i + 1}: Discount percent must be valid`);
    }
  }
  const prisma2 = getPrismaClient();
  return prisma2.$transaction(
    async (tx) => {
      const supplierId = await ensureSupplier(payload, tx);
      for (const item of payload.items) {
        const product = await tx.product.findUnique({
          where: { id: item.productId }
        });
        if (!product) {
          throw new Error(`Product with ID ${item.productId} not found`);
        }
      }
      const totals = payload.items.reduce(
        (acc, item) => {
          const { lineTotal, taxAmount } = prepareItemTotals(item);
          return {
            amount: acc.amount + lineTotal,
            tax: acc.tax + taxAmount
          };
        },
        { amount: 0, tax: 0 }
      );
      const invoice = await tx.purchaseInvoice.create({
        data: {
          invoiceNumber: payload.invoiceNumber,
          supplierId,
          supplierName: payload.supplierName,
          invoiceDate: new Date(payload.invoiceDate),
          totalAmount: toDecimal(totals.amount),
          totalTax: toDecimal(totals.tax),
          notes: payload.notes,
          items: {
            create: await Promise.all(
              payload.items.map(async (item) => {
                const { batch, totalQuantity } = await upsertBatch(tx, item);
                const { createLedgerEntry: createLedgerEntry2 } = await Promise.resolve().then(() => (init_stockLedgerService(), stockLedgerService_exports));
                await createLedgerEntry2({
                  productId: item.productId,
                  batchId: batch.id,
                  godownId: item.godownId,
                  movementType: "PURCHASE",
                  reference: payload.invoiceNumber,
                  quantityChange: totalQuantity,
                  narration: `GRN for invoice ${payload.invoiceNumber}`,
                  tx
                });
                const { lineTotal } = prepareItemTotals(item);
                return {
                  productId: item.productId,
                  batchId: batch.id,
                  quantity: item.quantity,
                  freeQuantity: item.freeQuantity ?? 0,
                  costPrice: toDecimal(item.costPrice),
                  taxPercent: toDecimal(item.taxPercent),
                  discountPercent: toDecimal(item.discountPercent ?? 0),
                  lineTotal: toDecimal(lineTotal)
                };
              })
            )
          }
        },
        include: {
          supplier: true,
          items: {
            include: {
              product: true,
              batch: true
            }
          }
        }
      });
      logAuditAsync({
        entity: "PurchaseInvoice",
        entityId: invoice.id,
        action: "CREATE",
        details: {
          invoiceNumber: invoice.invoiceNumber,
          supplierName: invoice.supplierName,
          totalAmount: invoice.totalAmount
        }
      });
      return mapPurchaseInvoice(invoice);
    },
    { timeout: 3e4 }
    // Increased to 30s for complex purchases with batch creation
  );
};
var listPurchaseInvoices = async () => {
  const prisma2 = getPrismaClient();
  const invoices = await prisma2.purchaseInvoice.findMany({
    where: {
      deletedAt: null
      // Exclude deleted invoices
    },
    orderBy: { invoiceDate: "desc" },
    take: 20,
    include: {
      supplier: true,
      items: {
        include: {
          product: true,
          batch: true
        }
      }
    }
  });
  return invoices.map(mapPurchaseInvoice);
};
var getPurchaseInvoiceById = async (id) => {
  const prisma2 = getPrismaClient();
  const invoice = await prisma2.purchaseInvoice.findUnique({
    where: { id },
    include: {
      supplier: true,
      items: {
        include: {
          product: true,
          batch: true
        }
      }
    }
  });
  if (!invoice) {
    throw new Error("Purchase invoice not found");
  }
  return mapPurchaseInvoice(invoice);
};
var deletePurchaseInvoice = async (id, userId, reason, force) => {
  const { safeDeletePurchaseInvoice: safeDeletePurchaseInvoice2 } = await Promise.resolve().then(() => (init_safeDeleteService(), safeDeleteService_exports));
  if (!userId) {
    throw new Error("User ID is required for deletion");
  }
  await safeDeletePurchaseInvoice2(id, { userId, reason, force });
};

// electron/src/services/salesService.ts
var import_client9 = require("@prisma/client");
init_prismaClient();
init_auditService();
var toDecimal2 = (value) => new import_client9.Prisma.Decimal(Number(value || 0));
var mapSalesInvoice = (invoice) => ({
  id: invoice.id,
  invoiceNumber: invoice.invoiceNumber,
  customerId: invoice.customer.id,
  customerName: invoice.customer.name,
  mrId: invoice.mr?.id,
  mrName: invoice.mr?.name,
  doctorId: invoice.doctor?.id,
  doctorName: invoice.doctor?.name,
  invoiceDate: invoice.invoiceDate.toISOString(),
  billingType: invoice.billingType,
  challanNumber: invoice.challanNumber ?? void 0,
  orderNumber: invoice.orderNumber ?? void 0,
  totalAmount: Number(invoice.totalAmount),
  totalTax: Number(invoice.totalTax),
  roundOff: Number(invoice.roundOff),
  paidAmount: Number(invoice.paidAmount),
  paymentStatus: invoice.paymentStatus,
  notes: invoice.notes ?? void 0,
  items: invoice.items.map((item) => ({
    id: item.id,
    productId: item.productId,
    productName: item.product?.name ?? "",
    batchNumber: item.batch?.batchNumber,
    quantity: item.quantity,
    mrp: Number(item.mrp),
    salePrice: Number(item.salePrice),
    taxPercent: Number(item.taxPercent),
    discountPercent: Number(item.discountPercent),
    lineTotal: Number(item.lineTotal)
  }))
});
var allocateFefoBatch = async (tx, productId, quantity, batchId) => {
  if (batchId) {
    const batch = await tx.batch.findUnique({
      where: { id: batchId }
    });
    if (!batch || batch.productId !== productId) {
      throw new Error("Invalid batch for this product");
    }
    if (batch.quantity < quantity) {
      throw new Error("Insufficient batch quantity");
    }
    return [{
      batchId: batch.id,
      quantity,
      mrp: batch.mrp
    }];
  }
  const batches = await tx.batch.findMany({
    where: {
      productId,
      quantity: { gt: 0 },
      expiryDate: { gt: /* @__PURE__ */ new Date() }
    },
    orderBy: {
      expiryDate: "asc"
    }
  });
  const allocations = [];
  let remaining = quantity;
  for (const batch of batches) {
    if (remaining <= 0) break;
    const used = Math.min(batch.quantity, remaining);
    allocations.push({
      batchId: batch.id,
      quantity: used,
      mrp: batch.mrp
    });
    remaining -= used;
  }
  if (remaining > 0) {
    throw new Error("Insufficient stock to allocate sale");
  }
  return allocations;
};
var generateInvoiceNumber = async (invoiceDate) => {
  const prisma2 = getPrismaClient();
  const { getFinancialYear: getFinancialYear2 } = await Promise.resolve().then(() => (init_gstComplianceService(), gstComplianceService_exports));
  const { fyString } = getFinancialYear2(invoiceDate);
  const lastInvoice = await prisma2.salesInvoice.findFirst({
    where: {
      invoiceNumber: {
        startsWith: `INV-${fyString}-`
      }
    },
    orderBy: {
      invoiceNumber: "desc"
    }
  });
  let sequence = 1;
  if (lastInvoice) {
    const match = lastInvoice.invoiceNumber.match(/-(\d+)$/);
    if (match) {
      sequence = parseInt(match[1], 10) + 1;
    }
  }
  return `INV-${fyString}-${String(sequence).padStart(4, "0")}`;
};
var createSalesInvoice = async (payload) => {
  if (!payload.customerId || payload.customerId <= 0) {
    throw new Error("Customer is required");
  }
  if (!payload.items || payload.items.length === 0) {
    throw new Error("Invoice must contain at least one item");
  }
  if (!payload.invoiceDate) {
    throw new Error("Invoice date is required");
  }
  const invoiceNumber = (payload.invoiceNumber?.trim() || "").length > 0 ? payload.invoiceNumber.trim() : await generateInvoiceNumber(new Date(payload.invoiceDate));
  for (let i = 0; i < payload.items.length; i++) {
    const item = payload.items[i];
    if (!item.productId || item.productId <= 0) {
      throw new Error(`Item ${i + 1}: Product is required`);
    }
    if (!item.quantity || item.quantity <= 0) {
      throw new Error(`Item ${i + 1}: Quantity must be greater than 0`);
    }
    if (!item.salePrice || item.salePrice <= 0 || isNaN(item.salePrice)) {
      throw new Error(`Item ${i + 1}: Sale price is required and must be valid`);
    }
    if (!item.taxPercent || isNaN(item.taxPercent)) {
      throw new Error(`Item ${i + 1}: Tax percent is required`);
    }
    if (isNaN(item.discountPercent ?? 0)) {
      throw new Error(`Item ${i + 1}: Discount percent must be valid`);
    }
  }
  const prisma2 = getPrismaClient();
  return prisma2.$transaction(
    async (tx) => {
      const customer = await tx.customer.findUnique({
        where: { id: payload.customerId }
      });
      if (!customer) {
        throw new Error("Customer not found");
      }
      for (const item of payload.items) {
        const product = await tx.product.findUnique({
          where: { id: item.productId }
        });
        if (!product) {
          throw new Error(`Product with ID ${item.productId} not found`);
        }
        if (item.batchId) {
          const batch = await tx.batch.findUnique({
            where: { id: item.batchId }
          });
          if (!batch || batch.productId !== item.productId) {
            throw new Error(`Invalid batch selection for product ${product.name}`);
          }
        }
      }
      const totals = payload.items.reduce(
        (acc, item) => {
          const base = item.salePrice * item.quantity;
          const discount = base * (item.discountPercent ?? 0) * 0.01;
          const taxable = base - discount;
          const tax = taxable * item.taxPercent * 0.01;
          return {
            amount: acc.amount + taxable + tax,
            tax: acc.tax + tax
          };
        },
        { amount: 0, tax: 0 }
      );
      const productDetails = await Promise.all(
        payload.items.map(async (item) => {
          const product = await tx.product.findUnique({
            where: { id: item.productId },
            select: { stripQuantity: true }
          });
          return {
            item,
            product,
            stripQuantity: product?.stripQuantity ?? item.stripQuantity ?? 1
          };
        })
      );
      const itemsWithQuantities = productDetails.map(({ item, stripQuantity }) => {
        let actualQuantity = item.quantity;
        if (item.soldInStrips && stripQuantity) {
          actualQuantity = item.quantity * stripQuantity;
        }
        return { item, actualQuantity, stripQuantity };
      });
      const invoice = await tx.salesInvoice.create({
        data: {
          invoiceNumber: payload.invoiceNumber,
          customerId: customer.id,
          mrId: payload.mrId,
          doctorId: payload.doctorId,
          invoiceDate: new Date(payload.invoiceDate),
          billingType: payload.billingType ?? "CASH",
          challanNumber: payload.challanNumber,
          orderNumber: payload.orderNumber,
          totalAmount: toDecimal2(totals.amount),
          totalTax: toDecimal2(totals.tax),
          roundOff: toDecimal2(0),
          paidAmount: payload.billingType === "CASH" ? toDecimal2(totals.amount) : toDecimal2(0),
          paymentStatus: payload.billingType === "CASH" ? "PAID" : "UNPAID",
          notes: payload.notes,
          items: {
            create: (await Promise.all(
              itemsWithQuantities.map(async ({ item, actualQuantity, stripQuantity }) => {
                const allocations = await allocateFefoBatch(
                  tx,
                  item.productId,
                  actualQuantity,
                  item.batchId
                );
                return Promise.all(
                  allocations.map(async (allocation) => {
                    const { createLedgerEntry: createLedgerEntry2 } = await Promise.resolve().then(() => (init_stockLedgerService(), stockLedgerService_exports));
                    const ledgerResult = await createLedgerEntry2({
                      productId: item.productId,
                      batchId: allocation.batchId,
                      movementType: "SALE",
                      reference: payload.invoiceNumber,
                      quantityChange: -allocation.quantity,
                      narration: `Sale invoice ${payload.invoiceNumber}`,
                      tx
                    });
                    const base = item.salePrice * (item.soldInStrips ? item.quantity : actualQuantity);
                    const discount = base * (item.discountPercent ?? 0) * 0.01;
                    const taxable = base - discount;
                    const tax = taxable * item.taxPercent * 0.01;
                    return {
                      productId: item.productId,
                      batchId: allocation.batchId,
                      quantity: item.soldInStrips ? item.quantity : actualQuantity,
                      soldInStrips: item.soldInStrips ?? false,
                      stripQuantity,
                      freeQuantity: 0,
                      mrp: allocation.mrp,
                      salePrice: toDecimal2(item.salePrice),
                      taxPercent: toDecimal2(item.taxPercent),
                      discountPercent: toDecimal2(
                        item.discountPercent ?? 0
                      ),
                      lineTotal: toDecimal2(taxable + tax)
                    };
                  })
                );
              })
            )).flat()
          }
        },
        include: {
          customer: true,
          mr: true,
          doctor: true,
          items: {
            include: {
              product: true,
              batch: true
            }
          }
        }
      });
      logAuditAsync({
        entity: "SalesInvoice",
        entityId: invoice.id,
        action: "CREATE",
        details: {
          invoiceNumber: invoice.invoiceNumber,
          customerName: invoice.customer.name,
          totalAmount: invoice.totalAmount
        }
      });
      return mapSalesInvoice(invoice);
    },
    { timeout: 3e4 }
    // Increased to 30s for complex sales with multiple items
  );
};
var listSalesInvoices = async () => {
  const prisma2 = getPrismaClient();
  const invoices = await prisma2.salesInvoice.findMany({
    where: {
      deletedAt: null
      // Exclude deleted invoices
    },
    orderBy: { invoiceDate: "desc" },
    take: 50,
    include: {
      customer: true,
      items: {
        include: {
          product: true,
          batch: true
        }
      }
    }
  });
  return invoices.map(mapSalesInvoice);
};
var getSalesInvoiceById = async (id) => {
  const prisma2 = getPrismaClient();
  const invoice = await prisma2.salesInvoice.findUnique({
    where: { id },
    include: {
      customer: true,
      items: {
        include: {
          product: true,
          batch: true
        }
      }
    }
  });
  if (!invoice) {
    throw new Error("Sales invoice not found");
  }
  return mapSalesInvoice(invoice);
};
var deleteSalesInvoice = async (id, userId, reason, force) => {
  const { safeDeleteSalesInvoice: safeDeleteSalesInvoice2 } = await Promise.resolve().then(() => (init_safeDeleteService(), safeDeleteService_exports));
  if (!userId) {
    throw new Error("User ID is required for deletion");
  }
  await safeDeleteSalesInvoice2(id, { userId, reason, force });
};

// electron/src/services/creditNoteService.ts
var import_client10 = require("@prisma/client");
init_prismaClient();
init_auditService();
var toDecimal3 = (value) => new import_client10.Prisma.Decimal(Number(value || 0));
var mapCreditNote = (note) => ({
  id: note.id,
  creditNoteNumber: note.creditNoteNumber,
  salesInvoiceId: note.salesInvoiceId,
  salesInvoiceNumber: note.salesInvoice?.invoiceNumber ?? "",
  creditDate: note.creditDate.toISOString(),
  totalAmount: Number(note.totalAmount),
  notes: note.notes ?? void 0,
  createdAt: note.createdAt.toISOString()
});
var createCreditNote = async (payload) => {
  if (!payload.salesInvoiceId || payload.salesInvoiceId <= 0) {
    throw new Error("Sales invoice ID is required");
  }
  if (!payload.creditNoteNumber || payload.creditNoteNumber.trim() === "") {
    throw new Error("Credit note number is required");
  }
  if (!payload.creditDate) {
    throw new Error("Credit date is required");
  }
  if (!payload.items || payload.items.length === 0) {
    throw new Error("Credit note must contain at least one item");
  }
  for (let i = 0; i < payload.items.length; i++) {
    const item = payload.items[i];
    if (!item.salesItemId || item.salesItemId <= 0) {
      throw new Error(`Item ${i + 1}: Sales item ID is required`);
    }
    if (!item.quantity || item.quantity <= 0) {
      throw new Error(`Item ${i + 1}: Quantity must be greater than 0`);
    }
  }
  const prisma2 = getPrismaClient();
  return prisma2.$transaction(
    async (tx) => {
      const salesInvoice = await tx.salesInvoice.findUnique({
        where: { id: payload.salesInvoiceId },
        include: {
          items: {
            include: {
              product: true,
              batch: true
            }
          }
        }
      });
      if (!salesInvoice) {
        throw new Error("Sales invoice not found");
      }
      let totalAmount = 0;
      for (const itemInput of payload.items) {
        const salesItem = salesInvoice.items.find(
          (item) => item.id === itemInput.salesItemId
        );
        if (!salesItem) {
          throw new Error(`Sales item ${itemInput.salesItemId} not found`);
        }
        if (itemInput.quantity > salesItem.quantity) {
          throw new Error("Return quantity exceeds sold quantity");
        }
        const returnValue = Number(salesItem.lineTotal) * (itemInput.quantity / salesItem.quantity);
        totalAmount += returnValue;
        if (salesItem.batchId) {
          const batch = await tx.batch.findUnique({
            where: { id: salesItem.batchId }
          });
          if (batch) {
            const { createLedgerEntry: createLedgerEntry2 } = await Promise.resolve().then(() => (init_stockLedgerService(), stockLedgerService_exports));
            await createLedgerEntry2({
              productId: salesItem.productId,
              batchId: batch.id,
              movementType: "RETURN",
              reference: payload.creditNoteNumber,
              quantityChange: itemInput.quantity,
              narration: `Credit note ${payload.creditNoteNumber} - ${itemInput.reason ?? "Return"}`,
              tx
            });
          }
        }
      }
      const creditNote = await tx.creditNote.create({
        data: {
          creditNoteNumber: payload.creditNoteNumber,
          salesInvoiceId: payload.salesInvoiceId,
          creditDate: new Date(payload.creditDate),
          totalAmount: toDecimal3(totalAmount),
          notes: payload.notes
        },
        include: {
          salesInvoice: true
        }
      });
      await logAudit({
        entity: "CreditNote",
        entityId: creditNote.id,
        action: "CREATE",
        details: {
          creditNoteNumber: creditNote.creditNoteNumber,
          salesInvoiceId: payload.salesInvoiceId,
          totalAmount: creditNote.totalAmount
        }
      });
      return mapCreditNote(creditNote);
    },
    { timeout: 1e4 }
  );
};
var listCreditNotes = async () => {
  const prisma2 = getPrismaClient();
  const notes = await prisma2.creditNote.findMany({
    orderBy: { creditDate: "desc" },
    take: 50,
    include: {
      salesInvoice: true
    }
  });
  return notes.map(mapCreditNote);
};
var getCreditNoteById = async (id) => {
  const prisma2 = getPrismaClient();
  const note = await prisma2.creditNote.findUnique({
    where: { id },
    include: {
      salesInvoice: true
    }
  });
  if (!note) {
    throw new Error("Credit note not found");
  }
  return mapCreditNote(note);
};

// electron/src/services/paymentService.ts
var import_client11 = require("@prisma/client");
init_prismaClient();
init_auditService();
var toNumber5 = (value) => {
  if (value instanceof import_client11.Prisma.Decimal) {
    return value.toNumber();
  }
  return Number(value ?? 0);
};
var mapPayment = (payment) => ({
  id: payment.id,
  salesInvoiceId: payment.salesInvoiceId ?? void 0,
  purchaseInvoiceId: payment.purchaseInvoiceId ?? void 0,
  amount: toNumber5(payment.amount),
  paymentDate: payment.paymentDate.toISOString(),
  paymentMethod: payment.paymentMethod,
  referenceNumber: payment.referenceNumber ?? void 0,
  chequeNumber: payment.chequeNumber ?? void 0,
  bank: payment.bank ?? void 0,
  chequeIssueDate: payment.chequeIssueDate?.toISOString(),
  isCleared: payment.isCleared ?? void 0,
  clearedDate: payment.clearedDate?.toISOString(),
  bouncedDate: payment.bouncedDate?.toISOString(),
  notes: payment.notes ?? void 0,
  createdAt: payment.createdAt.toISOString()
});
var createPayment = async (payload) => {
  if (!payload.amount || payload.amount <= 0 || isNaN(payload.amount)) {
    throw new Error("Payment amount must be greater than 0");
  }
  if (!payload.salesInvoiceId && !payload.purchaseInvoiceId) {
    throw new Error("Either sales invoice or purchase invoice ID is required");
  }
  if (payload.salesInvoiceId && payload.purchaseInvoiceId) {
    throw new Error("Cannot specify both sales and purchase invoice");
  }
  if (!payload.paymentDate) {
    throw new Error("Payment date is required");
  }
  if (!payload.paymentMethod || payload.paymentMethod.trim() === "") {
    throw new Error("Payment method is required");
  }
  if (payload.salesInvoiceId && payload.salesInvoiceId <= 0) {
    throw new Error("Invalid sales invoice ID");
  }
  if (payload.purchaseInvoiceId && payload.purchaseInvoiceId <= 0) {
    throw new Error("Invalid purchase invoice ID");
  }
  const prisma2 = getPrismaClient();
  return prisma2.$transaction(
    async (tx) => {
      let invoice = null;
      let invoiceType = "sales";
      if (payload.salesInvoiceId) {
        invoice = await tx.salesInvoice.findUnique({
          where: { id: payload.salesInvoiceId },
          select: { id: true, totalAmount: true, paidAmount: true, paymentStatus: true }
        });
        if (!invoice) {
          throw new Error("Sales invoice not found");
        }
      } else if (payload.purchaseInvoiceId) {
        invoice = await tx.purchaseInvoice.findUnique({
          where: { id: payload.purchaseInvoiceId },
          select: { id: true, totalAmount: true, paidAmount: true, paymentStatus: true }
        });
        if (!invoice) {
          throw new Error("Purchase invoice not found");
        }
        invoiceType = "purchase";
      }
      if (!invoice) {
        throw new Error("Invoice not found");
      }
      const currentPaid = toNumber5(invoice.paidAmount);
      const newPaid = currentPaid + payload.amount;
      const totalAmount = toNumber5(invoice.totalAmount);
      if (newPaid > totalAmount) {
        throw new Error("Payment amount exceeds invoice total");
      }
      const payment = await tx.payment.create({
        data: {
          salesInvoiceId: payload.salesInvoiceId,
          purchaseInvoiceId: payload.purchaseInvoiceId,
          amount: new import_client11.Prisma.Decimal(payload.amount),
          paymentDate: new Date(payload.paymentDate),
          paymentMethod: payload.paymentMethod,
          referenceNumber: payload.referenceNumber,
          chequeNumber: payload.chequeNumber,
          bank: payload.bank,
          chequeIssueDate: payload.chequeIssueDate ? new Date(payload.chequeIssueDate) : null,
          notes: payload.notes
        }
      });
      const paymentStatus = newPaid >= totalAmount ? "PAID" : newPaid > 0 ? "PARTIAL" : "UNPAID";
      if (invoiceType === "sales") {
        await tx.salesInvoice.update({
          where: { id: invoice.id },
          data: {
            paidAmount: new import_client11.Prisma.Decimal(newPaid),
            paymentStatus
          }
        });
      } else {
        await tx.purchaseInvoice.update({
          where: { id: invoice.id },
          data: {
            paidAmount: new import_client11.Prisma.Decimal(newPaid),
            paymentStatus
          }
        });
      }
      logAuditAsync({
        entity: "Payment",
        entityId: payment.id,
        action: "CREATE",
        details: {
          amount: payload.amount,
          invoiceType,
          invoiceId: invoice.id
        }
      });
      return mapPayment(payment);
    },
    { timeout: 3e4 }
    // Increased to 30s for payment processing
  );
};
var listPayments = async (filters) => {
  const prisma2 = getPrismaClient();
  const payments = await prisma2.payment.findMany({
    where: {
      ...filters?.salesInvoiceId && { salesInvoiceId: filters.salesInvoiceId },
      ...filters?.purchaseInvoiceId && { purchaseInvoiceId: filters.purchaseInvoiceId },
      ...filters?.fromDate || filters?.toDate ? {
        paymentDate: {
          ...filters.fromDate && { gte: new Date(filters.fromDate) },
          ...filters.toDate && { lte: new Date(filters.toDate) }
        }
      } : void 0
    },
    orderBy: { paymentDate: "desc" }
  });
  return payments.map(mapPayment);
};
var updatePayment = async (id, payload) => {
  const prisma2 = getPrismaClient();
  const payment = await prisma2.payment.findUnique({
    where: { id }
  });
  if (!payment) {
    throw new Error("Payment not found");
  }
  const updated = await prisma2.payment.update({
    where: { id },
    data: {
      ...payload.amount !== void 0 && { amount: new import_client11.Prisma.Decimal(payload.amount) },
      ...payload.paymentDate && { paymentDate: new Date(payload.paymentDate) },
      ...payload.paymentMethod && { paymentMethod: payload.paymentMethod },
      ...payload.referenceNumber !== void 0 && { referenceNumber: payload.referenceNumber },
      ...payload.chequeNumber !== void 0 && { chequeNumber: payload.chequeNumber },
      ...payload.bank !== void 0 && { bank: payload.bank },
      ...payload.chequeIssueDate !== void 0 && {
        chequeIssueDate: payload.chequeIssueDate ? new Date(payload.chequeIssueDate) : null
      },
      ...payload.notes !== void 0 && { notes: payload.notes }
    }
  });
  await logAudit({
    entity: "Payment",
    entityId: id,
    action: "UPDATE",
    details: { amount: toNumber5(updated.amount) }
  });
  return mapPayment(updated);
};
var markChequeCleared = async (id) => {
  const prisma2 = getPrismaClient();
  const payment = await prisma2.payment.findUnique({
    where: { id }
  });
  if (!payment) {
    throw new Error("Payment not found");
  }
  if (payment.paymentMethod !== "CHEQUE") {
    throw new Error("Payment is not a cheque");
  }
  const updated = await prisma2.payment.update({
    where: { id },
    data: {
      isCleared: true,
      clearedDate: /* @__PURE__ */ new Date()
    }
  });
  await logAudit({
    entity: "Payment",
    entityId: id,
    action: "CHEQUE_CLEARED",
    details: { chequeNumber: payment.chequeNumber }
  });
  return mapPayment(updated);
};
var markChequeBounced = async (id) => {
  const prisma2 = getPrismaClient();
  const payment = await prisma2.payment.findUnique({
    where: { id }
  });
  if (!payment) {
    throw new Error("Payment not found");
  }
  if (payment.paymentMethod !== "CHEQUE") {
    throw new Error("Payment is not a cheque");
  }
  return prisma2.$transaction(
    async (tx) => {
      let invoice = null;
      let invoiceType = "sales";
      if (payment.salesInvoiceId) {
        invoice = await tx.salesInvoice.findUnique({
          where: { id: payment.salesInvoiceId },
          select: { id: true, totalAmount: true, paidAmount: true }
        });
      } else if (payment.purchaseInvoiceId) {
        invoice = await tx.purchaseInvoice.findUnique({
          where: { id: payment.purchaseInvoiceId },
          select: { id: true, totalAmount: true, paidAmount: true }
        });
        invoiceType = "purchase";
      }
      if (invoice) {
        const currentPaid = toNumber5(invoice.paidAmount);
        const paymentAmount = toNumber5(payment.amount);
        const newPaid = Math.max(0, currentPaid - paymentAmount);
        const totalAmount = toNumber5(invoice.totalAmount);
        const paymentStatus = newPaid >= totalAmount ? "PAID" : newPaid > 0 ? "PARTIAL" : "UNPAID";
        if (invoiceType === "sales") {
          await tx.salesInvoice.update({
            where: { id: invoice.id },
            data: {
              paidAmount: new import_client11.Prisma.Decimal(newPaid),
              paymentStatus
            }
          });
        } else {
          await tx.purchaseInvoice.update({
            where: { id: invoice.id },
            data: {
              paidAmount: new import_client11.Prisma.Decimal(newPaid),
              paymentStatus
            }
          });
        }
      }
      const updated = await tx.payment.update({
        where: { id },
        data: {
          isCleared: false,
          bouncedDate: /* @__PURE__ */ new Date()
        }
      });
      logAuditAsync({
        entity: "Payment",
        entityId: id,
        action: "CHEQUE_BOUNCED",
        details: { chequeNumber: payment.chequeNumber }
      });
      return mapPayment(updated);
    },
    { timeout: 3e4 }
    // Increased to 30s for payment processing
  );
};
var deletePayment = async (id) => {
  const prisma2 = getPrismaClient();
  return prisma2.$transaction(
    async (tx) => {
      const payment = await tx.payment.findUnique({
        where: { id }
      });
      if (!payment) {
        throw new Error("Payment not found");
      }
      let invoice = null;
      let invoiceType = "sales";
      if (payment.salesInvoiceId) {
        invoice = await tx.salesInvoice.findUnique({
          where: { id: payment.salesInvoiceId },
          select: { id: true, totalAmount: true, paidAmount: true }
        });
      } else if (payment.purchaseInvoiceId) {
        invoice = await tx.purchaseInvoice.findUnique({
          where: { id: payment.purchaseInvoiceId },
          select: { id: true, totalAmount: true, paidAmount: true }
        });
        invoiceType = "purchase";
      }
      if (invoice) {
        const currentPaid = toNumber5(invoice.paidAmount);
        const paymentAmount = toNumber5(payment.amount);
        const newPaid = Math.max(0, currentPaid - paymentAmount);
        const totalAmount = toNumber5(invoice.totalAmount);
        const paymentStatus = newPaid >= totalAmount ? "PAID" : newPaid > 0 ? "PARTIAL" : "UNPAID";
        if (invoiceType === "sales") {
          await tx.salesInvoice.update({
            where: { id: invoice.id },
            data: {
              paidAmount: new import_client11.Prisma.Decimal(newPaid),
              paymentStatus
            }
          });
        } else {
          await tx.purchaseInvoice.update({
            where: { id: invoice.id },
            data: {
              paidAmount: new import_client11.Prisma.Decimal(newPaid),
              paymentStatus
            }
          });
        }
      }
      await tx.payment.delete({ where: { id } });
      logAuditAsync({
        entity: "Payment",
        entityId: id,
        action: "DELETE",
        details: { amount: toNumber5(payment.amount) }
      });
    },
    { timeout: 3e4 }
    // Increased to 30s for payment processing
  );
};

// electron/src/services/mrService.ts
var import_client12 = require("@prisma/client");
init_prismaClient();
init_auditService();
var toNumber6 = (value) => {
  if (value instanceof import_client12.Prisma.Decimal) {
    return value.toNumber();
  }
  return Number(value ?? 0);
};
var mapMR = (mr) => ({
  id: mr.id,
  name: mr.name,
  code: mr.code ?? void 0,
  phone: mr.phone ?? void 0,
  email: mr.email ?? void 0,
  address: mr.address ?? void 0,
  commissionPercent: toNumber6(mr.commissionPercent),
  isActive: mr.isActive,
  createdAt: mr.createdAt.toISOString(),
  updatedAt: mr.updatedAt.toISOString()
});
var listMRs = async (search) => {
  const prisma2 = getPrismaClient();
  const mrs = await prisma2.mR.findMany({
    where: search ? {
      OR: [
        { name: { contains: search } },
        { code: { contains: search } }
      ]
    } : void 0,
    orderBy: { name: "asc" }
  });
  return mrs.map(mapMR);
};
var createMR = async (payload) => {
  if (!payload.name) {
    throw new Error("MR name is required");
  }
  const prisma2 = getPrismaClient();
  if (payload.code) {
    const existing = await prisma2.mR.findUnique({
      where: { code: payload.code }
    });
    if (existing) {
      throw new Error("MR with this code already exists");
    }
  }
  const mr = await prisma2.mR.create({
    data: {
      name: payload.name,
      code: payload.code,
      phone: payload.phone,
      email: payload.email,
      address: payload.address,
      commissionPercent: new import_client12.Prisma.Decimal(payload.commissionPercent ?? 0),
      isActive: payload.isActive ?? true
    }
  });
  await logAudit({
    entity: "MR",
    entityId: mr.id,
    action: "CREATE",
    details: { name: mr.name, code: mr.code }
  });
  return mapMR(mr);
};
var getMRById = async (id) => {
  const prisma2 = getPrismaClient();
  const mr = await prisma2.mR.findUnique({
    where: { id }
  });
  if (!mr) {
    throw new Error("MR not found");
  }
  return mapMR(mr);
};
var updateMR = async (id, payload) => {
  const prisma2 = getPrismaClient();
  if (payload.code) {
    const existing = await prisma2.mR.findUnique({
      where: { code: payload.code }
    });
    if (existing && existing.id !== id) {
      throw new Error("MR with this code already exists");
    }
  }
  const mr = await prisma2.mR.update({
    where: { id },
    data: {
      ...payload.name && { name: payload.name },
      ...payload.code !== void 0 && { code: payload.code },
      ...payload.phone !== void 0 && { phone: payload.phone },
      ...payload.email !== void 0 && { email: payload.email },
      ...payload.address !== void 0 && { address: payload.address },
      ...payload.commissionPercent !== void 0 && {
        commissionPercent: new import_client12.Prisma.Decimal(payload.commissionPercent)
      },
      ...payload.isActive !== void 0 && { isActive: payload.isActive }
    }
  });
  await logAudit({
    entity: "MR",
    entityId: mr.id,
    action: "UPDATE",
    details: { name: mr.name }
  });
  return mapMR(mr);
};
var deleteMR = async (id) => {
  const prisma2 = getPrismaClient();
  const mr = await prisma2.mR.findUnique({
    where: { id },
    include: {
      salesInvoices: { take: 1 }
    }
  });
  if (!mr) {
    throw new Error("MR not found");
  }
  if (mr.salesInvoices.length > 0) {
    throw new Error("Cannot delete MR with existing sales invoices");
  }
  await prisma2.mR.delete({ where: { id } });
  await logAudit({
    entity: "MR",
    entityId: id,
    action: "DELETE",
    details: { name: mr.name }
  });
};

// electron/src/services/doctorService.ts
var import_client13 = require("@prisma/client");
init_prismaClient();
init_auditService();
var toNumber7 = (value) => {
  if (value instanceof import_client13.Prisma.Decimal) {
    return value.toNumber();
  }
  return Number(value ?? 0);
};
var mapDoctor = (doctor) => ({
  id: doctor.id,
  name: doctor.name,
  code: doctor.code ?? void 0,
  phone: doctor.phone ?? void 0,
  email: doctor.email ?? void 0,
  address: doctor.address ?? void 0,
  commissionPercent: toNumber7(doctor.commissionPercent),
  isActive: doctor.isActive,
  createdAt: doctor.createdAt.toISOString(),
  updatedAt: doctor.updatedAt.toISOString()
});
var listDoctors = async (search) => {
  const prisma2 = getPrismaClient();
  const doctors = await prisma2.doctor.findMany({
    where: search ? {
      OR: [
        { name: { contains: search } },
        { code: { contains: search } }
      ]
    } : void 0,
    orderBy: { name: "asc" }
  });
  return doctors.map(mapDoctor);
};
var createDoctor = async (payload) => {
  if (!payload.name) {
    throw new Error("Doctor name is required");
  }
  const prisma2 = getPrismaClient();
  if (payload.code) {
    const existing = await prisma2.doctor.findUnique({
      where: { code: payload.code }
    });
    if (existing) {
      throw new Error("Doctor with this code already exists");
    }
  }
  const doctor = await prisma2.doctor.create({
    data: {
      name: payload.name,
      code: payload.code,
      phone: payload.phone,
      email: payload.email,
      address: payload.address,
      commissionPercent: new import_client13.Prisma.Decimal(payload.commissionPercent ?? 0),
      isActive: payload.isActive ?? true
    }
  });
  await logAudit({
    entity: "Doctor",
    entityId: doctor.id,
    action: "CREATE",
    details: { name: doctor.name, code: doctor.code }
  });
  return mapDoctor(doctor);
};
var getDoctorById = async (id) => {
  const prisma2 = getPrismaClient();
  const doctor = await prisma2.doctor.findUnique({
    where: { id }
  });
  if (!doctor) {
    throw new Error("Doctor not found");
  }
  return mapDoctor(doctor);
};
var updateDoctor = async (id, payload) => {
  const prisma2 = getPrismaClient();
  if (payload.code) {
    const existing = await prisma2.doctor.findUnique({
      where: { code: payload.code }
    });
    if (existing && existing.id !== id) {
      throw new Error("Doctor with this code already exists");
    }
  }
  const doctor = await prisma2.doctor.update({
    where: { id },
    data: {
      ...payload.name && { name: payload.name },
      ...payload.code !== void 0 && { code: payload.code },
      ...payload.phone !== void 0 && { phone: payload.phone },
      ...payload.email !== void 0 && { email: payload.email },
      ...payload.address !== void 0 && { address: payload.address },
      ...payload.commissionPercent !== void 0 && {
        commissionPercent: new import_client13.Prisma.Decimal(payload.commissionPercent)
      },
      ...payload.isActive !== void 0 && { isActive: payload.isActive }
    }
  });
  await logAudit({
    entity: "Doctor",
    entityId: doctor.id,
    action: "UPDATE",
    details: { name: doctor.name }
  });
  return mapDoctor(doctor);
};
var deleteDoctor = async (id) => {
  const prisma2 = getPrismaClient();
  const doctor = await prisma2.doctor.findUnique({
    where: { id },
    include: {
      salesInvoices: { take: 1 }
    }
  });
  if (!doctor) {
    throw new Error("Doctor not found");
  }
  if (doctor.salesInvoices.length > 0) {
    throw new Error("Cannot delete doctor with existing sales invoices");
  }
  await prisma2.doctor.delete({ where: { id } });
  await logAudit({
    entity: "Doctor",
    entityId: id,
    action: "DELETE",
    details: { name: doctor.name }
  });
};

// electron/src/services/categoryService.ts
init_prismaClient();
init_auditService();
var listCategories = async () => {
  const prisma2 = getPrismaClient();
  const categories = await prisma2.category.findMany({
    orderBy: { name: "asc" }
  });
  return categories.map((cat) => ({
    id: cat.id,
    name: cat.name,
    description: cat.description ?? void 0,
    createdAt: cat.createdAt.toISOString(),
    updatedAt: cat.updatedAt.toISOString()
  }));
};
var createCategory = async (payload) => {
  if (!payload.name) {
    throw new Error("Category name is required");
  }
  const prisma2 = getPrismaClient();
  const existing = await prisma2.category.findUnique({
    where: { name: payload.name }
  });
  if (existing) {
    throw new Error("Category with this name already exists");
  }
  const category = await prisma2.category.create({
    data: {
      name: payload.name,
      description: payload.description
    }
  });
  await logAudit({
    entity: "Category",
    entityId: category.id,
    action: "CREATE",
    details: { name: category.name }
  });
  return {
    id: category.id,
    name: category.name,
    description: category.description ?? void 0,
    createdAt: category.createdAt.toISOString(),
    updatedAt: category.updatedAt.toISOString()
  };
};
var updateCategory = async (id, payload) => {
  const prisma2 = getPrismaClient();
  if (payload.name) {
    const existing = await prisma2.category.findUnique({
      where: { name: payload.name }
    });
    if (existing && existing.id !== id) {
      throw new Error("Category with this name already exists");
    }
  }
  const category = await prisma2.category.update({
    where: { id },
    data: {
      ...payload.name && { name: payload.name },
      ...payload.description !== void 0 && { description: payload.description }
    }
  });
  await logAudit({
    entity: "Category",
    entityId: category.id,
    action: "UPDATE",
    details: { name: category.name }
  });
  return {
    id: category.id,
    name: category.name,
    description: category.description ?? void 0,
    createdAt: category.createdAt.toISOString(),
    updatedAt: category.updatedAt.toISOString()
  };
};
var deleteCategory = async (id) => {
  const prisma2 = getPrismaClient();
  const category = await prisma2.category.findUnique({
    where: { id },
    include: {
      products: { take: 1 }
    }
  });
  if (!category) {
    throw new Error("Category not found");
  }
  if (category.products.length > 0) {
    throw new Error("Cannot delete category with assigned products");
  }
  await prisma2.category.delete({ where: { id } });
  await logAudit({
    entity: "Category",
    entityId: id,
    action: "DELETE",
    details: { name: category.name }
  });
};
var listSubcategories = async (categoryId) => {
  const prisma2 = getPrismaClient();
  const subcategories = await prisma2.subcategory.findMany({
    where: categoryId ? { categoryId } : void 0,
    include: { category: true },
    orderBy: { name: "asc" }
  });
  return subcategories.map((sub) => ({
    id: sub.id,
    categoryId: sub.categoryId,
    categoryName: sub.category.name,
    name: sub.name,
    description: sub.description ?? void 0,
    createdAt: sub.createdAt.toISOString(),
    updatedAt: sub.updatedAt.toISOString()
  }));
};
var createSubcategory = async (payload) => {
  if (!payload.name || !payload.categoryId) {
    throw new Error("Subcategory name and category ID are required");
  }
  const prisma2 = getPrismaClient();
  const category = await prisma2.category.findUnique({
    where: { id: payload.categoryId }
  });
  if (!category) {
    throw new Error("Category not found");
  }
  const existing = await prisma2.subcategory.findUnique({
    where: {
      categoryId_name: {
        categoryId: payload.categoryId,
        name: payload.name
      }
    }
  });
  if (existing) {
    throw new Error("Subcategory with this name already exists in this category");
  }
  const subcategory = await prisma2.subcategory.create({
    data: {
      categoryId: payload.categoryId,
      name: payload.name,
      description: payload.description
    },
    include: { category: true }
  });
  await logAudit({
    entity: "Subcategory",
    entityId: subcategory.id,
    action: "CREATE",
    details: { name: subcategory.name, categoryId: payload.categoryId }
  });
  return {
    id: subcategory.id,
    categoryId: subcategory.categoryId,
    categoryName: subcategory.category.name,
    name: subcategory.name,
    description: subcategory.description ?? void 0,
    createdAt: subcategory.createdAt.toISOString(),
    updatedAt: subcategory.updatedAt.toISOString()
  };
};
var updateSubcategory = async (id, payload) => {
  const prisma2 = getPrismaClient();
  if (payload.name || payload.categoryId) {
    const existing = await prisma2.subcategory.findUnique({
      where: { id }
    });
    if (!existing) {
      throw new Error("Subcategory not found");
    }
    const categoryId = payload.categoryId ?? existing.categoryId;
    const name = payload.name ?? existing.name;
    const duplicate = await prisma2.subcategory.findUnique({
      where: {
        categoryId_name: {
          categoryId,
          name
        }
      }
    });
    if (duplicate && duplicate.id !== id) {
      throw new Error("Subcategory with this name already exists in this category");
    }
  }
  const subcategory = await prisma2.subcategory.update({
    where: { id },
    data: {
      ...payload.categoryId && { categoryId: payload.categoryId },
      ...payload.name && { name: payload.name },
      ...payload.description !== void 0 && { description: payload.description }
    },
    include: { category: true }
  });
  await logAudit({
    entity: "Subcategory",
    entityId: subcategory.id,
    action: "UPDATE",
    details: { name: subcategory.name }
  });
  return {
    id: subcategory.id,
    categoryId: subcategory.categoryId,
    categoryName: subcategory.category.name,
    name: subcategory.name,
    description: subcategory.description ?? void 0,
    createdAt: subcategory.createdAt.toISOString(),
    updatedAt: subcategory.updatedAt.toISOString()
  };
};
var deleteSubcategory = async (id) => {
  const prisma2 = getPrismaClient();
  const subcategory = await prisma2.subcategory.findUnique({
    where: { id },
    include: {
      products: { take: 1 }
    }
  });
  if (!subcategory) {
    throw new Error("Subcategory not found");
  }
  if (subcategory.products.length > 0) {
    throw new Error("Cannot delete subcategory with assigned products");
  }
  await prisma2.subcategory.delete({ where: { id } });
  await logAudit({
    entity: "Subcategory",
    entityId: id,
    action: "DELETE",
    details: { name: subcategory.name }
  });
};
var listCompanies = async () => {
  const prisma2 = getPrismaClient();
  const companies = await prisma2.company.findMany({
    orderBy: { name: "asc" }
  });
  return companies.map((comp) => ({
    id: comp.id,
    name: comp.name,
    description: comp.description ?? void 0,
    createdAt: comp.createdAt.toISOString(),
    updatedAt: comp.updatedAt.toISOString()
  }));
};
var createCompany = async (payload) => {
  if (!payload.name) {
    throw new Error("Company name is required");
  }
  const prisma2 = getPrismaClient();
  const existing = await prisma2.company.findUnique({
    where: { name: payload.name }
  });
  if (existing) {
    throw new Error("Company with this name already exists");
  }
  const company = await prisma2.company.create({
    data: {
      name: payload.name,
      description: payload.description
    }
  });
  await logAudit({
    entity: "Company",
    entityId: company.id,
    action: "CREATE",
    details: { name: company.name }
  });
  return {
    id: company.id,
    name: company.name,
    description: company.description ?? void 0,
    createdAt: company.createdAt.toISOString(),
    updatedAt: company.updatedAt.toISOString()
  };
};
var updateCompany = async (id, payload) => {
  const prisma2 = getPrismaClient();
  if (payload.name) {
    const existing = await prisma2.company.findUnique({
      where: { name: payload.name }
    });
    if (existing && existing.id !== id) {
      throw new Error("Company with this name already exists");
    }
  }
  const company = await prisma2.company.update({
    where: { id },
    data: {
      ...payload.name && { name: payload.name },
      ...payload.description !== void 0 && { description: payload.description }
    }
  });
  await logAudit({
    entity: "Company",
    entityId: company.id,
    action: "UPDATE",
    details: { name: company.name }
  });
  return {
    id: company.id,
    name: company.name,
    description: company.description ?? void 0,
    createdAt: company.createdAt.toISOString(),
    updatedAt: company.updatedAt.toISOString()
  };
};
var deleteCompany = async (id) => {
  const prisma2 = getPrismaClient();
  const company = await prisma2.company.findUnique({
    where: { id },
    include: {
      products: { take: 1 }
    }
  });
  if (!company) {
    throw new Error("Company not found");
  }
  if (company.products.length > 0) {
    throw new Error("Cannot delete company with assigned products");
  }
  await prisma2.company.delete({ where: { id } });
  await logAudit({
    entity: "Company",
    entityId: id,
    action: "DELETE",
    details: { name: company.name }
  });
};
var listSchedules = async () => {
  const prisma2 = getPrismaClient();
  const schedules = await prisma2.schedule.findMany({
    orderBy: { name: "asc" }
  });
  return schedules.map((sched) => ({
    id: sched.id,
    name: sched.name,
    description: sched.description ?? void 0,
    createdAt: sched.createdAt.toISOString(),
    updatedAt: sched.updatedAt.toISOString()
  }));
};
var createSchedule = async (payload) => {
  if (!payload.name) {
    throw new Error("Schedule name is required");
  }
  const prisma2 = getPrismaClient();
  const existing = await prisma2.schedule.findUnique({
    where: { name: payload.name }
  });
  if (existing) {
    throw new Error("Schedule with this name already exists");
  }
  const schedule = await prisma2.schedule.create({
    data: {
      name: payload.name,
      description: payload.description
    }
  });
  await logAudit({
    entity: "Schedule",
    entityId: schedule.id,
    action: "CREATE",
    details: { name: schedule.name }
  });
  return {
    id: schedule.id,
    name: schedule.name,
    description: schedule.description ?? void 0,
    createdAt: schedule.createdAt.toISOString(),
    updatedAt: schedule.updatedAt.toISOString()
  };
};
var updateSchedule = async (id, payload) => {
  const prisma2 = getPrismaClient();
  if (payload.name) {
    const existing = await prisma2.schedule.findUnique({
      where: { name: payload.name }
    });
    if (existing && existing.id !== id) {
      throw new Error("Schedule with this name already exists");
    }
  }
  const schedule = await prisma2.schedule.update({
    where: { id },
    data: {
      ...payload.name && { name: payload.name },
      ...payload.description !== void 0 && { description: payload.description }
    }
  });
  await logAudit({
    entity: "Schedule",
    entityId: schedule.id,
    action: "UPDATE",
    details: { name: schedule.name }
  });
  return {
    id: schedule.id,
    name: schedule.name,
    description: schedule.description ?? void 0,
    createdAt: schedule.createdAt.toISOString(),
    updatedAt: schedule.updatedAt.toISOString()
  };
};
var deleteSchedule = async (id) => {
  const prisma2 = getPrismaClient();
  const schedule = await prisma2.schedule.findUnique({
    where: { id },
    include: {
      products: { take: 1 }
    }
  });
  if (!schedule) {
    throw new Error("Schedule not found");
  }
  if (schedule.products.length > 0) {
    throw new Error("Cannot delete schedule with assigned products");
  }
  await prisma2.schedule.delete({ where: { id } });
  await logAudit({
    entity: "Schedule",
    entityId: id,
    action: "DELETE",
    details: { name: schedule.name }
  });
};
var listStorageTypes = async () => {
  const prisma2 = getPrismaClient();
  const storageTypes = await prisma2.storageType.findMany({
    orderBy: { name: "asc" }
  });
  return storageTypes.map((st) => ({
    id: st.id,
    name: st.name,
    description: st.description ?? void 0,
    createdAt: st.createdAt.toISOString(),
    updatedAt: st.updatedAt.toISOString()
  }));
};
var createStorageType = async (payload) => {
  if (!payload.name) {
    throw new Error("Storage type name is required");
  }
  const prisma2 = getPrismaClient();
  const existing = await prisma2.storageType.findUnique({
    where: { name: payload.name }
  });
  if (existing) {
    throw new Error("Storage type with this name already exists");
  }
  const storageType = await prisma2.storageType.create({
    data: {
      name: payload.name,
      description: payload.description
    }
  });
  await logAudit({
    entity: "StorageType",
    entityId: storageType.id,
    action: "CREATE",
    details: { name: storageType.name }
  });
  return {
    id: storageType.id,
    name: storageType.name,
    description: storageType.description ?? void 0,
    createdAt: storageType.createdAt.toISOString(),
    updatedAt: storageType.updatedAt.toISOString()
  };
};
var updateStorageType = async (id, payload) => {
  const prisma2 = getPrismaClient();
  if (payload.name) {
    const existing = await prisma2.storageType.findUnique({
      where: { name: payload.name }
    });
    if (existing && existing.id !== id) {
      throw new Error("Storage type with this name already exists");
    }
  }
  const storageType = await prisma2.storageType.update({
    where: { id },
    data: {
      ...payload.name && { name: payload.name },
      ...payload.description !== void 0 && { description: payload.description }
    }
  });
  await logAudit({
    entity: "StorageType",
    entityId: storageType.id,
    action: "UPDATE",
    details: { name: storageType.name }
  });
  return {
    id: storageType.id,
    name: storageType.name,
    description: storageType.description ?? void 0,
    createdAt: storageType.createdAt.toISOString(),
    updatedAt: storageType.updatedAt.toISOString()
  };
};
var deleteStorageType = async (id) => {
  const prisma2 = getPrismaClient();
  const storageType = await prisma2.storageType.findUnique({
    where: { id },
    include: {
      products: { take: 1 }
    }
  });
  if (!storageType) {
    throw new Error("Storage type not found");
  }
  if (storageType.products.length > 0) {
    throw new Error("Cannot delete storage type with assigned products");
  }
  await prisma2.storageType.delete({ where: { id } });
  await logAudit({
    entity: "StorageType",
    entityId: id,
    action: "DELETE",
    details: { name: storageType.name }
  });
};

// electron/src/services/globalSearchService.ts
init_prismaClient();
var globalSearch = async (request) => {
  const prisma2 = getPrismaClient();
  const page = request.page ?? 1;
  const pageSize = request.pageSize ?? 50;
  const skip = (page - 1) * pageSize;
  const query = request.query.trim().toLowerCase();
  const entityTypes = request.filters?.entityTypes;
  if (!query) {
    return {
      products: [],
      customers: [],
      suppliers: [],
      batches: [],
      invoices: [],
      mrs: [],
      doctors: [],
      total: 0,
      page,
      pageSize,
      totalPages: 0
    };
  }
  const results = {
    products: [],
    customers: [],
    suppliers: [],
    batches: [],
    invoices: [],
    mrs: [],
    doctors: [],
    total: 0,
    page,
    pageSize,
    totalPages: 0
  };
  if (!entityTypes || entityTypes.includes("product")) {
    const products = await prisma2.product.findMany({
      where: {
        OR: [
          { name: { contains: query } },
          { sku: { contains: query } },
          { manufacturer: { contains: query } },
          { drugCategory: { contains: query } },
          { drugGroup: { contains: query } },
          { barcode: { contains: query } },
          { stripCode: { contains: query } },
          { itemCode: { contains: query } },
          { hsnCode: { contains: query } }
        ]
      },
      select: {
        id: true,
        name: true,
        sku: true,
        manufacturer: true,
        drugCategory: true,
        drugGroup: true,
        barcode: true,
        stripCode: true,
        itemCode: true
      },
      take: pageSize,
      skip
    });
    results.products = products.map((p) => ({
      id: p.id,
      name: p.name,
      sku: p.sku,
      manufacturer: p.manufacturer ?? void 0,
      drugCategory: p.drugCategory ?? void 0,
      drugGroup: p.drugGroup ?? void 0,
      barcode: p.barcode ?? void 0,
      stripCode: p.stripCode ?? void 0,
      itemCode: p.itemCode ?? void 0
    }));
  }
  if (!entityTypes || entityTypes.includes("customer")) {
    const customers = await prisma2.customer.findMany({
      where: {
        OR: [
          { name: { contains: query } },
          { gstin: { contains: query } },
          { phone: { contains: query } },
          { email: { contains: query } }
        ]
      },
      select: {
        id: true,
        name: true,
        gstin: true,
        phone: true
      },
      take: pageSize,
      skip
    });
    results.customers = customers.map((c) => ({
      id: c.id,
      name: c.name,
      gstin: c.gstin ?? void 0,
      phone: c.phone ?? void 0
    }));
  }
  if (!entityTypes || entityTypes.includes("supplier")) {
    const suppliers = await prisma2.supplier.findMany({
      where: {
        OR: [
          { name: { contains: query } },
          { gstin: { contains: query } },
          { phone: { contains: query } },
          { email: { contains: query } }
        ]
      },
      select: {
        id: true,
        name: true,
        gstin: true,
        phone: true
      },
      take: pageSize,
      skip
    });
    results.suppliers = suppliers.map((s) => ({
      id: s.id,
      name: s.name,
      gstin: s.gstin ?? void 0,
      phone: s.phone ?? void 0
    }));
  }
  if (!entityTypes || entityTypes.includes("batch")) {
    const batches = await prisma2.batch.findMany({
      where: {
        batchNumber: { contains: query }
      },
      include: {
        product: true
      },
      take: pageSize,
      skip
    });
    results.batches = batches.map((b) => ({
      id: b.id,
      batchNumber: b.batchNumber,
      productName: b.product.name,
      expiryDate: b.expiryDate.toISOString()
    }));
  }
  if (!entityTypes || entityTypes.includes("invoice")) {
    const [salesInvoices, purchaseInvoices] = await Promise.all([
      prisma2.salesInvoice.findMany({
        where: {
          invoiceNumber: { contains: query }
        },
        select: {
          id: true,
          invoiceNumber: true,
          invoiceDate: true
        },
        take: Math.floor(pageSize / 2),
        skip: Math.floor(skip / 2)
      }),
      prisma2.purchaseInvoice.findMany({
        where: {
          invoiceNumber: { contains: query }
        },
        select: {
          id: true,
          invoiceNumber: true,
          invoiceDate: true
        },
        take: Math.floor(pageSize / 2),
        skip: Math.floor(skip / 2)
      })
    ]);
    results.invoices = [
      ...salesInvoices.map((inv) => ({
        id: inv.id,
        invoiceNumber: inv.invoiceNumber,
        type: "sales",
        date: inv.invoiceDate.toISOString()
      })),
      ...purchaseInvoices.map((inv) => ({
        id: inv.id,
        invoiceNumber: inv.invoiceNumber,
        type: "purchase",
        date: inv.invoiceDate.toISOString()
      }))
    ];
  }
  if (!entityTypes || entityTypes.includes("mr")) {
    const mrs = await prisma2.mR.findMany({
      where: {
        OR: [
          { name: { contains: query } },
          { code: { contains: query } }
        ]
      },
      select: {
        id: true,
        name: true,
        code: true
      },
      take: pageSize,
      skip
    });
    results.mrs = mrs.map((mr) => ({
      id: mr.id,
      name: mr.name,
      code: mr.code ?? void 0
    }));
  }
  if (!entityTypes || entityTypes.includes("doctor")) {
    const doctors = await prisma2.doctor.findMany({
      where: {
        OR: [
          { name: { contains: query } },
          { code: { contains: query } }
        ]
      },
      select: {
        id: true,
        name: true,
        code: true
      },
      take: pageSize,
      skip
    });
    results.doctors = doctors.map((doc) => ({
      id: doc.id,
      name: doc.name,
      code: doc.code ?? void 0
    }));
  }
  const total = results.products.length + results.customers.length + results.suppliers.length + results.batches.length + results.invoices.length + results.mrs.length + results.doctors.length;
  results.total = total;
  results.totalPages = Math.ceil(total / pageSize);
  return results;
};

// electron/src/services/barcodeSearchService.ts
init_prismaClient();
var searchByBarcode = async (code) => {
  if (!code || !code.trim()) {
    return { found: false, searchType: "notFound" };
  }
  const prisma2 = getPrismaClient();
  const searchCode = code.trim();
  let product = await prisma2.product.findFirst({
    where: { barcode: searchCode },
    include: {
      batches: {
        where: { quantity: { gt: 0 } },
        orderBy: { expiryDate: "asc" },
        take: 1
      }
    }
  });
  if (product) {
    return {
      found: true,
      searchType: "barcode",
      product: {
        id: product.id,
        name: product.name,
        sku: product.sku,
        manufacturer: product.manufacturer ?? void 0,
        drugCategory: product.drugCategory ?? void 0,
        drugGroup: product.drugGroup ?? void 0,
        unitOfMeasure: product.unitOfMeasure ?? void 0,
        purchasePack: product.purchasePack ?? void 0,
        stripQuantity: product.stripQuantity ?? void 0,
        gstRate: Number(product.gstRate),
        batches: product.batches.map((b) => ({
          id: b.id,
          batchNumber: b.batchNumber,
          expiryDate: b.expiryDate.toISOString(),
          quantity: b.quantity,
          mrp: Number(b.mrp),
          ptr: Number(b.ptr),
          pts: Number(b.pts)
        }))
      },
      batch: product.batches.length > 0 ? {
        id: product.batches[0].id,
        batchNumber: product.batches[0].batchNumber,
        productId: product.id,
        productName: product.name,
        expiryDate: product.batches[0].expiryDate.toISOString(),
        quantity: product.batches[0].quantity,
        mrp: Number(product.batches[0].mrp),
        ptr: Number(product.batches[0].ptr),
        pts: Number(product.batches[0].pts)
      } : void 0
    };
  }
  product = await prisma2.product.findFirst({
    where: { stripCode: searchCode },
    include: {
      batches: {
        where: { quantity: { gt: 0 } },
        orderBy: { expiryDate: "asc" },
        take: 1
      }
    }
  });
  if (product) {
    return {
      found: true,
      searchType: "stripCode",
      product: {
        id: product.id,
        name: product.name,
        sku: product.sku,
        manufacturer: product.manufacturer ?? void 0,
        drugCategory: product.drugCategory ?? void 0,
        drugGroup: product.drugGroup ?? void 0,
        unitOfMeasure: product.unitOfMeasure ?? void 0,
        purchasePack: product.purchasePack ?? void 0,
        stripQuantity: product.stripQuantity ?? void 0,
        gstRate: Number(product.gstRate),
        batches: product.batches.map((b) => ({
          id: b.id,
          batchNumber: b.batchNumber,
          expiryDate: b.expiryDate.toISOString(),
          quantity: b.quantity,
          mrp: Number(b.mrp),
          ptr: Number(b.ptr),
          pts: Number(b.pts)
        }))
      },
      batch: product.batches.length > 0 ? {
        id: product.batches[0].id,
        batchNumber: product.batches[0].batchNumber,
        productId: product.id,
        productName: product.name,
        expiryDate: product.batches[0].expiryDate.toISOString(),
        quantity: product.batches[0].quantity,
        mrp: Number(product.batches[0].mrp),
        ptr: Number(product.batches[0].ptr),
        pts: Number(product.batches[0].pts)
      } : void 0
    };
  }
  product = await prisma2.product.findFirst({
    where: { itemCode: searchCode },
    include: {
      batches: {
        where: { quantity: { gt: 0 } },
        orderBy: { expiryDate: "asc" },
        take: 1
      }
    }
  });
  if (product) {
    return {
      found: true,
      searchType: "itemCode",
      product: {
        id: product.id,
        name: product.name,
        sku: product.sku,
        manufacturer: product.manufacturer ?? void 0,
        drugCategory: product.drugCategory ?? void 0,
        drugGroup: product.drugGroup ?? void 0,
        unitOfMeasure: product.unitOfMeasure ?? void 0,
        purchasePack: product.purchasePack ?? void 0,
        stripQuantity: product.stripQuantity ?? void 0,
        gstRate: Number(product.gstRate),
        batches: product.batches.map((b) => ({
          id: b.id,
          batchNumber: b.batchNumber,
          expiryDate: b.expiryDate.toISOString(),
          quantity: b.quantity,
          mrp: Number(b.mrp),
          ptr: Number(b.ptr),
          pts: Number(b.pts)
        }))
      },
      batch: product.batches.length > 0 ? {
        id: product.batches[0].id,
        batchNumber: product.batches[0].batchNumber,
        productId: product.id,
        productName: product.name,
        expiryDate: product.batches[0].expiryDate.toISOString(),
        quantity: product.batches[0].quantity,
        mrp: Number(product.batches[0].mrp),
        ptr: Number(product.batches[0].ptr),
        pts: Number(product.batches[0].pts)
      } : void 0
    };
  }
  product = await prisma2.product.findFirst({
    where: { sku: searchCode },
    include: {
      batches: {
        where: { quantity: { gt: 0 } },
        orderBy: { expiryDate: "asc" },
        take: 1
      }
    }
  });
  if (product) {
    return {
      found: true,
      searchType: "sku",
      product: {
        id: product.id,
        name: product.name,
        sku: product.sku,
        manufacturer: product.manufacturer ?? void 0,
        drugCategory: product.drugCategory ?? void 0,
        drugGroup: product.drugGroup ?? void 0,
        unitOfMeasure: product.unitOfMeasure ?? void 0,
        purchasePack: product.purchasePack ?? void 0,
        stripQuantity: product.stripQuantity ?? void 0,
        gstRate: Number(product.gstRate),
        batches: product.batches.map((b) => ({
          id: b.id,
          batchNumber: b.batchNumber,
          expiryDate: b.expiryDate.toISOString(),
          quantity: b.quantity,
          mrp: Number(b.mrp),
          ptr: Number(b.ptr),
          pts: Number(b.pts)
        }))
      },
      batch: product.batches.length > 0 ? {
        id: product.batches[0].id,
        batchNumber: product.batches[0].batchNumber,
        productId: product.id,
        productName: product.name,
        expiryDate: product.batches[0].expiryDate.toISOString(),
        quantity: product.batches[0].quantity,
        mrp: Number(product.batches[0].mrp),
        ptr: Number(product.batches[0].ptr),
        pts: Number(product.batches[0].pts)
      } : void 0
    };
  }
  return { found: false, searchType: "notFound" };
};

// electron/src/services/expiryReturnService.ts
var import_client14 = require("@prisma/client");
init_prismaClient();
init_auditService();
var toNumber8 = (value) => {
  if (value instanceof import_client14.Prisma.Decimal) {
    return value.toNumber();
  }
  return Number(value ?? 0);
};
var mapExpiryReturn = (expiryReturn) => ({
  id: expiryReturn.id,
  returnNumber: expiryReturn.returnNumber,
  returnDate: expiryReturn.returnDate.toISOString(),
  supplierId: expiryReturn.supplierId ?? void 0,
  supplierName: expiryReturn.supplier?.name,
  batchId: expiryReturn.batchId,
  batchNumber: expiryReturn.batch.batchNumber,
  productId: expiryReturn.batch.product.id,
  productName: expiryReturn.batch.product.name,
  quantity: expiryReturn.quantity,
  lossAmount: toNumber8(expiryReturn.lossAmount),
  notes: expiryReturn.notes ?? void 0,
  createdAt: expiryReturn.createdAt.toISOString(),
  updatedAt: expiryReturn.updatedAt.toISOString()
});
var createExpiryReturn = async (payload) => {
  if (!payload.returnNumber || !payload.batchId || !payload.quantity) {
    throw new Error("Return number, batch ID, and quantity are required");
  }
  if (payload.quantity <= 0) {
    throw new Error("Quantity must be greater than 0");
  }
  if (payload.lossAmount < 0) {
    throw new Error("Loss amount cannot be negative");
  }
  const prisma2 = getPrismaClient();
  return prisma2.$transaction(
    async (tx) => {
      const batch = await tx.batch.findUnique({
        where: { id: payload.batchId },
        include: {
          product: true
        }
      });
      if (!batch) {
        throw new Error("Batch not found");
      }
      if (batch.quantity < payload.quantity) {
        throw new Error("Insufficient batch quantity for return");
      }
      const existing = await tx.expiryReturn.findUnique({
        where: { returnNumber: payload.returnNumber }
      });
      if (existing) {
        throw new Error("Return number already exists");
      }
      const { createLedgerEntry: createLedgerEntry2 } = await Promise.resolve().then(() => (init_stockLedgerService(), stockLedgerService_exports));
      await createLedgerEntry2({
        productId: batch.productId,
        batchId: batch.id,
        godownId: batch.godownId,
        movementType: "EXPIRY_RETURN",
        reference: payload.returnNumber,
        quantityChange: -payload.quantity,
        narration: `Expiry return - ${payload.notes ?? "Expired stock"}`,
        tx
      });
      const expiryReturn = await tx.expiryReturn.create({
        data: {
          returnNumber: payload.returnNumber,
          returnDate: new Date(payload.returnDate),
          supplierId: payload.supplierId,
          batchId: payload.batchId,
          quantity: payload.quantity,
          lossAmount: new import_client14.Prisma.Decimal(payload.lossAmount),
          notes: payload.notes
        },
        include: {
          supplier: true,
          batch: {
            include: {
              product: true
            }
          }
        }
      });
      await logAudit({
        entity: "ExpiryReturn",
        entityId: expiryReturn.id,
        action: "CREATE",
        details: {
          returnNumber: expiryReturn.returnNumber,
          batchId: batch.id,
          quantity: payload.quantity,
          lossAmount: payload.lossAmount
        }
      });
      return mapExpiryReturn(expiryReturn);
    },
    { timeout: 1e4 }
  );
};
var listExpiryReturns = async (filters) => {
  const prisma2 = getPrismaClient();
  const returns = await prisma2.expiryReturn.findMany({
    where: {
      ...filters?.fromDate || filters?.toDate ? {
        returnDate: {
          ...filters.fromDate && { gte: new Date(filters.fromDate) },
          ...filters.toDate && { lte: new Date(filters.toDate) }
        }
      } : void 0,
      ...filters?.supplierId && { supplierId: filters.supplierId },
      ...filters?.batchId && { batchId: filters.batchId }
    },
    include: {
      supplier: true,
      batch: {
        include: {
          product: true
        }
      }
    },
    orderBy: { returnDate: "desc" }
  });
  return returns.map(mapExpiryReturn);
};
var getExpiryReturnById = async (id) => {
  const prisma2 = getPrismaClient();
  const expiryReturn = await prisma2.expiryReturn.findUnique({
    where: { id },
    include: {
      supplier: true,
      batch: {
        include: {
          product: true
        }
      }
    }
  });
  if (!expiryReturn) {
    throw new Error("Expiry return not found");
  }
  return mapExpiryReturn(expiryReturn);
};
var getExpiryLossReport = async (filters) => {
  const prisma2 = getPrismaClient();
  const returns = await prisma2.expiryReturn.findMany({
    where: {
      ...filters?.fromDate || filters?.toDate ? {
        returnDate: {
          ...filters.fromDate && { gte: new Date(filters.fromDate) },
          ...filters.toDate && { lte: new Date(filters.toDate) }
        }
      } : void 0,
      ...filters?.supplierId && { supplierId: filters.supplierId }
    },
    include: {
      supplier: true,
      batch: {
        include: {
          product: true
        }
      }
    }
  });
  let totalQuantity = 0;
  let totalLossAmount = 0;
  const supplierMap = /* @__PURE__ */ new Map();
  const productMap = /* @__PURE__ */ new Map();
  returns.forEach((ret) => {
    totalQuantity += ret.quantity;
    totalLossAmount += toNumber8(ret.lossAmount);
    if (ret.supplierId) {
      const supplierName = ret.supplier?.name ?? "Unknown";
      const existing2 = supplierMap.get(ret.supplierId);
      if (existing2) {
        existing2.count++;
        existing2.quantity += ret.quantity;
        existing2.lossAmount += toNumber8(ret.lossAmount);
      } else {
        supplierMap.set(ret.supplierId, {
          name: supplierName,
          count: 1,
          quantity: ret.quantity,
          lossAmount: toNumber8(ret.lossAmount)
        });
      }
    }
    const productId = ret.batch.product.id;
    const productName = ret.batch.product.name;
    const existing = productMap.get(productId);
    if (existing) {
      existing.count++;
      existing.quantity += ret.quantity;
      existing.lossAmount += toNumber8(ret.lossAmount);
    } else {
      productMap.set(productId, {
        name: productName,
        count: 1,
        quantity: ret.quantity,
        lossAmount: toNumber8(ret.lossAmount)
      });
    }
  });
  return {
    totalReturns: returns.length,
    totalQuantity,
    totalLossAmount,
    bySupplier: Array.from(supplierMap.entries()).map(([id, data]) => ({
      supplierId: id,
      supplierName: data.name,
      returnCount: data.count,
      totalQuantity: data.quantity,
      totalLossAmount: data.lossAmount
    })),
    byProduct: Array.from(productMap.entries()).map(([id, data]) => ({
      productId: id,
      productName: data.name,
      returnCount: data.count,
      totalQuantity: data.quantity,
      totalLossAmount: data.lossAmount
    }))
  };
};

// electron/src/services/notificationService.ts
init_prismaClient();
var mapNotification = (notification) => ({
  id: notification.id,
  type: notification.type,
  title: notification.title,
  message: notification.message,
  isRead: notification.isRead,
  userId: notification.userId ?? void 0,
  entity: notification.entity ?? void 0,
  entityId: notification.entityId ?? void 0,
  createdAt: notification.createdAt.toISOString()
});
var createNotification = async (payload) => {
  if (!payload.title || !payload.message) {
    throw new Error("Title and message are required");
  }
  const prisma2 = getPrismaClient();
  const notification = await prisma2.notification.create({
    data: {
      type: payload.type,
      title: payload.title,
      message: payload.message,
      userId: payload.userId,
      entity: payload.entity,
      entityId: payload.entityId
    }
  });
  return mapNotification(notification);
};
var listNotifications = async (filters) => {
  const prisma2 = getPrismaClient();
  const notifications = await prisma2.notification.findMany({
    where: {
      ...filters?.userId !== void 0 && { userId: filters.userId },
      ...filters?.type && { type: filters.type },
      ...filters?.isRead !== void 0 && { isRead: filters.isRead }
    },
    orderBy: { createdAt: "desc" },
    take: filters?.limit ?? 50
  });
  return notifications.map(mapNotification);
};
var markAsRead = async (id) => {
  const prisma2 = getPrismaClient();
  const notification = await prisma2.notification.update({
    where: { id },
    data: { isRead: true }
  });
  return mapNotification(notification);
};
var markAllAsRead = async (userId) => {
  const prisma2 = getPrismaClient();
  const result = await prisma2.notification.updateMany({
    where: {
      ...userId !== void 0 && { userId },
      isRead: false
    },
    data: { isRead: true }
  });
  return result.count;
};
var getUnreadCount = async (userId) => {
  const prisma2 = getPrismaClient();
  return prisma2.notification.count({
    where: {
      ...userId !== void 0 && { userId },
      isRead: false
    }
  });
};
var notifyLowStock = async (productId, productName, currentStock, minStock) => {
  await createNotification({
    type: "LOW_STOCK",
    title: "Low Stock Alert",
    message: `${productName} is running low. Current stock: ${currentStock}, Minimum required: ${minStock}`,
    entity: "Product",
    entityId: productId
  });
};
var notifyExpiry = async (batchId, productName, batchNumber, daysUntilExpiry) => {
  await createNotification({
    type: "EXPIRY",
    title: "Batch Expiring Soon",
    message: `Batch ${batchNumber} of ${productName} will expire in ${daysUntilExpiry} days`,
    entity: "Batch",
    entityId: batchId
  });
};

// electron/src/services/batchTransferService.ts
init_prismaClient();
init_auditService();
var transferBatch = async (payload) => {
  if (!payload.batchId || !payload.toGodownId || !payload.quantity) {
    throw new Error("Batch ID, target godown ID, and quantity are required");
  }
  if (payload.quantity <= 0) {
    throw new Error("Transfer quantity must be greater than 0");
  }
  if (payload.fromGodownId === payload.toGodownId) {
    throw new Error("Source and target godowns cannot be the same");
  }
  const prisma2 = getPrismaClient();
  return prisma2.$transaction(
    async (tx) => {
      const batch = await tx.batch.findUnique({
        where: { id: payload.batchId },
        include: {
          product: true,
          godown: true
        }
      });
      if (!batch) {
        throw new Error("Batch not found");
      }
      if (payload.fromGodownId && batch.godownId !== payload.fromGodownId) {
        throw new Error("Batch is not in the specified source godown");
      }
      if (batch.quantity < payload.quantity) {
        throw new Error("Insufficient batch quantity for transfer");
      }
      const toGodown = await tx.godown.findUnique({
        where: { id: payload.toGodownId }
      });
      if (!toGodown) {
        throw new Error("Target godown not found");
      }
      let targetBatch = await tx.batch.findUnique({
        where: {
          productId_batchNumber: {
            productId: batch.productId,
            batchNumber: batch.batchNumber
          }
        }
      });
      if (targetBatch && targetBatch.godownId === payload.toGodownId && targetBatch.id !== batch.id) {
        const { createLedgerEntry: createLedgerEntry2 } = await Promise.resolve().then(() => (init_stockLedgerService(), stockLedgerService_exports));
        const sourceResult = await createLedgerEntry2({
          productId: batch.productId,
          batchId: batch.id,
          godownId: payload.fromGodownId ?? batch.godownId,
          movementType: "TRANSFER_OUT",
          reference: `Transfer to ${toGodown.name}`,
          quantityChange: -payload.quantity,
          narration: payload.notes ?? `Transferred to ${toGodown.name}`,
          tx
        });
        await createLedgerEntry2({
          productId: batch.productId,
          batchId: targetBatch.id,
          godownId: payload.toGodownId,
          movementType: "TRANSFER_IN",
          reference: `Transfer from ${batch.godown?.name ?? "Unknown"}`,
          quantityChange: payload.quantity,
          narration: payload.notes ?? `Transferred from ${batch.godown?.name ?? "Unknown"}`,
          tx
        });
        if (sourceResult.newBatchQuantity === 0) {
          await tx.batch.update({
            where: { id: batch.id },
            data: { godownId: null }
          });
        }
        await logAudit({
          entity: "Batch",
          entityId: batch.id,
          action: "TRANSFER",
          details: {
            fromGodown: batch.godown?.name,
            toGodown: toGodown.name,
            quantity: payload.quantity
          }
        });
        return {
          id: batch.id,
          batchId: batch.id,
          batchNumber: batch.batchNumber,
          productName: batch.product.name,
          fromGodownId: batch.godownId ?? void 0,
          fromGodownName: batch.godown?.name ?? void 0,
          toGodownId: payload.toGodownId,
          toGodownName: toGodown.name,
          quantity: payload.quantity,
          notes: payload.notes,
          createdAt: (/* @__PURE__ */ new Date()).toISOString()
        };
      } else {
        if (batch.quantity === payload.quantity) {
          const updatedBatch = await tx.batch.update({
            where: { id: batch.id },
            data: { godownId: payload.toGodownId }
          });
          await tx.stockLedger.create({
            data: {
              productId: batch.productId,
              batchId: batch.id,
              godownId: payload.fromGodownId ?? batch.godownId,
              movementType: "TRANSFER_OUT",
              reference: `Transfer to ${toGodown.name}`,
              quantityChange: -payload.quantity,
              balanceAfter: 0,
              narration: payload.notes ?? `Transferred to ${toGodown.name}`
            }
          });
          await tx.stockLedger.create({
            data: {
              productId: batch.productId,
              batchId: batch.id,
              godownId: payload.toGodownId,
              movementType: "TRANSFER_IN",
              reference: `Transfer from ${batch.godown?.name ?? "Unknown"}`,
              quantityChange: payload.quantity,
              balanceAfter: payload.quantity,
              narration: payload.notes ?? `Transferred from ${batch.godown?.name ?? "Unknown"}`
            }
          });
          await logAudit({
            entity: "Batch",
            entityId: batch.id,
            action: "TRANSFER",
            details: {
              fromGodown: batch.godown?.name,
              toGodown: toGodown.name,
              quantity: payload.quantity
            }
          });
          return {
            id: batch.id,
            batchId: batch.id,
            batchNumber: batch.batchNumber,
            productName: batch.product.name,
            fromGodownId: payload.fromGodownId ?? void 0,
            fromGodownName: batch.godown?.name ?? void 0,
            toGodownId: payload.toGodownId,
            toGodownName: toGodown.name,
            quantity: payload.quantity,
            notes: payload.notes,
            createdAt: (/* @__PURE__ */ new Date()).toISOString()
          };
        } else {
          const newBatch = await tx.batch.create({
            data: {
              productId: batch.productId,
              batchNumber: batch.batchNumber,
              expiryDate: batch.expiryDate,
              mrp: batch.mrp,
              ptr: batch.ptr,
              pts: batch.pts,
              taxPercent: batch.taxPercent,
              quantity: payload.quantity,
              godownId: payload.toGodownId
            }
          });
          await tx.batch.update({
            where: { id: batch.id },
            data: { quantity: { decrement: payload.quantity } }
          });
          await tx.stockLedger.create({
            data: {
              productId: batch.productId,
              batchId: batch.id,
              godownId: payload.fromGodownId ?? batch.godownId,
              movementType: "TRANSFER_OUT",
              reference: `Transfer to ${toGodown.name}`,
              quantityChange: -payload.quantity,
              balanceAfter: batch.quantity - payload.quantity,
              narration: payload.notes ?? `Transferred to ${toGodown.name}`
            }
          });
          await tx.stockLedger.create({
            data: {
              productId: batch.productId,
              batchId: newBatch.id,
              godownId: payload.toGodownId,
              movementType: "TRANSFER_IN",
              reference: `Transfer from ${batch.godown?.name ?? "Unknown"}`,
              quantityChange: payload.quantity,
              balanceAfter: payload.quantity,
              narration: payload.notes ?? `Transferred from ${batch.godown?.name ?? "Unknown"}`
            }
          });
          await logAudit({
            entity: "Batch",
            entityId: newBatch.id,
            action: "TRANSFER",
            details: {
              fromGodown: batch.godown?.name,
              toGodown: toGodown.name,
              quantity: payload.quantity,
              sourceBatchId: batch.id
            }
          });
          return {
            id: newBatch.id,
            batchId: newBatch.id,
            batchNumber: newBatch.batchNumber,
            productName: batch.product.name,
            fromGodownId: payload.fromGodownId ?? void 0,
            fromGodownName: batch.godown?.name ?? void 0,
            toGodownId: payload.toGodownId,
            toGodownName: toGodown.name,
            quantity: payload.quantity,
            notes: payload.notes,
            createdAt: newBatch.createdAt.toISOString()
          };
        }
      }
    }
  );
};

// electron/src/ipcHandlers/index.ts
init_reportService();

// electron/src/services/pdfService.ts
var import_electron4 = require("electron");
var fs4 = __toESM(require("fs"));
var path5 = __toESM(require("path"));
init_prismaClient();
var generateInvoicePDF = async (options) => {
  const prisma2 = getPrismaClient();
  let invoice;
  let items = [];
  let customerOrSupplier = null;
  if (options.invoiceType === "sales") {
    invoice = await prisma2.salesInvoice.findUnique({
      where: { id: options.invoiceId },
      include: {
        customer: true,
        items: {
          include: {
            product: true,
            batch: true
          }
        }
      }
    });
    if (invoice) {
      customerOrSupplier = invoice.customer;
      items = invoice.items;
    }
  } else if (options.invoiceType === "purchase") {
    invoice = await prisma2.purchaseInvoice.findUnique({
      where: { id: options.invoiceId },
      include: {
        supplier: true,
        items: {
          include: {
            product: true,
            batch: true
          }
        }
      }
    });
    if (invoice) {
      customerOrSupplier = invoice.supplier;
      items = invoice.items;
    }
  } else if (options.invoiceType === "creditnote") {
    invoice = await prisma2.creditNote.findUnique({
      where: { id: options.invoiceId },
      include: {
        salesInvoice: {
          include: {
            customer: true,
            items: {
              include: {
                product: true,
                batch: true
              }
            }
          }
        }
      }
    });
    if (invoice) {
      customerOrSupplier = invoice.salesInvoice.customer;
      items = invoice.salesInvoice.items;
    }
  }
  if (!invoice) {
    throw new Error("Invoice not found");
  }
  const html = generateInvoiceHTML(invoice, items, customerOrSupplier, options.invoiceType);
  const outputDir = options.outputPath || path5.join(import_electron4.app.getPath("documents"), "invoices");
  if (!fs4.existsSync(outputDir)) {
    fs4.mkdirSync(outputDir, { recursive: true });
  }
  const fileName = `${options.invoiceType}_${invoice.invoiceNumber || invoice.creditNoteNumber || invoice.id}_${Date.now()}.html`;
  const filePath = path5.join(outputDir, fileName);
  fs4.writeFileSync(filePath, html, "utf-8");
  return filePath;
};
function generateInvoiceHTML(invoice, items, customerOrSupplier, type) {
  const invoiceNumber = invoice.invoiceNumber || invoice.creditNoteNumber;
  const invoiceDate = new Date(invoice.invoiceDate || invoice.creditDate).toLocaleDateString();
  const totalAmount = Number(invoice.totalAmount);
  const totalTax = Number(invoice.totalTax || 0);
  const roundOff = Number(invoice.roundOff || 0);
  const paidAmount = Number(invoice.paidAmount || 0);
  const balance = totalAmount - paidAmount;
  return `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>${type.toUpperCase()} Invoice - ${invoiceNumber}</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    .header { text-align: center; margin-bottom: 30px; }
    .company-info { margin-bottom: 20px; }
    .invoice-details { display: flex; justify-content: space-between; margin-bottom: 20px; }
    .customer-info, .invoice-meta { width: 48%; }
    table { width: 100%; border-collapse: collapse; margin: 20px 0; }
    th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
    th { background-color: #f2f2f2; }
    .totals { text-align: right; margin-top: 20px; }
    .total-row { margin: 5px 0; }
    .footer { margin-top: 40px; text-align: center; font-size: 12px; color: #666; }
  </style>
</head>
<body>
  <div class="header">
    <h1>${type === "creditnote" ? "CREDIT NOTE" : type.toUpperCase() + " INVOICE"}</h1>
  </div>
  
  <div class="invoice-details">
    <div class="customer-info">
      <h3>${type === "purchase" ? "Supplier" : "Customer"} Details:</h3>
      <p><strong>${customerOrSupplier?.name || "N/A"}</strong></p>
      ${customerOrSupplier?.addressLine1 ? `<p>${customerOrSupplier.addressLine1}</p>` : ""}
      ${customerOrSupplier?.addressLine2 ? `<p>${customerOrSupplier.addressLine2}</p>` : ""}
      ${customerOrSupplier?.city ? `<p>${customerOrSupplier.city}, ${customerOrSupplier.state || ""} ${customerOrSupplier.postalCode || ""}</p>` : ""}
      ${customerOrSupplier?.gstin ? `<p>GSTIN: ${customerOrSupplier.gstin}</p>` : ""}
      ${customerOrSupplier?.phone ? `<p>Phone: ${customerOrSupplier.phone}</p>` : ""}
    </div>
    
    <div class="invoice-meta">
      <p><strong>Invoice Number:</strong> ${invoiceNumber}</p>
      <p><strong>Date:</strong> ${invoiceDate}</p>
      ${invoice.dueDate ? `<p><strong>Due Date:</strong> ${new Date(invoice.dueDate).toLocaleDateString()}</p>` : ""}
      ${invoice.paymentStatus ? `<p><strong>Payment Status:</strong> ${invoice.paymentStatus}</p>` : ""}
    </div>
  </div>

  <table>
    <thead>
      <tr>
        <th>#</th>
        <th>Product</th>
        <th>Batch</th>
        <th>Qty</th>
        <th>Rate</th>
        <th>Tax %</th>
        <th>Discount %</th>
        <th>Amount</th>
      </tr>
    </thead>
    <tbody>
      ${items.map((item, index) => `
        <tr>
          <td>${index + 1}</td>
          <td>${item.product.name} (${item.product.sku})</td>
          <td>${item.batch?.batchNumber || "N/A"}</td>
          <td>${item.quantity}</td>
          <td>${Number(item.salePrice || item.costPrice).toFixed(2)}</td>
          <td>${Number(item.taxPercent).toFixed(2)}</td>
          <td>${Number(item.discountPercent || 0).toFixed(2)}</td>
          <td>${Number(item.lineTotal).toFixed(2)}</td>
        </tr>
      `).join("")}
    </tbody>
  </table>

  <div class="totals">
    <div class="total-row"><strong>Subtotal:</strong> \u20B9${(totalAmount - totalTax).toFixed(2)}</div>
    <div class="total-row"><strong>Tax:</strong> \u20B9${totalTax.toFixed(2)}</div>
    ${roundOff !== 0 ? `<div class="total-row"><strong>Round Off:</strong> \u20B9${roundOff.toFixed(2)}</div>` : ""}
    <div class="total-row"><strong>Total Amount:</strong> \u20B9${totalAmount.toFixed(2)}</div>
    ${paidAmount > 0 ? `<div class="total-row"><strong>Paid:</strong> \u20B9${paidAmount.toFixed(2)}</div>` : ""}
    ${balance > 0 ? `<div class="total-row"><strong>Balance:</strong> \u20B9${balance.toFixed(2)}</div>` : ""}
  </div>

  ${invoice.notes ? `<div style="margin-top: 20px;"><strong>Notes:</strong> ${invoice.notes}</div>` : ""}

  <div class="footer">
    <p>This is a computer-generated document. No signature required.</p>
    <p>Generated on ${(/* @__PURE__ */ new Date()).toLocaleString()}</p>
  </div>
</body>
</html>
  `;
}

// electron/src/services/importService.ts
var import_client15 = require("@prisma/client");
init_prismaClient();
init_auditService();
var importProducts = async (rows) => {
  const prisma2 = getPrismaClient();
  const result = {
    success: 0,
    failed: 0,
    errors: []
  };
  for (let i = 0; i < rows.length; i++) {
    const row = rows[i];
    const rowNum = i + 2;
    try {
      if (!row.sku || !row.name || !row.hsnCode) {
        throw new Error("SKU, name, and HSN code are required");
      }
      const existing = await prisma2.product.findUnique({
        where: { sku: row.sku }
      });
      if (existing) {
        await prisma2.product.update({
          where: { id: existing.id },
          data: {
            name: row.name,
            hsnCode: row.hsnCode,
            manufacturer: row.manufacturer,
            packSize: row.packSize,
            gstRate: new import_client15.Prisma.Decimal(row.gstRate ?? 0),
            minStock: row.minStock ?? 0,
            maxStock: row.maxStock,
            isBatchManaged: row.isBatchManaged ?? true
          }
        });
      } else {
        await prisma2.product.create({
          data: {
            sku: row.sku,
            name: row.name,
            hsnCode: row.hsnCode,
            manufacturer: row.manufacturer,
            packSize: row.packSize,
            gstRate: new import_client15.Prisma.Decimal(row.gstRate ?? 0),
            minStock: row.minStock ?? 0,
            maxStock: row.maxStock,
            isBatchManaged: row.isBatchManaged ?? true
          }
        });
      }
      result.success++;
    } catch (error) {
      result.failed++;
      result.errors.push({
        row: rowNum,
        error: error.message || "Unknown error"
      });
    }
  }
  await logAudit({
    entity: "Product",
    action: "BULK_IMPORT",
    details: {
      total: rows.length,
      success: result.success,
      failed: result.failed
    }
  });
  return result;
};
var importCustomers = async (rows) => {
  const prisma2 = getPrismaClient();
  const result = {
    success: 0,
    failed: 0,
    errors: []
  };
  for (let i = 0; i < rows.length; i++) {
    const row = rows[i];
    const rowNum = i + 2;
    try {
      if (!row.name) {
        throw new Error("Name is required");
      }
      const existing = await prisma2.customer.findFirst({
        where: { name: row.name }
      });
      if (existing) {
        await prisma2.customer.update({
          where: { id: existing.id },
          data: {
            gstin: row.gstin,
            drugLicenseNumber: row.drugLicenseNumber,
            addressLine1: row.addressLine1,
            addressLine2: row.addressLine2,
            city: row.city,
            state: row.state,
            postalCode: row.postalCode,
            phone: row.phone,
            email: row.email,
            creditLimit: new import_client15.Prisma.Decimal(row.creditLimit ?? 0)
          }
        });
      } else {
        await prisma2.customer.create({
          data: {
            name: row.name,
            gstin: row.gstin,
            drugLicenseNumber: row.drugLicenseNumber,
            addressLine1: row.addressLine1,
            addressLine2: row.addressLine2,
            city: row.city,
            state: row.state,
            postalCode: row.postalCode,
            phone: row.phone,
            email: row.email,
            creditLimit: new import_client15.Prisma.Decimal(row.creditLimit ?? 0)
          }
        });
      }
      result.success++;
    } catch (error) {
      result.failed++;
      result.errors.push({
        row: rowNum,
        error: error.message || "Unknown error"
      });
    }
  }
  await logAudit({
    entity: "Customer",
    action: "BULK_IMPORT",
    details: {
      total: rows.length,
      success: result.success,
      failed: result.failed
    }
  });
  return result;
};
var importSuppliers = async (rows) => {
  const prisma2 = getPrismaClient();
  const result = {
    success: 0,
    failed: 0,
    errors: []
  };
  for (let i = 0; i < rows.length; i++) {
    const row = rows[i];
    const rowNum = i + 2;
    try {
      if (!row.name) {
        throw new Error("Name is required");
      }
      const existing = await prisma2.supplier.findFirst({
        where: { name: row.name }
      });
      if (existing) {
        await prisma2.supplier.update({
          where: { id: existing.id },
          data: {
            gstin: row.gstin,
            drugLicenseNumber: row.drugLicenseNumber,
            addressLine1: row.addressLine1,
            addressLine2: row.addressLine2,
            city: row.city,
            state: row.state,
            postalCode: row.postalCode,
            phone: row.phone,
            email: row.email,
            openingBalance: new import_client15.Prisma.Decimal(row.openingBalance ?? 0)
          }
        });
      } else {
        await prisma2.supplier.create({
          data: {
            name: row.name,
            gstin: row.gstin,
            drugLicenseNumber: row.drugLicenseNumber,
            addressLine1: row.addressLine1,
            addressLine2: row.addressLine2,
            city: row.city,
            state: row.state,
            postalCode: row.postalCode,
            phone: row.phone,
            email: row.email,
            openingBalance: new import_client15.Prisma.Decimal(row.openingBalance ?? 0)
          }
        });
      }
      result.success++;
    } catch (error) {
      result.failed++;
      result.errors.push({
        row: rowNum,
        error: error.message || "Unknown error"
      });
    }
  }
  await logAudit({
    entity: "Supplier",
    action: "BULK_IMPORT",
    details: {
      total: rows.length,
      success: result.success,
      failed: result.failed
    }
  });
  return result;
};

// electron/src/services/backgroundJobService.ts
init_prismaClient();
init_backupService();
var checkLowStock = async () => {
  const prisma2 = getPrismaClient();
  let itemsProcessed = 0;
  try {
    const products = await prisma2.product.findMany({
      include: {
        batches: {
          where: { quantity: { gt: 0 } }
        }
      }
    });
    for (const product of products) {
      const totalQuantity = product.batches.reduce((sum, b) => sum + b.quantity, 0);
      if (totalQuantity < product.minStock) {
        const activeUsers = await prisma2.user.findMany({
          where: { isActive: true },
          select: { id: true }
        });
        for (const user of activeUsers) {
          await notifyLowStock(
            product.id,
            product.name,
            totalQuantity,
            product.minStock
          );
        }
        itemsProcessed++;
      }
    }
    return {
      success: true,
      message: `Checked ${products.length} products, found ${itemsProcessed} with low stock`,
      itemsProcessed
    };
  } catch (error) {
    return {
      success: false,
      message: error.message || "Error checking low stock",
      itemsProcessed
    };
  }
};
var checkExpiringBatches = async (daysAhead = 30) => {
  const prisma2 = getPrismaClient();
  let itemsProcessed = 0;
  try {
    const now = /* @__PURE__ */ new Date();
    const targetDate = new Date(now);
    targetDate.setDate(targetDate.getDate() + daysAhead);
    const batches = await prisma2.batch.findMany({
      where: {
        quantity: { gt: 0 },
        expiryDate: {
          gte: now,
          lte: targetDate
        }
      },
      include: {
        product: true
      }
    });
    const activeUsers = await prisma2.user.findMany({
      where: { isActive: true },
      select: { id: true }
    });
    for (const batch of batches) {
      const expiryDate = new Date(batch.expiryDate);
      const daysUntilExpiry = Math.ceil((expiryDate.getTime() - now.getTime()) / (1e3 * 60 * 60 * 24));
      if (daysUntilExpiry >= 0 && daysUntilExpiry <= daysAhead) {
        for (const user of activeUsers) {
          await notifyExpiry(
            batch.id,
            batch.product.name,
            batch.batchNumber,
            daysUntilExpiry
          );
        }
        itemsProcessed++;
      }
    }
    return {
      success: true,
      message: `Checked batches, found ${itemsProcessed} expiring within ${daysAhead} days`,
      itemsProcessed
    };
  } catch (error) {
    return {
      success: false,
      message: error.message || "Error checking expiring batches",
      itemsProcessed
    };
  }
};
var runAllChecks = async () => {
  const [lowStock, expiringBatches] = await Promise.all([
    checkLowStock(),
    checkExpiringBatches(30)
  ]);
  return {
    lowStock,
    expiringBatches
  };
};
var cleanupOldNotifications = async () => {
  const prisma2 = getPrismaClient();
  try {
    const thirtyDaysAgo = /* @__PURE__ */ new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
    const result = await prisma2.notification.deleteMany({
      where: {
        isRead: true,
        createdAt: {
          lt: thirtyDaysAgo
        }
      }
    });
    return {
      success: true,
      message: `Cleaned up ${result.count} old notifications`,
      itemsProcessed: result.count
    };
  } catch (error) {
    return {
      success: false,
      message: error.message || "Error cleaning up notifications",
      itemsProcessed: 0
    };
  }
};

// electron/src/ipcHandlers/index.ts
init_billService();
init_billTemplateService();

// electron/src/services/templateRenderer.ts
init_prismaClient();
init_companyInfoService();
var numberToWordsHelper = (num) => {
  const ones = [
    "",
    "ONE",
    "TWO",
    "THREE",
    "FOUR",
    "FIVE",
    "SIX",
    "SEVEN",
    "EIGHT",
    "NINE",
    "TEN",
    "ELEVEN",
    "TWELVE",
    "THIRTEEN",
    "FOURTEEN",
    "FIFTEEN",
    "SIXTEEN",
    "SEVENTEEN",
    "EIGHTEEN",
    "NINETEEN"
  ];
  const tens = [
    "",
    "",
    "TWENTY",
    "THIRTY",
    "FORTY",
    "FIFTY",
    "SIXTY",
    "SEVENTY",
    "EIGHTY",
    "NINETY"
  ];
  const convertHundreds = (n) => {
    let result2 = "";
    if (n >= 100) {
      result2 += ones[Math.floor(n / 100)] + " HUNDRED";
      n %= 100;
      if (n > 0) result2 += " ";
    }
    if (n >= 20) {
      result2 += tens[Math.floor(n / 10)];
      if (n % 10 > 0) result2 += " " + ones[n % 10];
    } else if (n > 0) {
      result2 += ones[n];
    }
    return result2;
  };
  if (num === 0) return "ZERO ONLY";
  let wholePart = Math.floor(num);
  const decimalPart = Math.round((num - wholePart) * 100);
  let result = "";
  if (wholePart >= 1e7) {
    const crores = Math.floor(wholePart / 1e7);
    result += convertHundreds(crores) + " CRORE";
    wholePart %= 1e7;
    if (wholePart > 0) result += " ";
  }
  if (wholePart >= 1e5) {
    const lakhs = Math.floor(wholePart / 1e5);
    result += convertHundreds(lakhs) + " LAKH";
    wholePart %= 1e5;
    if (wholePart > 0) result += " ";
  }
  if (wholePart >= 1e3) {
    const thousands = Math.floor(wholePart / 1e3);
    result += convertHundreds(thousands) + " THOUSAND";
    wholePart %= 1e3;
    if (wholePart > 0) result += " ";
  }
  if (wholePart > 0) {
    result += convertHundreds(wholePart);
  }
  if (decimalPart > 0) {
    result += " AND " + convertHundreds(decimalPart) + " PAISE";
  }
  return result.trim().toUpperCase() + " ONLY";
};
var renderBillTemplate = async (templateId, billId) => {
  const prisma2 = getPrismaClient();
  const [template, bill] = await Promise.all([
    prisma2.billTemplate.findUnique({
      where: { id: templateId }
    }),
    prisma2.bill.findUnique({
      where: { id: billId },
      include: {
        customer: true,
        supplier: true,
        mr: true,
        doctor: true,
        lines: {
          orderBy: { lineNumber: "asc" }
        }
      }
    })
  ]);
  if (!template) {
    throw new Error("Template not found");
  }
  const templateAny = template;
  const templateHtmlSource = templateAny.generatedHtml || template.htmlContent;
  if (!bill) {
    throw new Error("Bill not found");
  }
  const gstSummaryMap = /* @__PURE__ */ new Map();
  bill.lines.forEach((line) => {
    const rate = Number(line.taxPercent);
    const existing = gstSummaryMap.get(rate) || {
      rate,
      taxable: 0,
      cgst: 0,
      sgst: 0,
      total: 0
    };
    existing.taxable += Number(line.taxableAmount);
    existing.cgst += Number(line.cgstAmount);
    existing.sgst += Number(line.sgstAmount);
    existing.total += Number(line.cgstAmount) + Number(line.sgstAmount) + Number(line.igstAmount);
    gstSummaryMap.set(rate, existing);
  });
  const gstSummary = Array.from(gstSummaryMap.values()).sort((a, b) => a.rate - b.rate);
  const totalSavingValue = bill.lines.reduce((sum, line) => {
    return sum + Number(line.savingValue ?? 0);
  }, 0);
  const totalSavingPercent = Number(bill.subtotal) > 0 ? totalSavingValue / (Number(bill.subtotal) + totalSavingValue) * 100 : 0;
  const billDTO = {
    id: bill.id,
    billNumber: bill.billNumber,
    billType: bill.billType,
    billDate: bill.billDate.toISOString(),
    dueDate: bill.dueDate?.toISOString() ?? void 0,
    status: bill.status,
    paymentStatus: bill.paymentStatus,
    billingType: bill.billingType ?? void 0,
    customerId: bill.customerId ?? void 0,
    supplierId: bill.supplierId ?? void 0,
    customerName: bill.customerName ?? bill.customer?.name ?? void 0,
    supplierName: bill.supplierName ?? bill.supplier?.name ?? void 0,
    customerGstin: bill.customerGstin ?? void 0,
    supplierGstin: bill.supplierGstin ?? void 0,
    customerAddress: bill.customerAddress ?? void 0,
    supplierAddress: bill.supplierAddress ?? void 0,
    customerPhone: bill.customerPhone ?? void 0,
    supplierPhone: bill.supplierPhone ?? void 0,
    mrId: bill.mrId ?? void 0,
    mrName: bill.mr?.name ?? void 0,
    doctorId: bill.doctorId ?? void 0,
    doctorName: bill.doctor?.name ?? void 0,
    challanNumber: bill.challanNumber ?? void 0,
    orderNumber: bill.orderNumber ?? void 0,
    remarks: bill.remarks ?? void 0,
    notes: bill.notes ?? void 0,
    subtotal: Number(bill.subtotal),
    totalDiscount: Number(bill.totalDiscount),
    totalTax: Number(bill.totalTax),
    cgstTotal: Number(bill.cgstTotal),
    sgstTotal: Number(bill.sgstTotal),
    igstTotal: Number(bill.igstTotal),
    roundOff: Number(bill.roundOff),
    totalAmount: Number(bill.totalAmount),
    paidAmount: Number(bill.paidAmount),
    templateId: bill.templateId ?? void 0,
    finalizedAt: bill.finalizedAt?.toISOString() ?? void 0,
    finalizedBy: bill.finalizedBy ?? void 0,
    cancelledAt: bill.cancelledAt?.toISOString() ?? void 0,
    cancelledBy: bill.cancelledBy ?? void 0,
    cancellationReason: bill.cancellationReason ?? void 0,
    lines: bill.lines.map((line) => ({
      id: line.id,
      lineNumber: line.lineNumber,
      productId: line.productId,
      batchId: line.batchId ?? void 0,
      productName: line.productName,
      hsnCode: line.hsnCode,
      manufacturer: line.manufacturer ?? void 0,
      packSize: line.packSize ?? void 0,
      unitOfMeasure: line.unitOfMeasure ?? void 0,
      batchNumber: line.batchNumber ?? void 0,
      expiryDate: line.expiryDate?.toISOString() ?? void 0,
      quantity: line.quantity,
      freeQuantity: line.freeQuantity,
      soldInStrips: line.soldInStrips,
      stripQuantity: line.stripQuantity ?? void 0,
      mrp: Number(line.mrp),
      ptr: Number(line.ptr),
      pts: line.pts ? Number(line.pts) : void 0,
      rate: Number(line.rate),
      discountPercent: Number(line.discountPercent),
      discountAmount: Number(line.discountAmount),
      taxPercent: Number(line.taxPercent),
      cgstPercent: Number(line.cgstPercent),
      sgstPercent: Number(line.sgstPercent),
      igstPercent: Number(line.igstPercent),
      cgstAmount: Number(line.cgstAmount),
      sgstAmount: Number(line.sgstAmount),
      igstAmount: Number(line.igstAmount),
      taxableAmount: Number(line.taxableAmount),
      lineTotal: Number(line.lineTotal),
      savingPercent: line.savingPercent ? Number(line.savingPercent) : void 0,
      savingValue: line.savingValue ? Number(line.savingValue) : void 0
    })),
    createdAt: bill.createdAt.toISOString(),
    updatedAt: bill.updatedAt.toISOString()
  };
  const companyInfo = await getCompanyInfo();
  const customerDlNo = bill.customer?.drugLicenseNumber ?? "";
  const customerDlNo2 = bill.customer?.drugLicenseNumber2 ?? "";
  const customerPanNumber = bill.customer?.panNumber ?? "";
  const customerState = bill.customer?.state ?? "";
  const customerStateCode = bill.customer?.stateCode ?? "";
  const customerAddress = bill.customerAddress ?? (bill.customer?.addressLine1 ? [bill.customer.addressLine1, bill.customer.addressLine2, bill.customer.city].filter(Boolean).join(", ") : "");
  const context = {
    company: {
      name: companyInfo?.companyName ?? "",
      bankName: companyInfo?.bankName ?? "",
      bankAccountNumber: companyInfo?.bankAccountNumber ?? "",
      bankIFSC: companyInfo?.bankIFSC ?? "",
      bankBranch: companyInfo?.bankBranch ?? "",
      address: companyInfo?.address ?? "",
      phone: companyInfo?.phone ?? "",
      email: companyInfo?.email ?? "",
      gstin: companyInfo?.gstNumber ?? "",
      dlNo: companyInfo?.dlNumber1 ?? "",
      dlNo2: companyInfo?.dlNumber2 ?? "",
      fssaiNumber: companyInfo?.fssaiNumber ?? "",
      cinPan: companyInfo?.cinPan ?? "",
      logoPath: companyInfo?.logoPath ?? "",
      signPath: companyInfo?.signPath ?? "",
      state: companyInfo?.state ?? "",
      stateCode: companyInfo?.stateCode ?? ""
    },
    bill: {
      ...billDTO,
      customerDlNo,
      customerDlNo2,
      customerPanNumber,
      customerState,
      customerStateCode,
      customerAddress,
      customerAddressLine1: bill.customer?.addressLine1 ?? "",
      customerAddressLine2: bill.customer?.addressLine2 ?? "",
      customerCity: bill.customer?.city ?? "",
      customerPostalCode: bill.customer?.postalCode ?? "",
      customerEmail: bill.customer?.email ?? "",
      isOriginal: true,
      // Default to ORIGINAL, can be made configurable
      gstSummary,
      totalSavingPercent,
      totalSavingValue
    }
  };
  const flatContext = {
    ...context.company,
    ...context.bill,
    // Map company fields to expected template names
    companyName: context.company?.name ?? "",
    logoPath: context.company?.logoPath ?? "",
    dlNo1: context.company?.dlNo ?? "",
    // Map bill fields to expected template names
    billNumber: context.bill.billNumber ?? "",
    billDate: context.bill.billDate ? new Date(context.bill.billDate).toLocaleDateString("en-IN") : "",
    dueDate: context.bill.dueDate ? new Date(context.bill.dueDate).toLocaleDateString("en-IN") : "",
    challanNumber: context.bill.challanNumber ?? "",
    orderNumber: context.bill.orderNumber ?? "",
    customerName: context.bill.customerName ?? "",
    customerAddress: context.bill.customerAddress ?? "",
    customerPhone: context.bill.customerPhone ?? "",
    customerGstin: context.bill.customerGstin ?? "",
    customerDlNo: context.bill.customerDlNo ?? "",
    customerDlNo2: context.bill.customerDlNo2 ?? "",
    customerPanNumber: context.bill.customerPanNumber ?? "",
    customerState: context.bill.customerState ?? "",
    customerStateCode: context.bill.customerStateCode ?? "",
    customerAddressLine1: context.bill.customerAddressLine1 ?? "",
    customerAddressLine2: context.bill.customerAddressLine2 ?? "",
    customerCity: context.bill.customerCity ?? "",
    customerPostalCode: context.bill.customerPostalCode ?? "",
    customerEmail: context.bill.customerEmail ?? "",
    isOriginal: context.bill.isOriginal ?? true,
    // Add other bill fields as needed
    subtotal: context.bill.subtotal ?? 0,
    totalDiscount: context.bill.totalDiscount ?? 0,
    totalTax: context.bill.totalTax ?? 0,
    taxableAmount: (context.bill.subtotal ?? 0) - (context.bill.totalDiscount ?? 0),
    cgstTotal: context.bill.cgstTotal ?? 0,
    sgstTotal: context.bill.sgstTotal ?? 0,
    igstTotal: context.bill.igstTotal ?? 0,
    roundOff: context.bill.roundOff ?? 0,
    totalAmount: context.bill.totalAmount ?? 0,
    totalSavingPercent: context.bill.totalSavingPercent ?? 0,
    totalSavingValue: context.bill.totalSavingValue ?? 0,
    remarks: context.bill.remarks ?? "",
    lines: context.bill.lines ?? [],
    gstSummary: context.bill.gstSummary ?? []
  };
  let html = templateHtmlSource;
  html = html.replace(/\{\{cssContent\}\}/g, template.cssContent);
  html = html.replace(/\{\{company\.(\w+)\}\}/g, (match, key) => {
    const value = context.company?.[key];
    return value !== null && value !== void 0 ? String(value) : "";
  });
  html = html.replace(/\{\{bill\.(\w+)\}\}/g, (match, key) => {
    const value = context.bill[key];
    if (value === null || value === void 0) {
      return "";
    }
    if (typeof value === "number") {
      return value.toFixed(2);
    }
    if (value instanceof Date) {
      return value.toISOString().split("T")[0];
    }
    return String(value);
  });
  html = html.replace(/\{\{#if\s+(\w+\.?\w*)\}\}([\s\S]*?)\{\{\/if\}\}/g, (match, condition, content) => {
    if (flatContext[condition] !== void 0) {
      const value2 = flatContext[condition];
      return value2 !== null && value2 !== void 0 && value2 !== false && value2 !== "" ? content : "";
    }
    const parts = condition.split(".");
    let value = context;
    for (const part of parts) {
      value = value?.[part];
    }
    return value !== null && value !== void 0 && value !== false && value !== "" ? content : "";
  });
  html = html.replace(/\{\{#each\s+(\w+\.?\w*)\}\}([\s\S]*?)\{\{\/each\}\}/g, (match, arrayPath, content) => {
    let value = flatContext[arrayPath];
    if (value === void 0) {
      const parts = arrayPath.split(".");
      value = context;
      for (const part of parts) {
        value = value?.[part];
      }
    }
    if (!Array.isArray(value)) {
      return "";
    }
    return value.map((item, index) => {
      let itemContent = content;
      const itemKeys = new Set(Object.keys(item || {}));
      itemContent = itemContent.replace(/\{\{formatCurrency\s+([^}]+)\}\}/g, (_match, expr) => {
        const trimmedExpr = expr.trim();
        const itemValue = item[trimmedExpr];
        return formatCurrency(itemValue);
      });
      itemContent = itemContent.replace(/\{\{numberToWords\s+([^}]+)\}\}/g, (_match, expr) => {
        const trimmedExpr = expr.trim();
        const itemValue = item[trimmedExpr];
        return numberToWords(itemValue);
      });
      itemContent = itemContent.replace(/\{\{(\w+)\}\}/g, (propMatch, propKey) => {
        if (propKey === "formatCurrency" || propKey === "numberToWords" || propKey === "@index" || !itemKeys.has(propKey)) {
          return propMatch;
        }
        const itemValue = item[propKey];
        if (itemValue === null || itemValue === void 0) {
          return "";
        }
        if (typeof itemValue === "number") {
          return itemValue.toFixed(2);
        }
        if (itemValue instanceof Date) {
          return itemValue.toISOString().split("T")[0];
        }
        return String(itemValue);
      });
      itemContent = itemContent.replace(/\{\{this\.(\w+)\}\}/g, (_m, key) => {
        const itemValue = item[key];
        if (itemValue === null || itemValue === void 0) {
          return "";
        }
        if (typeof itemValue === "number") {
          return itemValue.toFixed(2);
        }
        if (itemValue instanceof Date) {
          return itemValue.toISOString().split("T")[0];
        }
        return String(itemValue);
      });
      itemContent = itemContent.replace(/\{\{@index\}\}/g, String(index + 1));
      return itemContent;
    }).join("");
  });
  const getNestedValue2 = (obj, path16) => {
    const parts = path16.split(".");
    let value = obj;
    for (const part of parts) {
      value = value?.[part];
    }
    return value;
  };
  const formatCurrency = (value) => {
    if (value === null || value === void 0) return "0.00";
    const num = typeof value === "string" ? parseFloat(value) : value;
    if (isNaN(num)) return "0.00";
    return num.toFixed(2);
  };
  const numberToWords = (value) => {
    const num = typeof value === "string" ? parseFloat(value) : value;
    if (typeof num !== "number" || isNaN(num)) return "ZERO ONLY";
    return numberToWordsHelper(num);
  };
  html = html.replace(/\{\{formatCurrency\s+([^}]+)\}\}/g, (match, expr) => {
    const trimmedExpr = expr.trim();
    let value = flatContext[trimmedExpr];
    if (value === void 0) {
      value = getNestedValue2(context, trimmedExpr);
    }
    return formatCurrency(value);
  });
  html = html.replace(/\{\{numberToWords\s+([^}]+)\}\}/g, (match, expr) => {
    const trimmedExpr = expr.trim();
    let value = flatContext[trimmedExpr];
    if (value === void 0) {
      value = getNestedValue2(context, trimmedExpr);
    }
    return numberToWords(value);
  });
  html = html.replace(/\{\{(\w+\.?\w*)\}\}/g, (match, key) => {
    if (key.includes(".")) {
      const parts2 = key.split(".");
      let value2 = context;
      for (const part of parts2) {
        value2 = value2?.[part];
      }
      if (value2 === null || value2 === void 0) {
        return "";
      }
      if (typeof value2 === "number") {
        return value2.toFixed(2);
      }
      if (typeof value2 === "boolean") {
        return value2 ? "true" : "false";
      }
      return String(value2);
    }
    if (flatContext[key] !== void 0) {
      const value2 = flatContext[key];
      if (value2 === null || value2 === void 0) {
        return "";
      }
      if (typeof value2 === "number") {
        return value2.toFixed(2);
      }
      if (typeof value2 === "boolean") {
        return value2 ? "true" : "false";
      }
      return String(value2);
    }
    const parts = key.split(".");
    let value = context;
    for (const part of parts) {
      value = value?.[part];
    }
    if (value === null || value === void 0) {
      return "";
    }
    if (typeof value === "number") {
      return value.toFixed(2);
    }
    if (typeof value === "boolean") {
      return value ? "true" : "false";
    }
    return String(value);
  });
  return html;
};

// electron/src/printers/billPrintService.ts
var import_electron5 = require("electron");
var fs6 = __toESM(require("fs"));
var path7 = __toESM(require("path"));
init_billService();
init_billTemplateService();
var printBill = async (options) => {
  const { billId, templateId, outputPath, silent = false, printToPDF = true } = options;
  const bill = await getBillById(billId);
  if (!bill) {
    throw new Error("Bill not found");
  }
  const { canPrintBill: canPrintBill2 } = await Promise.resolve().then(() => (init_gstComplianceService(), gstComplianceService_exports));
  const printCheck = await canPrintBill2(billId);
  if (!printCheck.canPrint) {
    throw new Error(`Cannot print bill: ${printCheck.reason}`);
  }
  let finalTemplateId = templateId;
  if (!finalTemplateId && bill.templateId) {
    finalTemplateId = bill.templateId;
  }
  if (!finalTemplateId) {
    const defaultTemplate = await getDefaultBillTemplate("A4");
    if (!defaultTemplate) {
      const templates = await listBillTemplates({ templateType: "A4" });
      if (templates.length === 0) {
        throw new Error("No template found");
      }
      finalTemplateId = templates[0].id;
    } else {
      finalTemplateId = defaultTemplate.id;
    }
  }
  const html = await renderBillTemplate(finalTemplateId, billId);
  if (printToPDF) {
    const printWindow = new import_electron5.BrowserWindow({
      show: false,
      webPreferences: {
        nodeIntegration: false,
        contextIsolation: true
      }
    });
    try {
      await printWindow.loadURL(`data:text/html;charset=utf-8,${encodeURIComponent(html)}`);
      await new Promise((resolve) => setTimeout(resolve, 500));
      const pdfPath = outputPath || path7.join(
        import_electron5.app.getPath("documents"),
        "bills",
        `${bill.billNumber}-${Date.now()}.pdf`
      );
      const pdfDir = path7.dirname(pdfPath);
      if (!fs6.existsSync(pdfDir)) {
        fs6.mkdirSync(pdfDir, { recursive: true });
      }
      const pdfData = await printWindow.webContents.printToPDF({
        margins: {
          top: 0,
          bottom: 0,
          left: 0,
          right: 0
        },
        printBackground: true,
        landscape: false,
        pageSize: "A4"
      });
      fs6.writeFileSync(pdfPath, pdfData);
      return pdfPath;
    } finally {
      printWindow.close();
    }
  } else {
    const printWindow = new import_electron5.BrowserWindow({
      show: !silent,
      webPreferences: {
        nodeIntegration: false,
        contextIsolation: true
      }
    });
    try {
      await printWindow.loadURL(`data:text/html;charset=utf-8,${encodeURIComponent(html)}`);
      await new Promise((resolve) => setTimeout(resolve, 500));
      await printWindow.webContents.print({
        silent,
        printBackground: true,
        margins: {
          marginType: "none"
        }
      });
      return "";
    } finally {
      if (silent) {
        printWindow.close();
      }
    }
  }
};
var previewBill = async (billId, templateId) => {
  const bill = await getBillById(billId);
  if (!bill) {
    throw new Error("Bill not found");
  }
  const { validateBillGSTCompliance: validateBillGSTCompliance2 } = await Promise.resolve().then(() => (init_gstComplianceService(), gstComplianceService_exports));
  const gstValidation = await validateBillGSTCompliance2(billId);
  if (!gstValidation.compliant) {
    console.warn("GST compliance errors (preview allowed):", gstValidation.errors);
  }
  let finalTemplateId = templateId;
  if (!finalTemplateId && bill.templateId) {
    finalTemplateId = bill.templateId;
  }
  if (!finalTemplateId) {
    const defaultTemplate = await getDefaultBillTemplate("A4");
    if (!defaultTemplate) {
      const templates = await listBillTemplates({ templateType: "A4" });
      if (templates.length === 0) {
        throw new Error("No template found");
      }
      finalTemplateId = templates[0].id;
    } else {
      finalTemplateId = defaultTemplate.id;
    }
  }
  return await renderBillTemplate(finalTemplateId, billId);
};

// electron/src/services/billPaymentService.ts
var import_client19 = require("@prisma/client");
init_prismaClient();
init_auditService();
var toDecimal5 = (value) => new import_client19.Prisma.Decimal(Number(value || 0));
var toNumber11 = (value) => {
  if (value instanceof import_client19.Prisma.Decimal) {
    return value.toNumber();
  }
  return Number(value ?? 0);
};
var mapBillPayment = (payment) => ({
  id: payment.id,
  billId: payment.billId,
  amount: toNumber11(payment.amount),
  paymentDate: payment.paymentDate.toISOString(),
  paymentMethod: payment.paymentMethod,
  referenceNumber: payment.referenceNumber ?? void 0,
  chequeNumber: payment.chequeNumber ?? void 0,
  bank: payment.bank ?? void 0,
  chequeIssueDate: payment.chequeIssueDate?.toISOString() ?? void 0,
  isCleared: payment.isCleared ?? void 0,
  clearedDate: payment.clearedDate?.toISOString() ?? void 0,
  bouncedDate: payment.bouncedDate?.toISOString() ?? void 0,
  notes: payment.notes ?? void 0,
  createdAt: payment.createdAt.toISOString(),
  updatedAt: payment.updatedAt.toISOString()
});
var createBillPayment = async (payload) => {
  if (!payload.amount || payload.amount <= 0) {
    throw new Error("Payment amount must be greater than 0");
  }
  const prisma2 = getPrismaClient();
  return prisma2.$transaction(
    async (tx) => {
      const bill = await tx.bill.findUnique({
        where: { id: payload.billId }
      });
      if (!bill) {
        throw new Error("Bill not found");
      }
      if (bill.status !== "FINALIZED") {
        throw new Error("Can only add payments to finalized bills");
      }
      const currentPaid = toNumber11(bill.paidAmount);
      const newPaid = currentPaid + payload.amount;
      const totalAmount = toNumber11(bill.totalAmount);
      if (newPaid > totalAmount) {
        throw new Error("Payment amount exceeds bill total");
      }
      const outstanding = totalAmount - newPaid;
      if (outstanding < 0) {
        throw new Error(`Payment would result in negative outstanding: ${outstanding}`);
      }
      const payment = await tx.billPayment.create({
        data: {
          billId: payload.billId,
          amount: toDecimal5(payload.amount),
          paymentDate: new Date(payload.paymentDate),
          paymentMethod: payload.paymentMethod,
          referenceNumber: payload.referenceNumber,
          chequeNumber: payload.chequeNumber,
          bank: payload.bank,
          chequeIssueDate: payload.chequeIssueDate ? new Date(payload.chequeIssueDate) : null,
          notes: payload.notes
        }
      });
      const paymentStatus = newPaid >= totalAmount ? "PAID" : newPaid > 0 ? "PARTIAL" : "UNPAID";
      await tx.bill.update({
        where: { id: payload.billId },
        data: {
          paidAmount: toDecimal5(newPaid),
          paymentStatus
        }
      });
      logAuditAsync({
        entity: "BillPayment",
        entityId: payment.id,
        action: "CREATE",
        details: {
          billId: payload.billId,
          amount: payload.amount
        }
      });
      return mapBillPayment(payment);
    },
    { timeout: 3e4 }
    // Increased to 30s for payment processing
  );
};
var listBillPayments = async (billId) => {
  const prisma2 = getPrismaClient();
  const payments = await prisma2.billPayment.findMany({
    where: billId !== void 0 ? { billId } : void 0,
    orderBy: { paymentDate: "desc" }
  });
  return payments.map(mapBillPayment);
};
var deleteBillPayment = async (id) => {
  const prisma2 = getPrismaClient();
  return prisma2.$transaction(
    async (tx) => {
      const payment = await tx.billPayment.findUnique({
        where: { id },
        include: {
          bill: true
        }
      });
      if (!payment) {
        throw new Error("Payment not found");
      }
      const currentPaid = toNumber11(payment.bill.paidAmount);
      const paymentAmount = toNumber11(payment.amount);
      const newPaid = Math.max(0, currentPaid - paymentAmount);
      const totalAmount = toNumber11(payment.bill.totalAmount);
      const paymentStatus = newPaid >= totalAmount ? "PAID" : newPaid > 0 ? "PARTIAL" : "UNPAID";
      await tx.bill.update({
        where: { id: payment.billId },
        data: {
          paidAmount: toDecimal5(newPaid),
          paymentStatus
        }
      });
      await tx.billPayment.delete({
        where: { id }
      });
      logAuditAsync({
        entity: "BillPayment",
        entityId: id,
        action: "DELETE",
        details: {
          billId: payment.billId,
          amount: paymentAmount
        }
      });
    },
    { timeout: 3e4 }
    // Increased to 30s for payment processing
  );
};
var markBillChequeCleared = async (id) => {
  const prisma2 = getPrismaClient();
  return prisma2.$transaction(
    async (tx) => {
      const payment = await tx.billPayment.findUnique({
        where: { id },
        include: { bill: true }
      });
      if (!payment) {
        throw new Error("Payment not found");
      }
      if (payment.paymentMethod !== "CHEQUE") {
        throw new Error("Payment is not a cheque");
      }
      if (payment.isCleared === true) {
        throw new Error("Cheque is already cleared");
      }
      const updated = await tx.billPayment.update({
        where: { id },
        data: {
          isCleared: true,
          clearedDate: /* @__PURE__ */ new Date()
        }
      });
      logAuditAsync({
        entity: "BillPayment",
        entityId: id,
        action: "CHEQUE_CLEARED",
        details: {
          billId: payment.billId,
          chequeNumber: payment.chequeNumber
        }
      });
      return mapBillPayment(updated);
    },
    { timeout: 3e4 }
    // Increased to 30s for payment processing
  );
};
var markBillChequeBounced = async (id) => {
  const prisma2 = getPrismaClient();
  return prisma2.$transaction(
    async (tx) => {
      const payment = await tx.billPayment.findUnique({
        where: { id },
        include: { bill: true }
      });
      if (!payment) {
        throw new Error("Payment not found");
      }
      if (payment.paymentMethod !== "CHEQUE") {
        throw new Error("Payment is not a cheque");
      }
      const bill = payment.bill;
      const currentPaid = toNumber11(bill.paidAmount);
      const paymentAmount = toNumber11(payment.amount);
      const newPaid = Math.max(0, currentPaid - paymentAmount);
      const totalAmount = toNumber11(bill.totalAmount);
      const paymentStatus = newPaid >= totalAmount ? "PAID" : newPaid > 0 ? "PARTIAL" : "UNPAID";
      await tx.bill.update({
        where: { id: bill.id },
        data: {
          paidAmount: toDecimal5(newPaid),
          paymentStatus
        }
      });
      const updated = await tx.billPayment.update({
        where: { id },
        data: {
          isCleared: false,
          bouncedDate: /* @__PURE__ */ new Date()
        }
      });
      logAuditAsync({
        entity: "BillPayment",
        entityId: id,
        action: "CHEQUE_BOUNCED",
        details: {
          billId: payment.billId,
          chequeNumber: payment.chequeNumber
        }
      });
      return mapBillPayment(updated);
    },
    { timeout: 3e4 }
    // Increased to 30s for payment processing
  );
};

// electron/src/services/templateService.ts
var fs8 = __toESM(require("fs"));
var path9 = __toESM(require("path"));

// electron/src/utils/templatePathResolver.ts
var fs7 = __toESM(require("fs"));
var path8 = __toESM(require("path"));
var import_electron6 = require("electron");
var resolveTemplatePath = (templateName) => {
  const paths2 = [
    // Development: project root
    path8.join(process.cwd(), "templates", templateName),
    // Built: dist_electron/templates
    path8.join(__dirname, "..", "templates", templateName),
    // Packaged: app resources/templates
    import_electron6.app.isPackaged ? path8.join(import_electron6.app.getAppPath(), "templates", templateName) : null
  ].filter((p) => p !== null);
  for (const templatePath of paths2) {
    if (fs7.existsSync(templatePath)) {
      return templatePath;
    }
  }
  return null;
};
var readTemplate = (templateName) => {
  try {
    const templatePath = resolveTemplatePath(templateName);
    if (templatePath) {
      return fs7.readFileSync(templatePath, "utf-8");
    }
    const defaultPath = resolveTemplatePath("default-a4-bill.html");
    if (defaultPath) {
      console.warn(`Template ${templateName} not found, using default template`);
      return fs7.readFileSync(defaultPath, "utf-8");
    }
    console.error(`Template ${templateName} and default template not found, using minimal fallback`);
    return `<!DOCTYPE html>
<html>
<head><meta charset="UTF-8"><title>Bill</title></head>
<body>
  <h1>Template Not Found</h1>
  <p>Template "${templateName}" could not be loaded. Please ensure templates are available.</p>
</body>
</html>`;
  } catch (error) {
    console.error(`Error reading template ${templateName}:`, error);
    return `<!DOCTYPE html>
<html>
<head><meta charset="UTF-8"><title>Error</title></head>
<body>
  <h1>Template Error</h1>
  <p>Failed to load template: ${error instanceof Error ? error.message : "Unknown error"}</p>
</body>
</html>`;
  }
};
var listTemplates = () => {
  const templates = [];
  const templateDirs = [
    // Development: project root
    path8.join(process.cwd(), "templates"),
    // Built: dist_electron/templates (when running from dist_electron/main.js)
    path8.join(__dirname, "..", "templates"),
    // Alternative: if __dirname is dist_electron/utils, go up one level
    path8.join(__dirname, "..", "..", "templates"),
    // Packaged: app resources/templates
    import_electron6.app.isPackaged ? path8.join(process.resourcesPath, "templates") : null
  ].filter((p) => p !== null);
  const seen = /* @__PURE__ */ new Set();
  for (const templateDir of templateDirs) {
    try {
      if (fs7.existsSync(templateDir)) {
        const files = fs7.readdirSync(templateDir);
        for (const file of files) {
          if (file.endsWith(".html") && !seen.has(file)) {
            const filePath = path8.join(templateDir, file);
            if (fs7.statSync(filePath).isFile()) {
              templates.push({ name: file, path: filePath });
              seen.add(file);
            }
          }
        }
      }
    } catch (error) {
      console.warn(`Error reading template directory ${templateDir}:`, error);
    }
  }
  if (templates.length === 0) {
    console.warn("No templates found. Checked directories:", templateDirs);
    console.warn("Current working directory:", process.cwd());
    console.warn("__dirname:", __dirname);
    console.warn("app.getAppPath():", import_electron6.app.getAppPath());
  }
  return templates;
};

// electron/src/services/templateService.ts
init_companyInfoService();
init_billService();
var import_electron7 = require("electron");
var import_electron_store = __toESM(require_electron_store());
var store = new import_electron_store.default();
var listTemplatesHandler = async () => {
  try {
    const templates = listTemplates();
    return templates.map((t) => {
      const stats = fs8.statSync(t.path);
      return {
        name: t.name,
        path: t.path,
        size: stats.size,
        modified: stats.mtime.toISOString()
      };
    });
  } catch (error) {
    console.error("Error listing templates:", error);
    return [];
  }
};
var getEmbeddedDefaultTemplate = () => {
  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Tax Invoice - {{companyName}}</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    .bill-container { max-width: 800px; margin: 0 auto; }
    .header { display: flex; justify-content: space-between; margin-bottom: 20px; }
    .company-info { flex: 1; }
    .customer-info { flex: 1; }
    table { width: 100%; border-collapse: collapse; margin: 20px 0; }
    th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
    th { background-color: #f2f2f2; }
    .total-row { font-weight: bold; }
    .footer { margin-top: 20px; text-align: center; }
  </style>
</head>
<body>
  <div class="bill-container">
    <div class="header">
      <div class="company-info">
        <h2>{{companyName}}</h2>
        <p>{{address}}</p>
        <p>GST: {{gstin}}</p>
      </div>
      <div class="customer-info">
        <h3>Bill To:</h3>
        <p>{{customerName}}</p>
        <p>{{customerAddress}}</p>
      </div>
    </div>
    <div>
      <p><strong>Bill Number:</strong> {{billNumber}}</p>
      <p><strong>Date:</strong> {{billDate}}</p>
    </div>
    <table>
      <thead>
        <tr>
          <th>Item</th>
          <th>Qty</th>
          <th>Rate</th>
          <th>Amount</th>
        </tr>
      </thead>
      <tbody>
        {{#each items}}
        <tr>
          <td>{{productName}}</td>
          <td>{{quantity}}</td>
          <td>{{rate}}</td>
          <td>{{lineTotal}}</td>
        </tr>
        {{/each}}
      </tbody>
      <tfoot>
        <tr class="total-row">
          <td colspan="3">Total</td>
          <td>{{totalAmount}}</td>
        </tr>
      </tfoot>
    </table>
    <div class="footer">
      <p>Thank you for your business!</p>
    </div>
  </div>
</body>
</html>`;
};
var loadTemplateHandler = async (request) => {
  try {
    let html;
    const warnings = [];
    try {
      html = readTemplate(request.name);
      if (html.includes("Template Not Found") || html.includes("Template Error")) {
        warnings.push(`Template file ${request.name} not found, using embedded default`);
        html = getEmbeddedDefaultTemplate();
      }
    } catch (error) {
      warnings.push(`Error reading template ${request.name}: ${error instanceof Error ? error.message : "Unknown error"}`);
      html = getEmbeddedDefaultTemplate();
    }
    let css;
    const cssName = request.name.replace(".html", ".css");
    const cssPath = resolveTemplatePath(cssName);
    if (cssPath) {
      try {
        css = fs8.readFileSync(cssPath, "utf-8");
        if (html.includes("{{cssContent}}")) {
          html = html.replace("{{cssContent}}", css);
        }
      } catch (err) {
        warnings.push(`CSS file ${cssName} not found`);
        html = html.replace("{{cssContent}}", "");
      }
    } else {
      html = html.replace("{{cssContent}}", "");
    }
    return { html, css, warnings };
  } catch (error) {
    console.error(`Critical error loading template ${request.name}:`, error);
    return {
      html: getEmbeddedDefaultTemplate(),
      warnings: [`Critical error: ${error instanceof Error ? error.message : "Unknown error"}. Using embedded default template.`]
    };
  }
};
var saveTemplateHandler = async (request) => {
  try {
    const templateName = request.name.endsWith(".html") ? request.name : `${request.name}.html`;
    const isDefault = templateName === "default-a4-bill.html";
    if (isDefault) {
      const defaultPath = resolveTemplatePath("default-a4-bill.html");
      if (defaultPath && fs8.existsSync(defaultPath)) {
        const timestamp = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-");
        const backupName = `default-a4-bill.backup-${timestamp}.html`;
        const backupPath = path9.join(path9.dirname(defaultPath), backupName);
        fs8.copyFileSync(defaultPath, backupPath);
        console.log(`Created backup: ${backupName}`);
      }
    }
    const savePath = path9.join(process.cwd(), "templates", templateName);
    const saveDir = path9.dirname(savePath);
    if (!fs8.existsSync(saveDir)) {
      fs8.mkdirSync(saveDir, { recursive: true });
    }
    fs8.writeFileSync(savePath, request.html, "utf-8");
    return {
      success: true,
      message: isDefault ? `Template saved. Backup created at ${path9.basename(savePath)}.backup-*.html` : "Template saved successfully"
    };
  } catch (error) {
    console.error(`Error saving template ${request.name}:`, error);
    return {
      success: false,
      message: error instanceof Error ? error.message : "Failed to save template"
    };
  }
};
var renderTemplateHandler = async (request) => {
  const warnings = [];
  try {
    const templateName = request.templateName || store.get("billing:lastTemplate", "default-a4-bill.html");
    let html = readTemplate(templateName);
    if (!html || html.includes("Template Not Found")) {
      warnings.push(`Template ${templateName} not found, using default`);
      html = readTemplate("default-a4-bill.html");
    }
    const cssName = templateName.replace(".html", ".css");
    const cssPath = resolveTemplatePath(cssName);
    if (cssPath && fs8.existsSync(cssPath)) {
      try {
        const css = fs8.readFileSync(cssPath, "utf-8");
        if (html.includes("{{cssContent}}")) {
          html = html.replace("{{cssContent}}", css);
        }
      } catch (err) {
        warnings.push(`Could not load CSS for ${templateName}`);
      }
    } else if (html.includes("{{cssContent}}")) {
      html = html.replace("{{cssContent}}", "");
    }
    const companyInfo = await getCompanyInfo();
    let templateData = {
      companyName: companyInfo?.companyName || "",
      address: companyInfo?.address || "",
      phone: companyInfo?.phone || "",
      email: companyInfo?.email || "",
      gstin: companyInfo?.gstNumber || "",
      fssaiNumber: companyInfo?.fssaiNumber || "",
      dlNo1: companyInfo?.dlNumber1 || "",
      dlNo2: companyInfo?.dlNumber2 || "",
      state: companyInfo?.state || "",
      stateCode: companyInfo?.stateCode || "",
      logoPath: companyInfo?.logoPath || "",
      signaturePath: companyInfo?.signPath || ""
    };
    if (request.billId) {
      const bill = await getBillById(request.billId);
      let customerDlNo = "";
      let customerDlNo2 = "";
      let customerPanNumber = "";
      let customerState = "";
      let customerStateCode = "";
      let customerAddressLine1 = "";
      let customerAddressLine2 = "";
      let customerCity = "";
      let customerPostalCode = "";
      let customerEmail = "";
      if (bill.customerId) {
        try {
          const { getCustomerById: getCustomerById2 } = await Promise.resolve().then(() => (init_customerService(), customerService_exports));
          const customer = await getCustomerById2(bill.customerId);
          customerDlNo = customer.drugLicenseNumber || "";
          customerDlNo2 = customer.drugLicenseNumber2 || "";
          customerPanNumber = customer.panNumber || "";
          customerState = customer.state || "";
          customerStateCode = customer.stateCode || "";
          customerAddressLine1 = customer.addressLine1 || "";
          customerAddressLine2 = customer.addressLine2 || "";
          customerCity = customer.city || "";
          customerPostalCode = customer.postalCode || "";
          customerEmail = customer.email || "";
          if (!customerStateCode && customer.gstin && customer.gstin.length >= 2) {
            customerStateCode = customer.gstin.substring(0, 2);
          }
        } catch (err) {
          console.warn("Could not load customer details:", err);
        }
      }
      templateData = {
        ...templateData,
        billNumber: bill.billNumber,
        billDate: new Date(bill.billDate).toLocaleDateString("en-IN"),
        dueDate: bill.dueDate ? new Date(bill.dueDate).toLocaleDateString("en-IN") : void 0,
        challanNumber: bill.challanNumber,
        orderNumber: bill.orderNumber,
        customerName: bill.customerName,
        customerAddress: bill.customerAddress,
        customerPhone: bill.customerPhone,
        customerGstin: bill.customerGstin,
        customerDlNo,
        customerDlNo2,
        customerPanNumber,
        customerState,
        customerStateCode,
        customerAddressLine1,
        customerAddressLine2,
        customerCity,
        customerPostalCode,
        customerEmail,
        isOriginal: true,
        // Default to ORIGINAL
        supplierName: bill.supplierName,
        supplierAddress: bill.supplierAddress,
        supplierPhone: bill.supplierPhone,
        supplierGstin: bill.supplierGstin,
        remarks: bill.remarks,
        subtotal: bill.subtotal,
        totalDiscount: bill.totalDiscount,
        totalTax: bill.totalTax,
        taxableAmount: bill.subtotal - bill.totalDiscount,
        cgstTotal: bill.cgstTotal,
        sgstTotal: bill.sgstTotal,
        igstTotal: bill.igstTotal,
        roundOff: bill.roundOff,
        totalAmount: bill.totalAmount,
        totalSaving: 0,
        // Calculate from discount
        totalSavingPercent: bill.totalDiscount > 0 ? (bill.totalDiscount / bill.subtotal * 100).toFixed(2) : "0.00",
        totalSavingValue: bill.totalDiscount,
        lines: bill.lines.map((line) => ({
          lineNumber: line.lineNumber,
          hsnCode: line.hsnCode,
          productName: line.productName,
          manufacturer: line.manufacturer || "",
          packSize: line.packSize || "",
          batchNumber: line.batchNumber || "",
          expiryDate: line.expiryDate ? new Date(line.expiryDate).toLocaleDateString("en-IN") : "",
          mrp: line.mrp,
          ptr: line.ptr,
          pts: line.pts,
          rate: line.rate,
          quantity: line.quantity,
          freeQuantity: line.freeQuantity,
          discountPercent: line.discountPercent,
          discountAmount: line.discountAmount || 0,
          taxPercent: line.taxPercent || 0,
          cgstPercent: line.cgstPercent || 0,
          sgstPercent: line.sgstPercent || 0,
          igstPercent: line.igstPercent || 0,
          taxableAmount: line.taxableAmount || 0,
          cgstAmount: line.cgstAmount || 0,
          sgstAmount: line.sgstAmount || 0,
          igstAmount: line.igstAmount || 0,
          lineTotal: line.lineTotal,
          savingPercent: line.savingPercent || 0,
          savingValue: line.savingValue || 0
        })),
        // GST Summary grouped by rate
        gstSummary: (() => {
          const gstMap = /* @__PURE__ */ new Map();
          bill.lines.forEach((line) => {
            const rate = line.taxPercent || 0;
            const cgstRate = line.cgstPercent || 0;
            const sgstRate = line.sgstPercent || 0;
            const existing = gstMap.get(rate) || { rate, taxable: 0, cgst: 0, sgst: 0, igst: 0, total: 0, cgstRate, sgstRate };
            existing.taxable += line.taxableAmount || 0;
            existing.cgst += line.cgstAmount || 0;
            existing.sgst += line.sgstAmount || 0;
            existing.igst += line.igstAmount || 0;
            existing.total += (line.cgstAmount || 0) + (line.sgstAmount || 0) + (line.igstAmount || 0);
            gstMap.set(rate, existing);
          });
          return Array.from(gstMap.values()).sort((a, b) => b.rate - a.rate);
        })()
      };
    } else if (request.sample) {
      templateData = {
        ...templateData,
        billNumber: "SAL-202412-0001",
        billDate: (/* @__PURE__ */ new Date()).toLocaleDateString("en-IN"),
        customerName: "Sample Customer",
        customerAddress: "123 Sample Street, Sample City",
        customerGstin: "29ABCDE1234F1Z5",
        customerDlNo: "20-MH-TZ6-123456",
        customerState: "Maharashtra",
        customerStateCode: "27",
        subtotal: 1e4,
        totalDiscount: 500,
        totalTax: 1710,
        taxableAmount: 9500,
        cgstTotal: 855,
        sgstTotal: 855,
        roundOff: 0,
        totalAmount: 11210,
        totalSaving: 500,
        totalSavingPercent: "5.00",
        totalSavingValue: 500,
        lines: [
          {
            lineNumber: 1,
            hsnCode: "30049069",
            productName: "Sample Medicine",
            manufacturer: "Sample Pharma",
            packSize: "10 TAB",
            batchNumber: "BATCH001",
            expiryDate: "12/2025",
            mrp: 100,
            ptr: 80,
            rate: 80,
            quantity: 100,
            freeQuantity: 0,
            discountPercent: 5,
            discountAmount: 400,
            taxPercent: 5,
            taxableAmount: 7600,
            cgstAmount: 190,
            sgstAmount: 190,
            lineTotal: 7980
          }
        ],
        gstSummary: [
          {
            rate: 5,
            taxable: 7600,
            cgst: 190,
            sgst: 190,
            total: 7980,
            cgstRate: 2.5,
            sgstRate: 2.5
          }
        ]
      };
    }
    html = renderTemplateServer(html, templateData);
    return { html, warnings };
  } catch (error) {
    console.error("Error rendering template:", error);
    warnings.push(error instanceof Error ? error.message : "Unknown error");
    return {
      html: `<!DOCTYPE html><html><body><h1>Render Error</h1><p>${error instanceof Error ? error.message : "Unknown error"}</p></body></html>`,
      warnings
    };
  }
};
var getNestedValue = (obj, path16) => {
  const parts = path16.split(".");
  let current = obj;
  for (const part of parts) {
    if (current === null || current === void 0) return null;
    if (/^\d+$/.test(part)) {
      current = current[parseInt(part, 10)];
    } else {
      current = current[part];
    }
  }
  return current;
};
var renderTemplateServer = (html, data) => {
  let result = html;
  const replacePlaceholder = (key, value) => {
    const regex = new RegExp(`\\{\\{${key}\\}\\}`, "g");
    result = result.replace(regex, String(value || ""));
  };
  Object.keys(data).forEach((key) => {
    if (key === "lines" && Array.isArray(data[key])) {
      return;
    }
    replacePlaceholder(key, data[key]);
  });
  if (data.lines && Array.isArray(data.lines)) {
    const linesMatch = result.match(/\{\{#each\s+lines\}\}([\s\S]*?)\{\{\/each\}\}/);
    if (linesMatch) {
      const lineTemplate = linesMatch[1];
      const renderedLines = data.lines.map((line) => {
        let lineHtml = lineTemplate;
        Object.keys(line).forEach((key) => {
          const regex = new RegExp(`\\{\\{${key}\\}\\}`, "g");
          lineHtml = lineHtml.replace(regex, String(line[key] || ""));
        });
        lineHtml = lineHtml.replace(/\{\{formatCurrency\(([^)]+)\)\}\}/g, (match, expr) => {
          const value = line[expr.trim()] || 0;
          return typeof value === "number" ? value.toFixed(2) : parseFloat(String(value)).toFixed(2);
        });
        lineHtml = lineHtml.replace(/\{\{formatCurrency\s+([^}]+)\}\}/g, (match, expr) => {
          const value = line[expr.trim()] || 0;
          return typeof value === "number" ? value.toFixed(2) : parseFloat(String(value)).toFixed(2);
        });
        return lineHtml;
      }).join("");
      result = result.replace(linesMatch[0], renderedLines);
    }
  }
  result = result.replace(/\{\{formatCurrency\(([^)]+)\)\}\}/g, (match, expr) => {
    const value = getNestedValue(data, expr.trim()) || 0;
    return typeof value === "number" ? value.toFixed(2) : parseFloat(String(value)).toFixed(2);
  });
  result = result.replace(/\{\{formatCurrency\s+([^}]+)\}\}/g, (match, expr) => {
    const value = getNestedValue(data, expr.trim()) || 0;
    return typeof value === "number" ? value.toFixed(2) : parseFloat(String(value)).toFixed(2);
  });
  result = result.replace(/\{\{numberToWords\(([^)]+)\)\}\}/g, (match, expr) => {
    const value = getNestedValue(data, expr.trim()) || 0;
    const num = typeof value === "number" ? value : parseFloat(String(value));
    return numberToWordsServer(num);
  });
  result = result.replace(/\{\{numberToWords\s+([^}]+)\}\}/g, (match, expr) => {
    const value = getNestedValue(data, expr.trim()) || 0;
    const num = typeof value === "number" ? value : parseFloat(String(value));
    return numberToWordsServer(num);
  });
  result = result.replace(/\{\{#if\s+([^}]+)\}\}([\s\S]*?)\{\{\/if\}\}/g, (match, condition, content) => {
    const value = data[condition.trim()];
    if (value && value !== "" && value !== "0" && value !== 0 && value !== false) {
      return content;
    }
    return "";
  });
  return result;
};
var numberToWordsServer = (num) => {
  const ones = [
    "",
    "ONE",
    "TWO",
    "THREE",
    "FOUR",
    "FIVE",
    "SIX",
    "SEVEN",
    "EIGHT",
    "NINE",
    "TEN",
    "ELEVEN",
    "TWELVE",
    "THIRTEEN",
    "FOURTEEN",
    "FIFTEEN",
    "SIXTEEN",
    "SEVENTEEN",
    "EIGHTEEN",
    "NINETEEN"
  ];
  const tens = ["", "", "TWENTY", "THIRTY", "FORTY", "FIFTY", "SIXTY", "SEVENTY", "EIGHTY", "NINETY"];
  if (num === 0) return "ZERO ONLY";
  let wholePart = Math.floor(num);
  const decimalPart = Math.round((num - wholePart) * 100);
  const convertHundreds = (n) => {
    let result2 = "";
    if (n >= 100) {
      result2 += ones[Math.floor(n / 100)] + " HUNDRED";
      n %= 100;
      if (n > 0) result2 += " ";
    }
    if (n >= 20) {
      result2 += tens[Math.floor(n / 10)];
      if (n % 10 > 0) result2 += " " + ones[n % 10];
    } else if (n > 0) {
      result2 += ones[n];
    }
    return result2;
  };
  let result = "";
  if (wholePart >= 1e7) {
    const crores = Math.floor(wholePart / 1e7);
    result += convertHundreds(crores) + " CRORE";
    wholePart %= 1e7;
    if (wholePart > 0) result += " ";
  }
  if (wholePart >= 1e5) {
    const lakhs = Math.floor(wholePart / 1e5);
    result += convertHundreds(lakhs) + " LAKH";
    wholePart %= 1e5;
    if (wholePart > 0) result += " ";
  }
  if (wholePart >= 1e3) {
    const thousands = Math.floor(wholePart / 1e3);
    result += convertHundreds(thousands) + " THOUSAND";
    wholePart %= 1e3;
    if (wholePart > 0) result += " ";
  }
  if (wholePart > 0) {
    result += convertHundreds(wholePart);
  }
  if (decimalPart > 0) {
    result += " AND " + convertHundreds(decimalPart) + " PAISE";
  }
  return result.trim().toUpperCase() + " ONLY";
};
var printTemplateHandler = async (request) => {
  try {
    const renderResult = await renderTemplateHandler(request);
    const printWindow = new import_electron7.BrowserWindow({
      show: false,
      webPreferences: {
        nodeIntegration: false,
        contextIsolation: true
      }
    });
    await printWindow.loadURL(`data:text/html;charset=utf-8,${encodeURIComponent(renderResult.html)}`);
    await new Promise((resolve) => setTimeout(resolve, 500));
    if (request.silent) {
      await printWindow.webContents.print({ silent: true, printBackground: true });
    } else {
      await printWindow.webContents.print({ printBackground: true });
    }
    printWindow.close();
    return { success: true };
  } catch (error) {
    console.error("Error printing template:", error);
    return { success: false };
  }
};

// electron/src/ipcHandlers/index.ts
var getUserId = (payload) => {
  if (payload?.userId) return payload.userId;
  if (payload?.token) return getUserIdFromToken(payload.token);
  return null;
};
var withPermission = (channel, handler, permission, disposers, timeout = 3e4) => {
  const wrapped = async (_event, payload) => {
    try {
      const p = payload;
      const userId = getUserId(p);
      if (!userId && permission) {
        throw new Error("Authentication required");
      }
      if (permission && userId) {
        await requirePermission(userId, permission);
      }
      const safeHandler = async (rawPayload) => {
        const payloadWithUserId = userId && !rawPayload?.userId ? { ...rawPayload, userId } : rawPayload;
        return await safeDbOperation(
          () => handler(payloadWithUserId),
          { operation: channel, userId: userId || void 0 }
        );
      };
      return await wrapIpcHandler(safeHandler, channel, timeout)(
        _event,
        payload
      );
    } catch (error) {
      logger.error(`[IPC Error] ${channel}:`, {
        error: error instanceof Error ? error.message : String(error),
        stack: error instanceof Error ? error.stack : void 0,
        payload
      });
      const friendlyError = getUserFriendlyError(error);
      throw new Error(friendlyError);
    }
  };
  import_electron13.ipcMain.handle(channel, wrapped);
  if (disposers) {
    disposers.push(() => import_electron13.ipcMain.removeHandler(channel));
  }
};
var register = (channel, handler, disposers, timeout = 3e4) => {
  const wrapped = async (_event, payload) => {
    try {
      const safeHandler = async (p) => {
        return await safeDbOperation(
          () => handler(p),
          { operation: channel }
        );
      };
      return await wrapIpcHandler(safeHandler, channel, timeout)(
        _event,
        payload
      );
    } catch (error) {
      logger.error(`[IPC Error] ${channel}:`, {
        error: error instanceof Error ? error.message : String(error),
        stack: error instanceof Error ? error.stack : void 0,
        payload
      });
      const friendlyError = getUserFriendlyError(error);
      throw new Error(friendlyError);
    }
  };
  import_electron13.ipcMain.handle(channel, wrapped);
  disposers.push(() => import_electron13.ipcMain.removeHandler(channel));
};
var registerIpcHandlers = async () => {
  const disposers = [];
  try {
    console.log("Starting IPC handler registration...");
    await ensureDefaultAdmin();
    console.log("Default admin ensured");
  } catch (error) {
    console.error("Failed to ensure default admin:", error);
    throw error;
  }
  register("ipc.auth.login", authenticateUser, disposers);
  register("ipc.security.getSettings", async () => {
    const { getSecuritySettings: getSecuritySettings2 } = await Promise.resolve().then(() => (init_securityService(), securityService_exports));
    return getSecuritySettings2();
  }, disposers);
  register("ipc.security.updateSettings", async (settings) => {
    const { updateSecuritySettings: updateSecuritySettings2 } = await Promise.resolve().then(() => (init_securityService(), securityService_exports));
    return updateSecuritySettings2(settings);
  }, disposers);
  register("ipc.security.trackActivity", async ({ userId }) => {
    const { trackSessionActivity: trackSessionActivity2 } = await Promise.resolve().then(() => (init_securityService(), securityService_exports));
    trackSessionActivity2(userId);
    return { success: true };
  }, disposers);
  register("ipc.security.checkSession", async ({ userId }) => {
    const { isSessionValid: isSessionValid2, getSessionInfo: getSessionInfo2 } = await Promise.resolve().then(() => (init_securityService(), securityService_exports));
    const valid = isSessionValid2(userId);
    const info = getSessionInfo2(userId);
    return info ? { valid, info } : { valid };
  }, disposers);
  register("ipc.security.clearSession", async ({ userId }) => {
    const { clearSession: clearSession2 } = await Promise.resolve().then(() => (init_securityService(), securityService_exports));
    clearSession2(userId);
    return { success: true };
  }, disposers);
  register("ipc.diagnostics.getInfo", async () => {
    const { getDiagnosticInfo: getDiagnosticInfo2 } = await Promise.resolve().then(() => (init_diagnosticsService(), diagnosticsService_exports));
    return getDiagnosticInfo2();
  }, disposers);
  register("ipc.diagnostics.exportLogs", async ({ outputPath }) => {
    const { exportLogs: exportLogs2 } = await Promise.resolve().then(() => (init_diagnosticsService(), diagnosticsService_exports));
    return { filePath: await exportLogs2(outputPath) };
  }, disposers);
  register("ipc.diagnostics.exportDBSnapshot", async ({ outputPath }) => {
    const { exportDBSnapshot: exportDBSnapshot2 } = await Promise.resolve().then(() => (init_diagnosticsService(), diagnosticsService_exports));
    return { filePath: await exportDBSnapshot2(outputPath) };
  }, disposers);
  register("ipc.diagnostics.getHealth", async () => {
    const { getSystemHealth: getSystemHealth2 } = await Promise.resolve().then(() => (init_diagnosticsService(), diagnosticsService_exports));
    return getSystemHealth2();
  }, disposers);
  register("ipc.diagnostics.validateDB", async () => {
    const { validateDatabaseIntegrity: validateDatabaseIntegrity2 } = await Promise.resolve().then(() => (init_diagnosticsService(), diagnosticsService_exports));
    return validateDatabaseIntegrity2();
  }, disposers);
  register("ipc.diagnostics.getReport", async () => {
    const { getDiagnosticReport: getDiagnosticReport2 } = await Promise.resolve().then(() => (init_diagnosticsService(), diagnosticsService_exports));
    return getDiagnosticReport2();
  }, disposers);
  register("ipc.diagnostics.isSafeMode", async () => {
    const { isSafeMode: isSafeMode2 } = await Promise.resolve().then(() => (init_diagnosticsService(), diagnosticsService_exports));
    return { safeMode: isSafeMode2() };
  }, disposers);
  register("ipc.diagnostics.isReadOnly", async () => {
    const { isReadOnlyMode: isReadOnlyMode2 } = await Promise.resolve().then(() => (init_diagnosticsService(), diagnosticsService_exports));
    return { readOnly: isReadOnlyMode2() };
  }, disposers);
  register("ipc.migration.getVersion", async () => {
    const { getCurrentSchemaVersion: getCurrentSchemaVersion2 } = await Promise.resolve().then(() => (init_migrationService(), migrationService_exports));
    return { version: await getCurrentSchemaVersion2() };
  }, disposers);
  register("ipc.migration.getStatus", async () => {
    const { getMigrationStatus: getMigrationStatus2 } = await Promise.resolve().then(() => (init_migrationService(), migrationService_exports));
    return getMigrationStatus2([]);
  }, disposers);
  register("ipc.migration.run", async ({ migrations }) => {
    const { runMigrations: runMigrations2 } = await Promise.resolve().then(() => (init_migrationService(), migrationService_exports));
    return runMigrations2(migrations || []);
  }, disposers);
  register("ipc.migration.validate", async ({ requiredVersion, migrations }) => {
    const { validateSchemaCompatibility: validateSchemaCompatibility2 } = await Promise.resolve().then(() => (init_migrationService(), migrationService_exports));
    return validateSchemaCompatibility2(requiredVersion, migrations || []);
  }, disposers);
  register("ipc.migration.getApplied", async () => {
    const { getAppliedMigrations: getAppliedMigrations2 } = await Promise.resolve().then(() => (init_migrationService(), migrationService_exports));
    return getAppliedMigrations2();
  }, disposers);
  withPermission("ipc.product.create", createProduct, "products.create", disposers);
  register("ipc.product.list", listProducts, disposers);
  register("ipc.product.get", ({ id }) => getProductById(id), disposers);
  withPermission("ipc.product.update", ({ id, data }) => updateProduct(id, data), "products.update", disposers);
  withPermission("ipc.product.delete", async ({ id, userId, reason }) => {
    if (!userId) {
      throw new Error("User ID is required for deletion");
    }
    return deleteProduct(id, userId, reason);
  }, "products.delete", disposers);
  register("ipc.stock.snapshot", (payload) => getStockSnapshot(payload), disposers);
  register("ipc.stock.kpis", () => getStockKPIs(), disposers);
  register("ipc.stock.alerts", () => getStockAlerts(), disposers);
  register(
    "ipc.stock.movements",
    (payload) => getStockMovements(payload),
    disposers
  );
  register(
    "ipc.stock.movementChart",
    ({ fromDate, toDate }) => getStockMovementChartData(fromDate, toDate),
    disposers
  );
  register(
    "ipc.stock.expiring",
    (payload) => getExpiringBatches(payload),
    disposers
  );
  register("ipc.dashboard.summary", getDashboardSummary, disposers);
  register("ipc.user.list", listUsers, disposers);
  withPermission("ipc.user.create", createUser, "users.create", disposers);
  withPermission("ipc.user.get", ({ id }) => getUserById(id), "users.view", disposers);
  withPermission("ipc.user.update", ({ id, data }) => updateUser(id, data), "users.update", disposers);
  withPermission("ipc.user.delete", ({ id }) => deleteUser(id), "users.delete", disposers);
  register("ipc.role.list", listRoles, disposers);
  register("ipc.report.sales", getSalesReport, disposers);
  register("ipc.report.purchase", getPurchaseReport, disposers);
  register("ipc.report.profitloss", getProfitLossReport, disposers);
  register(
    "ipc.supplier.list",
    (payload) => listSuppliers(payload?.search),
    disposers
  );
  register("ipc.supplier.create", createSupplier, disposers);
  register("ipc.supplier.get", ({ id }) => getSupplierById(id), disposers);
  register("ipc.supplier.update", ({ id, data }) => updateSupplier(id, data), disposers);
  register("ipc.supplier.delete", ({ id }) => deleteSupplier(id), disposers);
  register("ipc.purchase.create", createPurchaseInvoice, disposers);
  register("ipc.purchase.list", listPurchaseInvoices, disposers);
  register("ipc.purchase.get", ({ id }) => getPurchaseInvoiceById(id), disposers);
  withPermission("ipc.purchase.delete", async ({ id, userId, reason, force }) => {
    if (!userId) {
      throw new Error("User ID is required for deletion");
    }
    if (force) {
      await requireAdmin(userId, "Only ADMIN can force delete paid invoices");
    }
    return deletePurchaseInvoice(id, userId, reason, force);
  }, "bills.delete", disposers);
  register("ipc.sales.create", createSalesInvoice, disposers);
  register("ipc.sales.list", listSalesInvoices, disposers);
  register("ipc.sales.get", ({ id }) => getSalesInvoiceById(id), disposers);
  withPermission("ipc.sales.delete", async ({ id, userId, reason, force }) => {
    if (!userId) {
      throw new Error("User ID is required for deletion");
    }
    if (force) {
      await requireAdmin(userId, "Only ADMIN can force delete finalized invoices");
    }
    return deleteSalesInvoice(id, userId, reason, force);
  }, "bills.delete", disposers);
  register(
    "ipc.customer.list",
    (payload) => listCustomers(payload?.search),
    disposers
  );
  register("ipc.customer.create", createCustomer, disposers);
  register("ipc.customer.get", ({ id }) => getCustomerById(id), disposers);
  register("ipc.customer.update", ({ id, data }) => updateCustomer(id, data), disposers);
  register("ipc.customer.delete", ({ id }) => deleteCustomer(id), disposers);
  register("ipc.backup.export", async () => {
    const result = await exportBackup();
    if (!result.success || !result.filePath) {
      throw new Error(result.error || "Backup export failed");
    }
    return { filePath: result.filePath };
  }, disposers);
  register("ipc.backup.import", async ({ filePath }) => {
    await importBackup(filePath);
    return { filePath };
  }, disposers);
  register("ipc.backup.create", async () => {
    const result = await createBackup();
    return result;
  }, disposers, 12e4);
  register("ipc.backup.list", async () => {
    return listBackups();
  }, disposers, 3e4);
  register("ipc.backup.restore", async ({ filePath, validateBeforeRestore }) => {
    return restoreBackup(filePath, { validateBeforeRestore });
  }, disposers, 3e5);
  register("ipc.backup.verify", async ({ filePath }) => {
    return verifyBackupIntegrity(filePath);
  }, disposers, 6e4);
  register("ipc.draft.autoSave", async ({ billId, payload, userId }) => {
    const { autoSaveDraft: autoSaveDraft2 } = await Promise.resolve().then(() => (init_draftService(), draftService_exports));
    return autoSaveDraft2(billId, payload, userId);
  }, disposers);
  register("ipc.draft.getRecoverable", async ({ userId }) => {
    const { getRecoverableDrafts: getRecoverableDrafts2 } = await Promise.resolve().then(() => (init_draftService(), draftService_exports));
    return getRecoverableDrafts2(userId);
  }, disposers);
  register("ipc.draft.cleanup", async () => {
    const { cleanupOldDrafts: cleanupOldDrafts2 } = await Promise.resolve().then(() => (init_draftService(), draftService_exports));
    const count = await cleanupOldDrafts2();
    return { success: true, count };
  }, disposers);
  register("ipc.einvoice.queue", queueEInvoice, disposers);
  register("ipc.einvoice.list", listEInvoiceQueue, disposers);
  register("ipc.einvoice.sync", syncEInvoiceQueue, disposers);
  register("ipc.creditnote.create", createCreditNote, disposers);
  register("ipc.creditnote.list", listCreditNotes, disposers);
  register("ipc.creditnote.get", ({ id }) => getCreditNoteById(id), disposers);
  register("ipc.scheme.create", createScheme, disposers);
  register("ipc.scheme.list", listSchemes, disposers);
  register("ipc.scheme.update", ({ id, data }) => updateScheme(id, data), disposers);
  register("ipc.scheme.delete", ({ id }) => deleteScheme(id), disposers);
  register("ipc.godown.list", listGodowns, disposers);
  register("ipc.godown.create", createGodown, disposers);
  register("ipc.godown.update", ({ id, data }) => updateGodown(id, data), disposers);
  register("ipc.godown.delete", ({ id }) => deleteGodown(id), disposers);
  register("ipc.batch.list", (payload) => listBatches(payload?.productId), disposers);
  register("ipc.batch.get", ({ id }) => getBatchById(id), disposers);
  register("ipc.batch.create", createBatch, disposers);
  register("ipc.batch.update", ({ id, data }) => updateBatch(id, data), disposers);
  register("ipc.batch.delete", ({ id }) => deleteBatch(id), disposers);
  register("ipc.batch.transfer", transferBatch, disposers);
  withPermission("ipc.payment.create", createPayment, "payments.create", disposers);
  register("ipc.payment.list", (payload) => listPayments(payload), disposers);
  withPermission("ipc.payment.update", ({ id, data }) => updatePayment(id, data), "payments.update", disposers);
  withPermission("ipc.payment.markChequeCleared", ({ id }) => markChequeCleared(id), "payments.update", disposers);
  withPermission("ipc.payment.markChequeBounced", ({ id }) => markChequeBounced(id), "payments.update", disposers);
  withPermission("ipc.payment.delete", ({ id }) => deletePayment(id), "payments.delete", disposers);
  register("ipc.mr.list", (payload) => listMRs(payload?.search), disposers);
  register("ipc.mr.create", createMR, disposers);
  register("ipc.mr.get", ({ id }) => getMRById(id), disposers);
  register("ipc.mr.update", ({ id, data }) => updateMR(id, data), disposers);
  register("ipc.mr.delete", ({ id }) => deleteMR(id), disposers);
  register("ipc.doctor.list", (payload) => listDoctors(payload?.search), disposers);
  register("ipc.doctor.create", createDoctor, disposers);
  register("ipc.doctor.get", ({ id }) => getDoctorById(id), disposers);
  register("ipc.doctor.update", ({ id, data }) => updateDoctor(id, data), disposers);
  register("ipc.doctor.delete", ({ id }) => deleteDoctor(id), disposers);
  register("ipc.category.list", () => listCategories(), disposers);
  register("ipc.category.create", createCategory, disposers);
  register("ipc.category.update", ({ id, data }) => updateCategory(id, data), disposers);
  register("ipc.category.delete", ({ id }) => deleteCategory(id), disposers);
  register("ipc.subcategory.list", (payload) => listSubcategories(payload?.categoryId), disposers);
  register("ipc.subcategory.create", createSubcategory, disposers);
  register("ipc.subcategory.update", ({ id, data }) => updateSubcategory(id, data), disposers);
  register("ipc.subcategory.delete", ({ id }) => deleteSubcategory(id), disposers);
  register("ipc.company.list", () => listCompanies(), disposers);
  register("ipc.company.create", createCompany, disposers);
  register("ipc.company.update", ({ id, data }) => updateCompany(id, data), disposers);
  register("ipc.company.delete", ({ id }) => deleteCompany(id), disposers);
  register("ipc.schedule.list", () => listSchedules(), disposers);
  register("ipc.schedule.create", createSchedule, disposers);
  register("ipc.schedule.update", ({ id, data }) => updateSchedule(id, data), disposers);
  register("ipc.schedule.delete", ({ id }) => deleteSchedule(id), disposers);
  register("ipc.scheduleH1.getRegister", async (filters) => {
    const { getScheduleH1Register: getScheduleH1Register2 } = await Promise.resolve().then(() => (init_scheduleH1RegisterService(), scheduleH1RegisterService_exports));
    return getScheduleH1Register2(filters);
  }, disposers);
  register("ipc.scheduleH1.exportCSV", async ({ filters, outputPath }) => {
    const { exportScheduleH1RegisterCSV: exportScheduleH1RegisterCSV2 } = await Promise.resolve().then(() => (init_scheduleH1RegisterService(), scheduleH1RegisterService_exports));
    return { filePath: await exportScheduleH1RegisterCSV2(filters, outputPath) };
  }, disposers, 6e4);
  register("ipc.scheduleH1.exportPDF", async ({ filters, outputPath }) => {
    const { exportScheduleH1RegisterPDF: exportScheduleH1RegisterPDF2 } = await Promise.resolve().then(() => (init_scheduleH1RegisterService(), scheduleH1RegisterService_exports));
    return { filePath: await exportScheduleH1RegisterPDF2(filters, outputPath) };
  }, disposers, 6e4);
  register("ipc.gst.exportGSTR1JSON", async ({ filters, outputPath }) => {
    const { exportGSTR1JSON: exportGSTR1JSON2 } = await Promise.resolve().then(() => (init_gstr1ExportService(), gstr1ExportService_exports));
    return { filePath: await exportGSTR1JSON2(filters, outputPath) };
  }, disposers, 6e4);
  register("ipc.gst.exportGSTR1Excel", async ({ filters, outputPath }) => {
    const { exportGSTR1Excel: exportGSTR1Excel2 } = await Promise.resolve().then(() => (init_gstr1ExportService(), gstr1ExportService_exports));
    return { filePath: await exportGSTR1Excel2(filters, outputPath) };
  }, disposers, 6e4);
  register("ipc.audit.exportCSV", async ({ filters, outputPath }) => {
    const { exportAuditLogCSV: exportAuditLogCSV2 } = await Promise.resolve().then(() => (init_auditExportService(), auditExportService_exports));
    return { filePath: await exportAuditLogCSV2(filters, outputPath) };
  }, disposers, 6e4);
  register("ipc.audit.exportJSON", async ({ filters, outputPath }) => {
    const { exportAuditLogJSON: exportAuditLogJSON2 } = await Promise.resolve().then(() => (init_auditExportService(), auditExportService_exports));
    return { filePath: await exportAuditLogJSON2(filters, outputPath) };
  }, disposers, 6e4);
  register("ipc.storageType.list", () => listStorageTypes(), disposers);
  register("ipc.storageType.create", createStorageType, disposers);
  register("ipc.storageType.update", ({ id, data }) => updateStorageType(id, data), disposers);
  register("ipc.storageType.delete", ({ id }) => deleteStorageType(id), disposers);
  register("ipc.search.global", globalSearch, disposers);
  register("ipc.search.barcode", ({ code }) => searchByBarcode(code), disposers);
  register("ipc.expiryReturn.create", createExpiryReturn, disposers);
  register("ipc.expiryReturn.list", (payload) => listExpiryReturns(payload), disposers);
  register("ipc.expiryReturn.get", ({ id }) => getExpiryReturnById(id), disposers);
  register("ipc.expiryReturn.report", (payload) => getExpiryLossReport(payload), disposers);
  register("ipc.notification.list", (payload) => listNotifications(payload), disposers);
  register("ipc.notification.markRead", ({ id }) => markAsRead(id), disposers);
  register("ipc.notification.markAllRead", async (payload) => {
    const count = await markAllAsRead(payload?.userId);
    return { count };
  }, disposers);
  register("ipc.notification.unreadCount", async (payload) => {
    const count = await getUnreadCount(payload?.userId);
    return { count };
  }, disposers);
  register("ipc.report.stock", () => getStockReport(), disposers);
  register("ipc.report.customer", () => getCustomerReport(), disposers);
  register("ipc.report.supplier", () => getSupplierReport(), disposers);
  register("ipc.pdf.generate", ({ invoiceId, invoiceType, outputPath }) => generateInvoicePDF({ invoiceId, invoiceType, outputPath }).then((filePath) => ({ filePath })), disposers);
  register("ipc.import.products", ({ rows }) => importProducts(rows), disposers);
  register("ipc.import.customers", ({ rows }) => importCustomers(rows), disposers);
  register("ipc.import.suppliers", ({ rows }) => importSuppliers(rows), disposers);
  register("ipc.job.checkLowStock", () => checkLowStock(), disposers);
  register("ipc.job.checkExpiringBatches", (payload) => checkExpiringBatches(payload?.daysAhead), disposers);
  register("ipc.job.runAllChecks", () => runAllChecks(), disposers);
  register("ipc.job.cleanupNotifications", () => cleanupOldNotifications(), disposers);
  withPermission("ipc.bill.create", createBill, "bills.create", disposers);
  withPermission("ipc.bill.update", ({ id, data, userId }) => updateBill(id, data, userId), "bills.update", disposers);
  register("ipc.bill.get", ({ id }) => getBillById(id), disposers);
  register("ipc.bill.list", (payload) => listBills(payload), disposers);
  withPermission("ipc.bill.finalize", ({ id, userId }) => finalizeBill(id, userId), "bills.finalize", disposers);
  withPermission("ipc.bill.cancel", ({ id, reason, userId }) => cancelBill(id, reason, userId), "bills.cancel", disposers);
  withPermission("ipc.bill.delete", async ({ id, userId, reason, force }) => {
    if (!userId) {
      throw new Error("User ID is required for deletion");
    }
    if (force) {
      await requireAdmin(userId, "Only ADMIN can force delete finalized bills");
    }
    return deleteBill(id, userId, reason, force);
  }, "bills.delete", disposers);
  register("ipc.bill.print", async ({ id, templateId, outputPath }) => {
    const filePath = await printBill({
      billId: id,
      templateId,
      outputPath,
      printToPDF: true
    });
    return { filePath };
  }, disposers, 6e4);
  register("ipc.bill.printToPrinter", async ({ id, templateId, silent }) => {
    await printBill({
      billId: id,
      templateId,
      printToPDF: false,
      silent: silent ?? false
    });
    return { success: true };
  }, disposers, 6e4);
  register("ipc.bill.preview", async ({ id, templateId }) => {
    const html = await previewBill(id, templateId);
    return { html };
  }, disposers, 3e4);
  register("ipc.billTemplate.list", (payload) => listBillTemplates(payload), disposers);
  register("ipc.billTemplate.get", ({ id }) => getBillTemplateById(id), disposers);
  register("ipc.billTemplate.clone", ({ id, name, userId }) => cloneBillTemplate(id, name, userId), disposers);
  register("ipc.billTemplate.validate", async ({ htmlContent, cssContent }) => {
    const { validateTemplate: validateTemplate2 } = await Promise.resolve().then(() => (init_templateValidationService(), templateValidationService_exports));
    return validateTemplate2(htmlContent, cssContent);
  }, disposers);
  register("ipc.billTemplate.isSystem", async ({ templateId }) => {
    const { isSystemTemplate: isSystemTemplate2 } = await Promise.resolve().then(() => (init_templateValidationService(), templateValidationService_exports));
    return { isSystem: await isSystemTemplate2(templateId) };
  }, disposers);
  register("ipc.billTemplate.getVersions", async ({ templateId }) => {
    const { getTemplateVersions: getTemplateVersions2 } = await Promise.resolve().then(() => (init_templateValidationService(), templateValidationService_exports));
    return getTemplateVersions2(templateId);
  }, disposers);
  register("ipc.billTemplate.restoreVersion", async ({ templateId, version, userId }) => {
    const { restoreTemplateVersion: restoreTemplateVersion2 } = await Promise.resolve().then(() => (init_templateValidationService(), templateValidationService_exports));
    await restoreTemplateVersion2(templateId, version, userId);
    return { success: true };
  }, disposers);
  register("ipc.billTemplate.create", createBillTemplate, disposers);
  register("ipc.billTemplate.update", ({ id, data }) => updateBillTemplate(id, data), disposers);
  register("ipc.billTemplate.delete", ({ id }) => deleteBillTemplate(id), disposers);
  register("ipc.billTemplate.setDefault", ({ id }) => setDefaultBillTemplate(id), disposers);
  register("ipc.billTemplate.render", ({ templateId, billId }) => renderBillTemplate(templateId, billId).then((html) => ({ html })), disposers, 3e4);
  register("ipc.billPayment.create", createBillPayment, disposers);
  register("ipc.billPayment.list", (payload) => listBillPayments(payload?.billId), disposers);
  register("ipc.billPayment.delete", ({ id }) => deleteBillPayment(id), disposers);
  register("ipc.billPayment.markChequeCleared", ({ id }) => markBillChequeCleared(id), disposers);
  register("ipc.billPayment.markChequeBounced", ({ id }) => markBillChequeBounced(id), disposers);
  register("ipc.outstanding.getBills", async (filters) => {
    const { getOutstandingBills: getOutstandingBills2 } = await Promise.resolve().then(() => (init_outstandingService(), outstandingService_exports));
    const bills = await getOutstandingBills2(filters);
    return bills.map((bill) => ({
      billId: bill.billId,
      billNumber: bill.billNumber,
      billDate: bill.billDate,
      customerName: bill.customerName,
      supplierName: bill.supplierName,
      totalAmount: bill.totalAmount,
      paidAmount: bill.paidAmount,
      outstanding: bill.outstanding,
      daysOverdue: bill.daysOverdue,
      aging: {
        current: bill.aging.current,
        days30: bill.aging.days30,
        days60: bill.aging.days60,
        days90: bill.aging.days90,
        // Map 90+ bucket from existing 90-day bucket
        days90Plus: bill.aging.days90
      }
    }));
  }, disposers);
  register("ipc.outstanding.getCustomers", async (filters) => {
    const { getCustomerOutstanding: getCustomerOutstanding2 } = await Promise.resolve().then(() => (init_outstandingService(), outstandingService_exports));
    const customers = await getCustomerOutstanding2(filters);
    return customers.map((customer) => ({
      customerId: customer.customerId,
      customerName: customer.customerName,
      totalOutstanding: customer.totalOutstanding,
      bills: customer.bills.map((bill) => ({
        billId: bill.billId,
        billNumber: bill.billNumber,
        outstanding: bill.outstanding,
        daysOverdue: bill.daysOverdue
      })),
      aging: {
        current: customer.aging.current,
        days30: customer.aging.days30,
        days60: customer.aging.days60,
        days90: customer.aging.days90,
        days90Plus: customer.aging.days90
      }
    }));
  }, disposers);
  register("ipc.outstanding.getSuppliers", async (filters) => {
    const { getSupplierOutstanding: getSupplierOutstanding2 } = await Promise.resolve().then(() => (init_outstandingService(), outstandingService_exports));
    const suppliers = await getSupplierOutstanding2(filters);
    return suppliers.map((supplier) => ({
      supplierId: supplier.supplierId,
      supplierName: supplier.supplierName,
      totalOutstanding: supplier.totalOutstanding,
      bills: supplier.bills.map((bill) => ({
        billId: bill.billId,
        billNumber: bill.billNumber,
        outstanding: bill.outstanding,
        daysOverdue: bill.daysOverdue
      })),
      aging: {
        current: supplier.aging.current,
        days30: supplier.aging.days30,
        days60: supplier.aging.days60,
        days90: supplier.aging.days90,
        days90Plus: supplier.aging.days90
      }
    }));
  }, disposers);
  register("ipc.outstanding.reconcileBill", async ({ billId }) => {
    const { reconcileBillOutstanding: reconcileBillOutstanding2 } = await Promise.resolve().then(() => (init_outstandingService(), outstandingService_exports));
    return reconcileBillOutstanding2(billId);
  }, disposers);
  register("ipc.outstanding.autoReconcile", async () => {
    const { autoReconcileAllBills: autoReconcileAllBills2 } = await Promise.resolve().then(() => (init_outstandingService(), outstandingService_exports));
    return autoReconcileAllBills2();
  }, disposers);
  register("ipc.outstanding.validate", async ({ billId }) => {
    const { validateOutstanding: validateOutstanding3 } = await Promise.resolve().then(() => (init_outstandingService(), outstandingService_exports));
    const result = await validateOutstanding3(billId);
    return {
      consistent: result.valid,
      errors: result.error ? [result.error] : []
    };
  }, disposers);
  register("ipc.profit.getBillMargin", async ({ billId }) => {
    const { calculateBillProfitMargin: calculateBillProfitMargin2 } = await Promise.resolve().then(() => (init_profitMarginService(), profitMarginService_exports));
    const margin = await calculateBillProfitMargin2(billId);
    return {
      billId: margin.billId,
      billNumber: margin.billNumber,
      totalAmount: margin.totalAmount,
      totalCost: margin.totalCost,
      totalGST: margin.totalGST,
      totalDiscount: margin.totalDiscount,
      grossProfit: margin.grossProfit,
      netProfit: margin.netProfit,
      profitMargin: margin.profitMargin,
      lines: margin.lines.map((line, index) => ({
        lineNumber: index + 1,
        productName: line.productName,
        costPrice: line.costPrice,
        sellingPrice: line.sellingPrice,
        quantity: line.quantity,
        profit: line.netProfit,
        margin: line.profitMargin
      }))
    };
  }, disposers);
  register("ipc.profit.getProductMargin", async (filters) => {
    const { calculateProductProfitMargin: calculateProductProfitMargin2 } = await Promise.resolve().then(() => (init_profitMarginService(), profitMarginService_exports));
    const products = await calculateProductProfitMargin2(filters);
    return products.map((product) => ({
      productId: product.productId,
      productName: product.productName,
      totalSales: product.totalSales,
      totalCost: product.totalCost,
      grossProfit: product.totalProfit,
      netProfit: product.totalProfit,
      profitMargin: product.profitMargin,
      // Quantity is not tracked in the aggregated structure; approximate as 0 for now
      quantity: 0
    }));
  }, disposers);
  register("ipc.profit.getCompanyMargin", async (filters) => {
    const { calculateCompanyProfitMargin: calculateCompanyProfitMargin2 } = await Promise.resolve().then(() => (init_profitMarginService(), profitMarginService_exports));
    const companies = await calculateCompanyProfitMargin2(filters);
    return companies.map((company) => ({
      companyId: company.companyId,
      companyName: company.companyName,
      totalSales: company.totalSales,
      totalCost: company.totalCost,
      grossProfit: company.totalProfit,
      netProfit: company.totalProfit,
      profitMargin: company.profitMargin
    }));
  }, disposers);
  register("ipc.profit.getComprehensiveReport", async (filters) => {
    const { getComprehensiveProfitReport: getComprehensiveProfitReport2 } = await Promise.resolve().then(() => (init_profitMarginService(), profitMarginService_exports));
    return getComprehensiveProfitReport2(filters);
  }, disposers, 9e4);
  register("ipc.profit.getExpiryLossImpact", async (filters) => {
    const { getExpiryLossImpact: getExpiryLossImpact2 } = await Promise.resolve().then(() => (init_profitMarginService(), profitMarginService_exports));
    return getExpiryLossImpact2(filters);
  }, disposers);
  register("ipc.validation.validateBill", async ({ billData, excludeBillId, userId }) => {
    const { validateBill: validateBill2 } = await Promise.resolve().then(() => (init_validationService(), validationService_exports));
    return validateBill2(billData, excludeBillId, userId);
  }, disposers);
  register("ipc.validation.getBillSummary", async ({ billId }) => {
    const { getBillValidationSummary: getBillValidationSummary2 } = await Promise.resolve().then(() => (init_validationService(), validationService_exports));
    const summary = await getBillValidationSummary2(billId);
    return {
      warnings: summary.warnings.map((w) => ({
        type: w.type,
        severity: w.severity,
        message: w.message,
        overridden: false
      }))
    };
  }, disposers);
  register("ipc.validation.override", async ({ billId, warningType, reason, userId }) => {
    const { overrideValidationWarning: overrideValidationWarning2 } = await Promise.resolve().then(() => (init_validationService(), validationService_exports));
    await overrideValidationWarning2(billId, warningType, reason, userId);
    return { success: true };
  }, disposers);
  register("ipc.consistency.scan", async () => {
    const { runConsistencyScan: runConsistencyScan2 } = await Promise.resolve().then(() => (init_consistencyScannerService(), consistencyScannerService_exports));
    return runConsistencyScan2();
  }, disposers, 12e4);
  withPermission("ipc.consistency.fixIssue", async ({ issue, userId }) => {
    const { fixConsistencyIssue: fixConsistencyIssue2 } = await Promise.resolve().then(() => (init_consistencyScannerService(), consistencyScannerService_exports));
    return fixConsistencyIssue2(issue, userId);
  }, "consistency.fix", disposers);
  withPermission("ipc.consistency.autoFix", async ({ userId }) => {
    const { autoFixAllIssues: autoFixAllIssues2 } = await Promise.resolve().then(() => (init_consistencyScannerService(), consistencyScannerService_exports));
    return autoFixAllIssues2(userId);
  }, "consistency.fix", disposers);
  register("ipc.report.mrPerformance", async (filters) => {
    const { getMRPerformanceReport: getMRPerformanceReport2 } = await Promise.resolve().then(() => (init_mrPerformanceService(), mrPerformanceService_exports));
    return getMRPerformanceReport2(filters);
  }, disposers, 6e4);
  register("ipc.report.doctorROI", async (filters) => {
    const { getDoctorROIReport: getDoctorROIReport2 } = await Promise.resolve().then(() => (init_doctorROIService(), doctorROIService_exports));
    return getDoctorROIReport2(filters);
  }, disposers, 6e4);
  register("ipc.report.outstandingAging", async (filters) => {
    const { getOutstandingBills: getOutstandingBills2 } = await Promise.resolve().then(() => (init_outstandingService(), outstandingService_exports));
    const bills = await getOutstandingBills2(filters);
    return bills.map((bill) => ({
      billId: bill.billId,
      billNumber: bill.billNumber,
      billDate: bill.billDate,
      customerName: bill.customerName,
      supplierName: bill.supplierName,
      totalAmount: bill.totalAmount,
      paidAmount: bill.paidAmount,
      outstanding: bill.outstanding,
      daysOverdue: bill.daysOverdue,
      aging: {
        current: bill.aging.current,
        days30: bill.aging.days30,
        days60: bill.aging.days60,
        days90: bill.aging.days90,
        days90Plus: bill.aging.days90
      }
    }));
  }, disposers, 6e4);
  register("ipc.report.deadStock", async (filters) => {
    const { getDeadStock: getDeadStock2 } = await Promise.resolve().then(() => (init_deadStockService(), deadStockService_exports));
    return getDeadStock2(filters);
  }, disposers, 6e4);
  register("ipc.report.expiryLoss", async (filters) => {
    const { getExpiryLossAccounting: getExpiryLossAccounting2 } = await Promise.resolve().then(() => (init_deadStockService(), deadStockService_exports));
    const report = await getExpiryLossAccounting2(filters);
    return {
      totalLoss: report.totalLossAmount,
      byProduct: report.byProduct,
      bySupplier: report.bySupplier
    };
  }, disposers, 6e4);
  register("ipc.report.companyMargin", async (filters) => {
    const { calculateCompanyProfitMargin: calculateCompanyProfitMargin2 } = await Promise.resolve().then(() => (init_profitMarginService(), profitMarginService_exports));
    const companies = await calculateCompanyProfitMargin2(filters);
    return companies.map((company) => ({
      companyId: company.companyId,
      companyName: company.companyName,
      totalSales: company.totalSales,
      totalCost: company.totalCost,
      grossProfit: company.totalProfit,
      netProfit: company.totalProfit,
      profitMargin: company.profitMargin
    }));
  }, disposers, 6e4);
  register("ipc.report.purchaseVsSales", async (filters) => {
    const { getPurchaseVsSalesVariance: getPurchaseVsSalesVariance2 } = await Promise.resolve().then(() => (init_reportService(), reportService_exports));
    return getPurchaseVsSalesVariance2(filters);
  }, disposers, 6e4);
  register("ipc.companyInfo.get", () => getCompanyInfo(), disposers);
  register("ipc.companyInfo.save", saveCompanyInfo, disposers);
  register("templates:list", listTemplatesHandler, disposers);
  register("templates:load", loadTemplateHandler, disposers);
  register("templates:save", saveTemplateHandler, disposers);
  register("templates:render", renderTemplateHandler, disposers);
  register("templates:print", printTemplateHandler, disposers);
  register("userInfo:get", () => getCompanyInfo(), disposers);
  register("userInfo:set", saveCompanyInfo, disposers);
  try {
    console.log("Initializing templates from disk...");
    const { initializeTemplatesFromDisk: initializeTemplatesFromDisk2 } = await Promise.resolve().then(() => (init_templateInitializationService(), templateInitializationService_exports));
    const result = await initializeTemplatesFromDisk2();
    console.log(`Templates initialized: ${result.created} created, ${result.updated} updated, ${result.skipped} skipped`);
    if (result.errors.length > 0) {
      console.warn("Template initialization errors:", result.errors);
    }
  } catch (error) {
    console.error("Failed to initialize templates:", error);
  }
  console.log("All IPC handlers registered successfully");
  return () => disposers.forEach((dispose) => dispose());
};

// electron/main.ts
init_prismaClient();
init_errorHandler();
var isDevelopment = process.env.NODE_ENV === "development";
initializeErrorHandlers();
var isHighMemory = false;
var consecutiveHighMemory = 0;
var checkMemoryUsage = () => {
  const memUsage = process.memoryUsage();
  const heapUsedPercent = memUsage.heapUsed / memUsage.heapTotal * 100;
  const heapUsedMB = Math.round(memUsage.heapUsed / 1024 / 1024);
  const rssMB = Math.round(memUsage.rss / 1024 / 1024);
  if (heapUsedPercent > 85 || rssMB > 1500) {
    consecutiveHighMemory++;
    if (!isHighMemory || consecutiveHighMemory % 5 === 0) {
      isHighMemory = true;
      console.warn(`[Memory Warning] Heap: ${heapUsedMB}MB (${Math.round(heapUsedPercent)}%), RSS: ${rssMB}MB`);
      if (global.gc) {
        global.gc();
        console.log("Garbage collection triggered");
      }
      if (heapUsedPercent > 95 || rssMB > 2e3) {
        console.error("[Critical Memory] Application may freeze. Consider restarting.");
      }
    }
  } else if (heapUsedPercent < 70 && rssMB < 1e3) {
    if (isHighMemory) {
      console.log(`[Memory Normalized] Heap: ${heapUsedMB}MB, RSS: ${rssMB}MB`);
    }
    isHighMemory = false;
    consecutiveHighMemory = 0;
  }
};
setInterval(checkMemoryUsage, 1e4);
var getPreloadPath = () => {
  if (isDevelopment) {
    return import_node_path4.default.join(__dirname, "preload.js");
  }
  return import_node_path4.default.join(__dirname, "preload.js");
};
var getRendererEntry = () => {
  if (isDevelopment && process.env.VITE_DEV_SERVER_URL) {
    return process.env.VITE_DEV_SERVER_URL;
  }
  const rendererPath = import_node_path4.default.join(import_electron14.app.getAppPath(), "dist_renderer", "index.html");
  return import_node_url.default.pathToFileURL(rendererPath).toString();
};
async function createWindow() {
  const mainWindow = new import_electron14.BrowserWindow({
    width: 1400,
    height: 900,
    minWidth: 1200,
    minHeight: 720,
    show: false,
    webPreferences: {
      preload: getPreloadPath(),
      sandbox: false,
      contextIsolation: true,
      nodeIntegration: false
    }
  });
  mainWindow.once("ready-to-show", () => {
    mainWindow.show();
    if (isDevelopment) {
      mainWindow.webContents.openDevTools({ mode: "detach" });
    }
  });
  const entry = getRendererEntry();
  await mainWindow.loadURL(entry);
}
function registerLifecycleHooks() {
  import_electron14.app.on("window-all-closed", () => {
    if (process.platform !== "darwin") {
      import_electron14.app.quit();
    }
  });
  import_electron14.app.on("activate", () => {
    if (import_electron14.BrowserWindow.getAllWindows().length === 0) {
      createWindow().catch((error) => {
        console.error("Failed to recreate window", error);
      });
    }
  });
}
var disposeIpc = null;
async function initIpc() {
  try {
    import_electron14.ipcMain.handle("ping", () => "pong");
    disposeIpc = await registerIpcHandlers();
    console.log("IPC handlers registered successfully");
  } catch (error) {
    console.error("Failed to register IPC handlers:", error);
    throw error;
  }
}
import_electron14.app.whenReady().then(async () => {
  try {
    console.log("App ready, starting initialization...");
    registerLifecycleHooks();
    console.log("Lifecycle hooks registered");
    try {
      await Promise.race([
        initIpc(),
        new Promise(
          (_, reject) => setTimeout(() => reject(new Error("IPC initialization timeout")), 3e4)
        )
      ]);
      console.log("IPC initialized, creating window...");
    } catch (ipcError) {
      console.error("IPC initialization failed:", ipcError);
      console.warn("Continuing with partial IPC initialization...");
    }
    return createWindow();
  } catch (error) {
    console.error("Error during initialization:", error);
    try {
      const errorWindow = new import_electron14.BrowserWindow({
        width: 600,
        height: 400,
        show: true,
        webPreferences: { nodeIntegration: false, contextIsolation: true }
      });
      errorWindow.loadURL(`data:text/html,<html><body><h1>Initialization Error</h1><p>${error instanceof Error ? error.message : String(error)}</p><p>Please check the console for details.</p></body></html>`);
    } catch {
      import_electron14.app.quit();
    }
  }
}).catch((error) => {
  console.error("Failed to start application", error);
  setTimeout(() => import_electron14.app.quit(), 5e3);
});
import_electron14.app.on("before-quit", async () => {
  disposeIpc?.();
  await disconnectPrisma();
});
/*! Bundled license information:

bcryptjs/dist/bcrypt.js:
  (**
   * @license bcrypt.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
   * Released under the Apache License, Version 2.0
   * see: https://github.com/dcodeIO/bcrypt.js for details
   *)
*/
